#!/usr/bin/env expect
#!/usr/local/bin/expect
#!/usr/bin/expect
#!/volume/buildtools/bin/expect
# vim: set ft=tcl cc=80:
#
#adjust above for different server...annoying but seems no unified solution
#
#
#these looks good trick, but relies on "tclsh" that some system may not have!
#- they maybe have only tclsh8.5, tclsh8.6, etc...not portable either
##!/bin/sh
## -*- tcl -*-
## The next line is executed by /bin/sh, but not tcl \
#exec tclsh "$0" ${1+"$@"}
#package require Expect

#the above is flexible, but may generate some issue - depending on the "PATH"
#env, unexpected expect version may be used. if the expect path is known,
#better just use it explicitly.
#
##e.g.: in juniper svl server, use this:
##!/usr/local/bin/expect
#
#another method way to avoid unexpected expect to be used, is to run script as
#below:
#
#      /usr/local/bin/expect crtc -H abc@jtac
#
#
#license {{{1}}}
# one line to give the program's name and an idea of what it does.
# Copyright (C) 2014  ping song pings@juniper.net
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


#experimental: running purely in background
#if {[fork]!=0} exit
#disconnect



#set yesno abc
#data {{{1}}}
#
#test in cron, doens't work well.

#set env(USER) pings
#set env(SHELL) bash

#host session config_file default {{{2}}}
#these 3 values will be changed based on last param in command line
#so they can't be merged to $config!
set crtc_dir [file dirname $argv0]              ;#get folder name
set crtc [file rootname [file tail $argv0]]     ;#get basename "crtc"
set config_file "$crtc_dir/$crtc.conf"
#puts "config_file:$config_file"
set host "LOCALHOST"
set session "LOCALHOST"

exp_version -exit 5.0
if {[exp_version] < 5.44} {
    puts "!!!your expect version [exp_version] seems too low!!!"
    puts "!!!this script was created/tested only under expect 5.45 or 5.44!!!" 
    puts "!!!with your current expect version, something may go wrong!" 
} 

#this may cause issues: (not quite sure this is the trigger)
# unable to realloc 600000002 bytes and coredump
#
#match_max -d 100000000
#
#10M cache of output is enough for most command? (show config)
match_max -d 10000000

set myinteract_depth 1

proc CONST { key } {    ;#{{{2}}}
    #format: xxxyzz
    #        ---        type
    #           -       sub-type
    #            --     value
    #exit code {{{3}}}
    set constant(EXIT_ON_1ARGC_DONE)              101010
    set constant(EXIT_ON_FAIL_CREATE_LOG_DIR)     101110
    set constant(EXIT_ON_NO_PA)                   101210
    set constant(EXIT_ON_NO_RESOLVE)              101310
    set constant(EXIT_ON_QUIT_FROM_SLEEP)         101410
    set constant(EXIT_ON_FULL_BUFF)               101510
    set constant(EXIT_ON_CONFIGURED_ACTION)       101610
    set constant(EXIT_ON_RETRY_MAX)               101710

    #return value:mysleep {{{3}}}
    set constant(RETURN_SLEEP_CONTINUE)           112010
    set constant(RETURN_SLEEP_BREAK)              112020
    set constant(RETURN_SLEEP_ZERO)               112030

    #return value:myexpect {{{3}}}
    set constant(RETURN_EXPECT_SENDFIRST0_NORMAL) 111010
    set constant(RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN)   111011
    set constant(RETURN_EXPECT_SENDFIRST1_NORMAL) 111012

    set constant(RETURN_EXPECT_USER_INTERUPT)     111110

    set constant(RETURN_EXPECT_CONN_UNABLE)       111210
    set constant(RETURN_EXPECT_CONN_CLOSED)       111211
    set constant(RETURN_EXPECT_CONN_CONSOLE1)     111213
    set constant(RETURN_EXPECT_NOT_RESOLVED)      111214
    set constant(RETURN_EXPECT_BROKEN_PIPE)       111215

    set constant(RETURN_EXPECT_TIMEOUT)           111310
    set constant(RETURN_EXPECT_EOF)               111311
    set constant(RETURN_EXPECT_FULL_BUFFER)       111312

    #return value:do_pag {{{3}}}
    set constant(RETURN_DO_PA5_NO_PA)             121010
    set constant(RETURN_DO_PA5_NORMAL)            121110
    set constant(RETURN_DO_PA5_SIGQUIT)           121210

    #actions_on_timeout {{{3}}}
    #useful under multiple host
    #deprecated (2016-03-30): no need these, just return strings are simpler:
    #CTRLC CONTINUE NONE CLOSE EXIT
    #
    #set constant(ACTIONS_ON_TIMEOUT_CTRLC)        131010
    #set constant(ACTIONS_ON_TIMEOUT_CONTINUE)     131011
    #set constant(ACTIONS_ON_TIMEOUT_NONE)         131012
    #set constant(ACTIONS_ON_TIMEOUT_CLOSE)        131013
    #set constant(ACTIONS_ON_TIMEOUT_EXIT)         131014

    #return value:GRES {{{3}}}
    set constant(RETURN_GRES_SUCCESS)             141010
    set constant(RETURN_GRES_FORCE_RPD)           141110
    set constant(RETURN_GRES_SESSION_CLOSED)      141210
    set constant(RETURN_GRES_FAILED)              141310
    set constant(RETURN_GRES_TIMEOUT)             141410

    #return value:spawn_login {{{3}}}
    set constant(RETURN_SPAWN_LOGIN_NORMAL)       151010
    set constant(RETURN_SPAWN_LOGIN_LOCALSHELL)   151110

    #return value:myinteract {{{3}}}
    set constant(RETURN_INTERACT_NORMAL)          161010

    #control characters {{{3}}}
    #http://www.i-logic.com/serial/ascii.htm
    #
    #1   00000001  01  SOH   (start of header)          <CONTROL><A>
    #2   00000010  02  STX   (start of text)            <CONTROL><B>
    #3   00000011  03  ETX   (end of text)              <CONTROL><C>
    #4   00000100  04  EOT   (end of transmission)      <CONTROL><D>
    #5   00000101  05  ENQ   (enquiry)                  <CONTROL><E>
    #6   00000110  06  ACK   (acknowledge)              <CONTROL><F>
    #7   00000111  07  BEL   (bell)                     <CONTROL><G>
    #8   00001000  08  BS    (backspace)     <CONTROL><H>
    #9   00001001  09  HT    (horizontal tab)        <CONTROL><I>
    #10  00001010  0A  LF    (line feed)     <CONTROL><J>
    #11  00001011  0B  VT    (vertical tab)  <CONTROL><K>
    #12  00001100  0C  FF    (form feed)     <CONTROL><L>
    #13  00001101  0D  CR    (carriage return)       <CONTROL><M>
    #14  00001110  0E  SO    (shift out)     <CONTROL><N>
    #15  00001111  0F  SI    (shift in)      <CONTROL><O>
    #16  00010000  10  DLE   (data link escape)      <CONTROL><P>
    #17  00010001  11  DC1   (device control1)       <CONTROL><Q>    XON
    #18  00010010  12  DC2   (device control2)       <CONTROL><R>
    #19  00010011  13  DC3   (device control3)       <CONTROL><S>    XOFF
    #20  00010100  14  DC4   (device control4)       <CONTROL><T>
    #21  00010101  15  NAK   (negative acknowledge)  <CONTROL><U>
    #22  00010110  16  SYN   (syncronization)        <CONTROL><V>
    #23  00010111  17  ETB   (end of text block)     <CONTROL><W>
    #24  00011000  18  CAN   (cancel)        <CONTROL><X>
    #25  00011001  19  EM    (end of medium) <CONTROL><Y>
    #26  00011010  1A  SUB   (substitute)               <CONTROL><Z>
    #27  00011011  1B  ESC   (escape)        <CONTROL><[>
    #28  00011100  1C  FS    (file separator)        <CONTROL><SHIFT><L>
    #29  00011101  1D  GS    (group separator)       <CONTROL><SHIFT><M>
    #30  00011110  1E  RS    (record separator)      <CONTROL><SHIFT><N>
    #31  00011111  1F  US    (unit separator)        <CONTROL><SHIFT><O>
    #32  00100000  20  SP    (space) <SPACEBAR>

    #Dec Hex    Dec Hex    Dec Hex  Dec Hex  Dec Hex  Dec Hex   Dec Hex   Dec Hex   
    #  0 00 NUL  16 10 DLE  32 20    48 30 0  64 40 @  80 50 P   96 60 `  112 70 p  
    #  1 01 SOH  17 11 DC1  33 21 !  49 31 1  65 41 A  81 51 Q   97 61 a  113 71 q  
    #  2 02 STX  18 12 DC2  34 22 "  50 32 2  66 42 B  82 52 R   98 62 b  114 72 r  
    #  3 03 ETX  19 13 DC3  35 23 #  51 33 3  67 43 C  83 53 S   99 63 c  115 73 s  
    #  4 04 EOT  20 14 DC4  36 24 $  52 34 4  68 44 D  84 54 T  100 64 d  116 74 t  
    #  5 05 ENQ  21 15 NAK  37 25 %  53 35 5  69 45 E  85 55 U  101 65 e  117 75 u  
    #  6 06 ACK  22 16 SYN  38 26 &  54 36 6  70 46 F  86 56 V  102 66 f  118 76 v  
    #  7 07 BEL  23 17 ETB  39 27 '  55 37 7  71 47 G  87 57 W  103 67 g  119 77 w  
    #  8 08 BS   24 18 CAN  40 28 (  56 38 8  72 48 H  88 58 X  104 68 h  120 78 x  
    #  9 09 HT   25 19 EM   41 29 )  57 39 9  73 49 I  89 59 Y  105 69 i  121 79 y  
    # 10 0A LF   26 1A SUB  42 2A *  58 3A :  74 4A J  90 5A Z  106 6A j  122 7A z  
    # 11 0B VT   27 1B ESC  43 2B +  59 3B ;  75 4B K  91 5B [  107 6B k  123 7B {  
    # 12 0C FF   28 1C FS   44 2C ,  60 3C <  76 4C L  92 5C \  108 6C l  124 7C |  
    # 13 0D CR   29 1D GS   45 2D -  61 3D =  77 4D M  93 5D ]  109 6D m  125 7D }  
    # 14 0E SO   30 1E RS   46 2E .  62 3E >  78 4E N  94 5E ^  110 6E n  126 7E ~  
    # 15 0F SI   31 1F US   47 2F /  63 3F ?  79 4F O  95 5F _  111 6F o  127 7F DEL 

    set constant(CTRL_A)                  "\x01"
    set constant(CTRL_B)                  "\x02"
    set constant(CTRL_C)                  "\x03"
    set constant(CTRL_D)                  "\x04"
    set constant(CTRL_E)                  "\x05"
    set constant(CTRL_F)                  "\x06"
    set constant(CTRL_G)                  "\x07"
    set constant(CTRL_H)                  "\x08"
    set constant(CTRL_I)                  "\x09"
    set constant(CTRL_J)                  "\x0a"
    set constant(CTRL_K)                  "\x0b"
    set constant(CTRL_L)                  "\x0c"
    set constant(CTRL_M)                  "\x0d"
    set constant(CTRL_N)                  "\x0e"
    set constant(CTRL_O)                  "\x0f"
    set constant(CTRL_P)                  "\x10"
    set constant(CTRL_Q)                  "\x11"
    set constant(CTRL_R)                  "\x12"
    set constant(CTRL_S)                  "\x13"
    set constant(CTRL_T)                  "\x14"
    set constant(CTRL_U)                  "\x15"
    set constant(CTRL_V)                  "\x16"
    set constant(CTRL_W)                  "\x17"
    set constant(CTRL_X)                  "\x18"
    set constant(CTRL_Y)                  "\x19"
    set constant(CTRL_Z)                  "\x1a"
    set constant(ESC)                     "\x1B"

    #Dec Hex           Dec Hex
    # 96 60 `          112 70 p
    # 97 61 a          113 71 q
    # 98 62 b          114 72 r
    # 99 63 c          115 73 s
    #100 64 d          116 74 t
    #101 65 e          117 75 u
    #102 66 f          118 76 v
    #103 67 g          119 77 w
    #104 68 h          120 78 x
    #105 69 i          121 79 y
    #106 6A j          122 7A z
    #107 6B k          123 7B {
    #108 6C l          124 7C |
    #109 6D m          125 7D }
    #110 6E n          126 7E ~
    #111 6F o          127 7F DEL
    #
    #a neater way:
    #
    #P330
    ##convert a char to its interger equivlent in ascii
    #scan $char %c i
    ##-96:convert a lower case value to a control value, 
    ##format converts the integer value back to an ascii char
    #set ctrl_char [format %c [expr $i-96]]
    #
    #why bother this conversion? string is same good, except for exit code

    set constant(CR)                    "\r"

    return $constant($key)

    #return $key
}

#exit status {{{2}}}
#1      got "connection closed by foreigh host"
#2      got eof
#3      got full_buffer
#4      GRES failed
#5      timeout without in GRES without a match
#6      wrong CLI options
#7      failed to create log dir
#8      issue reproduced
#9
#11     line number too big in -R
#12     session does not exists
#13     when getting "telnet: Unable to connect to remote host"
#14     timeout_login expired


#optlist & optmap {{{2}}}
set optlist "-(a|A|b|B|c|C|d|D|e|E|f|F|g        \
              |h|H|i|I|j|J|k|K|l|L|m|M|n|N      \
              |o|O|p|P|q|Q|r|R|s|S|t|T|u|U      \
              |V|v|w|W|x|X|y|Y|z|Z)"

array set optmap {                   \
    "-a" attribute                   \
    "-A" auto_paging                 \
    "-B" post_commands               \
    "-b" pre_commands                \
    "-c" commands                    \
    "-C" config_file                 \
    "-d" debug                       \
    "-D" max_hits                    \
    "-e" expect                      \
    "-E" EXPECT                      \
    "-f" log_filename                \
    "-F" cmd_filename                \
    "-g" interval_cmd                \
    "-H" hideinfo                    \
    "-h" hosts                       \
    "-i" interval_cmds               \
    "-I" issue                       \
    "-j" project                     \
    "-J" eventmonitor                \
    "-k" send_usage_stats            \
    "-K" env_proof                   \
    "-l" emailto                     \
    "-L" log_when                    \
    "-m" max_rounds                  \
    "-M" local_task                  \
    "-n" max_rounds                  \
    "-N" reproduced_no               \
    "-o" login_only                  \
    "-O" emailbody                   \
    "-p" persistent                  \
    "-P" parallel                    \
    "-q" nointeract                  \
    "-Q" features                   \
    "-r" reconnect_interval          \
    "-R" regex_vars                  \
    "-s" send                        \
    "-S" SEND                        \
    "-t" timestamp                   \
    "-T" timestamp_output_line       \
    "-u" redirect_inshell          \
    "-U" login_succeed_signature     \
    "-V" print_matched_value         \
    "-v" verbose                     \
    "-w" timeout_login              \
    "-W" timeout_cmd                \
    "-x" all_met                     \
    "-X" lock_session                \
    "-y" easyvar                     \
    "-Y" reproduced_yes              \
    "-z" compress_log                \
    "-Z" no_anti_idle                \
}



set config_default { ;#{{{2}}}

    #generic options array {{{3}}}

    set options(datasent_noreturn)               0
    set options(send_usage_stats)            0
    #used to parse session name from the login name
    #e.g.: use below regex to capture a substring in $session and use the value
    #as the $session
    #which can be then used in the steps
    #set sessionname_regex {\S+0(\d)}
    set options(sessionname_regex)         ""

    set options(kibitz_kill_onfail)     1

    set options(req_win_title_chg)      "securecrt"

    #test only, don't enable
    set options(double_echo)            0
    set options(prefix_mark)            "HOST"

    #if set(-Q, !N), toggle all features under interact
    #useful when: 
    #1. something not working well because of the features
    #2. performance booster
    #
    #3:
    #    full features
    #2:
    #    flexible features
    #1:
    #    keep all patterns from user keystroke as full features
    #    disable all dyanmic process input patterns under interact.
    #0: 
    #    disable most patterns from user keystroke.
    #    disable all dyanmic process input patterns under interact.
    #
    set options(features)              2       ;#-Q
    
    #no use. simply set features 0 will be it
    ##disable featurs(set 0) when user start to type 
    ##better performance when running in a slow server
    #set options(type_to_disable_features)          0

    #use user_patterns to compose dynamic code 
    #
    #* for expect (during automation),or 
    #* for interact.
    #
    # 0: not for any of automation/interact
    # 1: expect_only: compose myexpect dynamically, during automation only
    # 2: interact_only: compose myinteract dynamically, during interaction
    # 3: both
    #set to 1 or 0 when performance under interactive mode is a concern
    set options(enable_user_patterns)   3       

    #compose myexpect with "match any" technique, it works:
    #
    #* during automation, 
    #* when enable_user_patterns enabled (1, or 3)
    #
    #this allows the detection of any output activities when trying to match
    #any patterns. one benefit is, the timeout (1800s here) really means there
    #is no any output during 1800s. if there is single chars from rsync/lftp
    #apps pop up (say, copy progress bar update: 71% 72%), timeout will be
    #reset. so 1800s here really means 1800s total silence -> this gives real
    #issue than that just because a huge file is being copied so the next
    #prompt took long time to appear...
    set options(expect_matchany)        1

    #when doing "RETRY", set a max limit instead of doing endless
    set options(retry_max)              "3"

    #if set, "Connection to 10.85.4.45 closed" will not trigger script to exit
    #useful when viewing log/text files (which might contain these key words)
    set options(no_reconnect_on_interact) 0

    set options(cmd_filename)           "default.txt"
    set options(cmd_file_dir)           "~/cmd_files"
    set options(retry_interval)         30
    set options(local_task)             0
    
    #when set to 1, skip environmental vars
    set options(env_proof)              0

    set options(auto_resolve)           1
    set options(eventmonitor)           0
    set options(redirect_inshell)       1
    set options(repeat_expand)          1

    #difference with debug: give more formal, intuitive output,not for debugging
    set options(verbose)                1

    set options(run_at)                 ""
    set options(key_interact)           "\\r"   ;#press enter to interupt
    #set options(key_interact)          "\x1B"  ;#press escape to interupt
    set options(key_interact)           ESC
    set options(key_background)         CTRL_F    ;#ctrl-f
    set options(key_background)         CTRL_G    ;#ctrl-g
    set options(key_background)         CTRL_Z    ;#ctrl-g
    #set options(controlC)               \x03
    #set options(controlC)               [CONST CTRL_C]


    set options(pattern_no_match)       "ThisIsAlmostImpossibleToBeMatched"
    set options(pattern_more_const)     {(--\(more \d+%\)--|--\(more\)--|--More--)}
    set options(pattern_more_key)       {\r}
    set options(pattern_more_key)       { }
    set options(pattern_timestamp)      "\r"
    set options(pattern_timestamp_verbose_const) "(\[^\r\]*)\r\n"
    set options(pattern_cmd_input)      ".+"
    #set options(pattern_common_prompt) "(% |> |# |\\\$ |%|>|#|\\\$)$"
    #this is more compact, but introduced expect_out(2,string), not sure any
    #impact
    set options(pattern_common_prompt) "((%|>|#|\\\$) ?)$"
    set options(pattern_continue_automation)       " |\\r"
    set options(pattern_break_automation) "q"
    set options(pattern_exit_script) "Q"
    set options(pattern_not_resolve_msg) "ould not resolve"
    set options(pattern_connection_unable) \
        "telnet: Unable to connect to remote host"
    set options(pattern_console_msg)    \
        "Type the hot key to suspend the connection: <CTRL>Z"
    #tcpoptions(ssh) session reset: Connection to DT404JVPE closed by foreign host
    #tcpoptions(ssh) session timeout: "Timeout, server 10.85.47.3 not responding"
    set options(pattern_connection_close_msg) \
            "Connection closed.*\\n|Connection to (\\d{1,3}\\.){3}\\d{1,3}\
            closed|Connection to \\S\+ closed|Connection reset by peer"
    set options(pattern_connection_not_responding) "Timeout,\
            server (\\d{1,3}\\.){3}\\d{1,3} not responding"
    set options(pattern_broken_pipe)    "Write failed: Broken pipe"
    set options(pattern_gres_not_ready) \
        "Not ready for mastership switch, try after \\d+ secs.*"
    set options(pattern_gres_success)   "routing engine becomes the master"


    set options(pattern_more)           $options(pattern_no_match)
    set options(pattern_timestamp_verbose) $options(pattern_timestamp_verbose_const)

    set options(download_folder)        "~/"
    set options(log_dir)                "~/logs"
    set options(log_fullname)           ""
    #%S:will be substitued to abc@jtac, looks most proper log file name
    set options(log_filename)           "%S.log"
    #set options(log_fullname)       "$options(log_dir)/crtc_session.log"
    #set options(dataformat) {"%s,%s"}   #<------use csv as data format
    #set options(data) "$packets $pps"   #<------data to export 
    #set options(datafile) "test.csv"    #<------file name
    #tcl native clock is much more portable/stable than external tool
    #set time [exec date +%Y-%m%d-%H%M-%S]
    #set time [exec date ]
    #set options(time_now) [clock format [clock seconds]]
    #
    #option 1: use double { } instead of triple, to avoiding mixing with source code tree
    #but when viewing log, set foldmarker={{,}}
    #option 2: use trick, instead of write explicit triple braces, use string
    #repeat to generate.
    set options(log_seperator)          "
    <<<<<<<<<<<<<<<<<<< new logs since: <<<<<<<<<<<<<<<<<<<<<<<
    < [time_now] $env(USER) [string repeat \{ 3]1[string repeat \} 3] <
    <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    "
    set options(log_when)               1     ;#0: no logging
                                              ;#1: after successful login
                                              ;#2: after automations
                                              ;#others: log everything

    set options(debug)                  0                     ;#-d/D
    set options(project)                9
    set options(lock_session)           0     ;#-X: set key_interact 
                                              ;# 1: lock dead: to an impossible value
                                              ;# 0: no lock, use default key to interupt
                                              ;# a CHAR: use specified char to interupt
    set options(nointeract)             0     ;#-q/Q:quickmode
    set options(hideinfo)               0     ;#-H
    set options(interval_cmd)           0     ;#-I, intv between cmd in cmds
    set options(interval_cmds)          0     ;#-i, intv between cmds
    set options(interval_cmds_min)      0     ;#-i, min intv between cmds
    set options(interval_cmds_max)      0     ;#-i, max intv between cmds
    set options(interval_gres)          300   ;#
    set options(timeout_login)         20    ;#-w
    set options(timeout_cmd)           20    ;#-W
    set options(max_rounds)             1     ;#-n
    set options(max_hits)               1     ;#
    set options(alternate_on_hit)       0     ;#
    set options(exit_sync)              1     ;#-k
    set options(persistent)             0     ;#-p
    set options(login_only)             0     ;#-o
    set options(send_initial_cr)        0
    set options(auto_paging)            0     ;#-A
    set options(timestamp)              0     ;#-t
    set options(continue_on_reconnect)  1 ;#cont from where leftoff after reconnect
    set options(reconnect_interval)     10    ;#-r
    set options(reload_conf_inloop)     0     ;# refresh conf file in iterations
 
    #these 4 options are a little bit tricky and messy:
    #
    #* reconnect_on_event and 
    #* terminate_on_event
    #* actions_on_timeout_login
    #* actions_on_timeout_cmd
    #
    #these two options currently only works for login process (spawn_login)
    #set options(reconnect_on_event)     "RETURN_EXPECT_TIMEOUT \
    #                                    RETURN_EXPECT_BROKEN_PIPE \
    #                                    RETURN_EXPECT_CONN_CLOSED \
    #                                    RETURN_EXPECT_CONN_UNABLE \
    #                                    "

    #                                    #RETURN_EXPECT_NOT_RESOLVED
    #set options(terminate_on_event)        "RETURN_EXPECT_TIMEOUT \
    #                                    RETURN_EXPECT_NOT_RESOLVED \
    #                                    RETURN_EXPECT_BROKEN_PIPE \
    #                                    RETURN_EXPECT_CONN_CLOSED \
    #                                    RETURN_EXPECT_CONN_UNABLE \
    #                                   "


    ##not actually in use
    #set options(actions_on_timeout_login) "CLOSE"

    ##this is used only for cmd sending (do_pags during_cmd)
    #set options(actions_on_timeout_cmd)  "CTRLC"
    #                                    #NONE
    #                                    #RETRY
    #                                    #CLOSE
    #                                    #CONTINUE
    #                                    #EXIT


    set options(actions_on_hit)         "EMAIL EXEC_collect EXIT_MAX"
    set options(actions_on_nohit)       "EXEC_test"

    #two timeout are maitained here: from user, or from process
    #user input timeout: is used to detect only user idleness, 
    #    "flexible feature" make use of this to switch between fast and monitor
    #    mode
    #process input timeout: is used to detect both process and user idleness
    #    useful to send anti_idle_string, only when both are idle, but not when
    #    only user is idle (e.g., during a long time file transfer, or a huge
    #    show config dump)
    #in practice, to make flexible feature("features 2") also works during log
    #monitoring(proc input may keep going), better to make user_input less
    #timeout than proc_input, 
    set options(anti_idle_timeout_user_input)      50
    set options(anti_idle_timeout_proc_input)      60
    #set options(anti_idle_timeout)      60
    set options(anti_idle_string)       " \177"	;#type space then delete
    set options(anti_idle_string) 	" \07"	;#type ctrl-g, good for editor 
    set options(no_anti_idle)           0

    set options(compress_log)           1     ;#-z
    #set options(issue_monitor)          0     ;#-M
    set options(print_matched_value)    0
    set options(match_means_issue)      0     ;#only used when no issue defined
    set options(nomatch_means_issue)    0
    set options(easyvar)                1
    set options(all_met)                0
    set options(default_domain)         "juniper.net"
    set options(email_on_event)         "EMAIL_ON_HIT \
                                        "
    #                                   EMAIL_LOG_ON_LOGIN
    set options(emailto)                "$env(USER)@$options(default_domain)" ;#-L
    #set emailto pings@juniper.net  ;#for testing only
    set options(emailsub)  "notification from crtc!"
    set options(emailbody) "check your crtc logs for what happened" 
    set options(headless)               0
    set options(sigquit)                0
    set options(automation_non_complete_msg) ""
    set options(parallel)               0
    set options(treat_special_char_as_pa) 1
    #this is from unix tool `date`
    #set options(dateformat)             "+%b %d %H:%M:%S %Y"
    #this is from tcl's native `clock`
    set options(dateformat)             "%Y_%m%d_%H%M_%S"
    set options(current_time_cmd)       {[clock format [clock seconds] -format $dateformat]}
    set options(clockcmd)               "show system clock"        ;#no use yet
    set options(flag_check_method)      1         ;#any flag indicate a hit
    set options(automation_timeout)     5      ;#start automation if no input
    #set emaildomain [expr ("[domainname]"==0)?"$default_domain":[domainname]]
    set options(usertype)               1
    set options(userinfile)             "userinfile"
    set options(useroutfile)            "useroutfile"

    #version history
    set options(version) "crtc version 0.7 by pings@juniper.net 1/24/2014" 
    set options(version) "crtc version 0.82 by pings@juniper.net 3/19/2015" 
    set options(version) "crtc version 0.8 by pings@juniper.net 3/15/2015" 
    set options(version) "crtc version 0.83 by pings@juniper.net 6/2015"
    set options(version) "crtc version 0.84 by pings@juniper.net 7/2015"
    set options(version) "crtc version 0.85 by pings@juniper.net 7/2015"
    set options(version) "crtc version 0.86 by pings@juniper.net 7/2015"
    set options(version) "crtc version 0.87 by pings@juniper.net 10/2015"
    set options(version) "crtc version 0.9 by pings@juniper.net 2/2016"
    set options(version) "crtc version 0.92 by pings@juniper.net 3/2016"
    set options(version) "crtc version 0.94 by pings@juniper.net 5/2016"
    set options(version) "crtc version 0.95 by pings@juniper.net 6/2016"
    set options(version) "crtc version 0.96 by pings@juniper.net 7/2016"
    #this will be the last version number!
    set options(version) "crtc version 0.97 by pings@juniper.net 8/2016"
    set options(version) "crtc version 0.98 by pings@juniper.net 11/2016"
    set options(version) "crtc version 0.99 by pings@juniper.net 11/2016"
    set options(login_succeed_signature) "login succeeded, it's all yours!\n\
                                         --\[$options(version)\]"
    set options(tips_on_login) 1

    #if [regexp -nocase {cygwin} [exec uname -a]] {}
    if [regexp -nocase {cygwin} $tcl_platform(os)] {
        set options(os) "cygwin"
        set options(emailapp) "email"
    # elseif [regexp -nocase {linux} [exec uname -a]] {}
    } elseif [regexp -nocase {linux} $tcl_platform(os)] {
        set options(os) "linux"
        set options(emailapp) "mail"
    } else {
        set options(os) "mac"
        set options(emailapp) "mail"
    }

    #populate options array -> option vars
    #myputs "populate option vars based on options array"
    foreach opt [array name options] {
        set $opt $options($opt)
        #myputs "set $opt $options($opt)"
    }

    #once set, CLI provided host will be ignored
    #set session alecto

    #default action when timeout
    set user_patterns(timeout)          [list "timeout" EXIT expect_only]
}

set global_data {    ;#{{{2}}}
    #this code var does 2 jobs:
    #
    #1.global :
    #   options , 
    #   data arrays, 
    #   some internal params
    #
    #2. assign option vars to vars, and also global them
    #

    #options: {{{3}}}
    global options options_cli options_cfg options_inline

    #data arrays {{{3}}}
    global pre_cmds1 pre_cmds_cli post_cmds1 post_cmds_cli
    global cmds1 cmds2 cmds3 collect test
    global cmds_cli collect_cli test_cli cmds_exp
    global cmd_output_array_pre_cmds1 cmd_output_array_post_cmds1
    global cmd_output_array_cmds1 cmd_output_array_cmds1_prev
    global login_info login_info_cli 
    global eventscript scheduled_event
    global cmd_file
    global user_patterns action_handler

    #code {{{3}}}
    global code_return_expect_user_interupt
    global code_return_expect_sendfirst
    global code_return_reconnect
    global code_return_retry
    global code_return_ctrlc
    global code_return_exit
    global code_return_close
    global code_return_continue

    #internal params {{{3}}}
    global session2host host2session 
    global config_default config_file hostmap
    global user_spawn_id expect_out debug spawn_id
    global env tcl_platform host help_file 
    global regex_info issue_info
    global regex_info_exp issue_info_exp
    global regex_info_resolve issue_info_resolve
    global myinteract_depth hostlist_full

    global log_filename_new log_filename_cur
    global log_dir_new log_dir_cur
    global log_fullname_new log_fullname_cur

    global during_login during_cmd

    #global login_index

    #all options => global var {{{3}}}
    #myputs "global all vars in options array" 0
    #parray options
    #puts "login_index looks $login_index!!!!!!!!!!!!!!"
    foreach opt [array name options] {
        global $opt
        set $opt $options($opt)
        #myputs "global $opt"
    }

    #test:all user_pattern => global var {{{3}}}
    myputs "global all vars in user_pattern array" 2
    foreach opt [array name user_pattern] {
        global $opt
        set $opt $user_pattern($opt)
        #myputs "global $opt"
    }

    #testN {{{3}}}
    for {set i 1} {$i<10} {incr i 1} {
        global test$i
    }

    #cmdsN {{{3}}}
    for {set i 1} {$i<=200} {incr i 1} {
        global cmds$i pre_cmds$i pre_cmds${i}_cli post_cmds$i post_cmds${i}_cli
        global cmd_output_array_pre_cmds${i} output_array_post_cmds${i}
        global cmd_output_array_cmds${i}_prev cmd_output_array_cmds${i}

        #for REPEAT
        global cmds${i}_exp
        #for auto_resolve
        global cmds${i}_resolve
    }
}

#code {{{1}}}
#
#

#code: template {{{2}}}
set code_init_template { ;#{{{3}}}
#common code-------------------------------------------------start
#these are the common codes that should be included in every handler
#it provides some default data structures that can be used for analysis

    global cmd_output_array_cmds1_prev cmd_output_array_cmds1
    global debug 

    #set rate_gap_ratio_threshold 0.3

    puts ""
    if $debug {myputs "--------parsing cmd output with defined parser--------"}
    myputs "$router:\[$cmd\]"

    if $debug {
        set procname [lindex [info level 0] 0]
        send_log "$procname:cmd_output_array_cmds1_prev looks \
            [array get cmd_output_array_cmds1_prev]\n"
        send_log "$procname:cmd_output_array looks [array get cmd_output_array_cmds1]\n"
    }

    #parse previous data array
    #set cmd_output_prev [get_output cmd_output_array_cmds1_prev $router $cmd]
    set cmd_output_prev [get_output cmd_output_array_cmds1_prev $router $cmd_id]
    #set time_prev [lindex [get_index cmd_output_array_cmds1_prev $router $cmd] 1]
    set time_prev [lindex [get_index cmd_output_array_cmds1_prev $router $cmd_id] 1]
    set cout_list_prev [split $cmd_output_prev "\n"]

    #parse current data array
    #set cmd_output [get_output cmd_output_array_cmds1 $router $cmd]
    set cmd_output [get_output cmd_output_array_cmds1 $router $cmd_id]
    #set time_now [lindex [get_index cmd_output_array_cmds1 $router $cmd] 1]
    set time_now [lindex [get_index cmd_output_array_cmds1 $router $cmd_id] 1]
    set cout_list [split $cmd_output "\n"]

    set cout_llen [llength $cout_list]

    send_log "proc1:for router $router cmd --$cmd-- got curr:prev time as $time_now:$time_prev\n"

    #if {($time_prev==0) || ($time_now==0) || ($time_prev==$time_now)} {}
    #
    #it seems, after stablized for a while, the last condition:
    #  time_prev==$time_now, can be loosed, to support the "no baseline"
    #  enhancement.
    #  currently a trick is added, to just copy cmd_output_array_${cmds}_prev
    #  from cmd_output_array_${cmds}. because of the "no baseline" improvement.
    #  without this, there won't be a "_prev" value in the first iteration,
    #  making the does_match1 always fail
    #TODO: maybe change dependency on both does_match1 and does_match2?
    #
    if {($time_prev==0) || ($time_now==0) } {
        myputs "time extraction error, exit!"
        if $debug {
            send_log "time extraction error, exit!\n"
            send_log "proc1:router -$router- cmd -$cmd- cmd_output_prev looks -$cmd_output_prev-\n"
            send_log "proc1:router -$router- cmd -$cmd- cmd_output looks -$cmd_output-\n"
            send_log "proc1:convert cmd_output_prev to list as --$cout_list_prev--\n"
            send_log "proc1:convert cmd_output to list as --$cout_list--\n"
        }
        exit
    } else {
        if $debug {
            send_log "time extraction correct, continue\n"
        }
    }
    for {set i 0} {$i<$cout_llen} {incr i 1} {          ;#for each line from cmd output
        set cout_line [lindex $cout_list $i]            ;#take a line from the output list
        set cout_aline($i) $cout_line
        set cout_line_prev [lindex $cout_list_prev $i]  ;#take same line,from the prev capture
        set cout_aline_prev($i) $cout_line_prev
    }

    if $debug {
        puts "cmd_output array cout_aline_prev and cout_aline looks:"
        parray cout_aline_prev
        parray cout_aline
    }

    #availble vars now:
    #cmd_output, cout_list cout_llen cout_line count_aline(n)
    #cmd_output_prev, cout_list_prev cout_llen_prev cout_line count_prev_aline_prev(n)

#common code-------------------------------------------------end
}

set code_template {       ;#{{{3}}}

    #assign issue {{{4}}}
    set issue4onecmd $issue4onecmd_holder

    #parse regex {{{4}}}
    set regex_vars_list [split $regex4onecmd "@"]
    myputs "split -$regex4onecmd- into list: -$regex_vars_list-"
    set cmd_num [lindex $regex_vars_list 0]
    set line_num [lindex $regex_vars_list 1]
    if {$line_num!=""} {
        myputs "get line_num as : -$line_num-"
        if {$line_num > $cout_llen} {
            myputs2 "line number($line_num) exceeded the max($cout_llen)!"
            myputs2 "check your -R regex"
            exit 11
        }
    } else {
        myputs "no line_num"
    }
    set regex [lindex $regex_vars_list 2]
    myputs "get regex : -$regex-"

    #announce all vars/prev vars {{{4}}}
    set vars [lrange $regex_vars_list 3 end]
    myputs "get vars list: -$vars-"
    foreach avar $vars {global $avar}   ;#to use in other places
    myputs "get vars as a list: -$vars-"

    #generate the "prev" var names to save captured values
    set vars_prev {}
    foreach avar $vars { append vars_prev "${avar}_prev " }
    set vars_prev [string trim $vars_prev]
    myputs "get vars_prev as a list: -$vars_prev-"

    #calc matches for both current/prev output {{{4}}}
    #TODO: when baseline not taken, the _prev data will be empty, any match2
    #won't be 1

    #scan cmd_output and escape braces
    myputs "will scan for braces and regsub to add backslash to escape them..."
    #http://stackoverflow.com/questions/5302120/general-string-quoting-for-tcl
    #http://wiki.tcl.tk/987
    #regsub -- {([^\.]*)\.c} file.c {cc -c & -o \1.o} ccCmd
    if {[regsub -all {([{}])} $cmd_output {\\\1} cmd_output] > 0} {
        myputs "substituted cmd_output now looks $cmd_output" 3
    }
    if {[regsub -all {([{}])} $cmd_output_prev {\\\1} cmd_output_prev] > 0} {
        myputs "substituted cmd_output now looks $cmd_output_prev" 3
    }

    if {$line_num==""} {
        myputs "empty line_num"
        myputs "looking for a match to regex:\n$regex"
        myputs "from following output:\n$cmd_output"
        myputs "and the previous version:\n$cmd_output_prev"
        puts "to be evaled:\n[subst {regexp {$regex} {$cmd_output} -> $vars}]"
        set does_match1 [eval \
            [subst {regexp {$regex} {$cmd_output} -> $vars}]]
        set does_match2 [eval \
            [subst {regexp {$regex} {$cmd_output_prev} -> $vars_prev}]]
    } else {
        set does_match1 [eval [subst {\
            regexp {$regex} {$cout_aline($line_num)} -> $vars}]]
        set does_match2 [eval [subst {\
            regexp {$regex} {$cout_aline_prev($line_num)} -> $vars_prev}]]
        myputs "from following output:\n$cout_aline($line_num)"
        myputs "and the previous version:\n$cout_aline_prev($line_num)"
        myputs "to find a match to regex:\n$regex"
    }

    #if matches {{{4}}}
    if {($does_match1==1) && ($does_match2==1)} {
        #myputs "vars captured and saved in var list:-$vars-,
        #packets:-$packets- pps:-$pps-"
        myputs "wanted value captured and saved in user defined vars:"
        #this caused errors (2015-12-04) 
        #myputs " |$vars_prev|: |[set $vars_prev]| "
        #myputs " |$vars|     : |[set $vars]|"
        #myputs "vars captured and saved in vars: $vars_prev\[[set
        #$vars_prev]\]and $vars\[[set $vars]\]"
        #
        #why send_user here?
        #send_user "|    got match to regex |$regex4onecmd|,"
        myputs2 "<<<CRTC:got match to regex |$regex4onecmd|,"

        if { [info exists issue4onecmd] && \
            ![string equal $issue4onecmd ""]} {

            #issue defined {{{5}}}
            myputs "criteria defined to detect the issue: -$issue4onecmd-,"
            #if {[expr {[subst $issue]}]}
            if ![regexp {\d+@(.*)} $issue4onecmd -> issue] {
                puts "wrong format in -I!";interpreter
            }

            #return 1 if issue seen {{{6}}}
            if {[expr $issue]} {
            #if ![string equal $issue ""] {}
                #for some reason, puts won't work in eval
                if {$::hideinfo<3} {
                    myputs2 "\ncriteria \"$issue\" was met -> \"[subst $issue]\""
                }

                #send captured value if -V was given
                if {$::print_matched_value==1} {
                    myputs "print all matched value"
                    foreach avar [subst $vars] {send_user "[set $avar] "}
                } elseif {$::print_matched_value==0} {
                } else {
                    send_user "[subst $::print_matched_value]"
                }

                return 1
            } else {
                #issue not seen {{{6}}}
                myputs2 "\ncriteria \"$issue\" was not met -> \"[subst $issue]\""

                #send captured value if -V was given
                if {$::print_matched_value==1} {
                    myputs "print all matched value"
                    foreach avar [subst $vars] {send_user "[set $avar] "}
                } elseif {$::print_matched_value==0} {
                } else {
                    send_user "[subst $::print_matched_value]"
                }

            }

        } else {
            #issue not defined {{{5}}}

            #send captured value if -V was given
            if {$::print_matched_value==1} {
                myputs "print all matched value"
                foreach avar [subst $vars] {send_user "[set $avar] "}
            } elseif {$::print_matched_value==0} {
            } else {
                send_user "[subst $::print_matched_value]"
            }

            myputs2 "issue not defined,"

            if $::match_means_issue {
                myputs2 "but match_means_issue set to $::match_means_issue, \
                    indicating issue appearing!"
                return 1
            } else {
                myputs2 "and match_means_issue not set , \
                    indicating issue NOT appearing!\n"
                return 0
            }

        }
    } else {
        #else if no match {{{4}}}
        #myputs "no match, defined vars:\n[set $vars]\nwas not captured"
        myputs "no match, defined vars:\n[set vars]\nwas not captured"
        myputs "consider to:"
        myputs "   double check your regex, make sure it's what you wanted"
        myputs "   or maybe issue does not appear yet"

        #send_user "|    got no match to regex |$regex4onecmd|,"
        myputs "<<<CRTC:|    got no match to regex |$regex4onecmd|,"
        if $auto_resolve {
            puts "some variable won't be resolved due to no match in regex_info
                provided, check the CLI output and regex!"
            #puts "exit for now.."
            #exit [CONST EXIT_ON_NO_RESOLVE]
            myinteract $login_index
        }

        if $::nomatch_means_issue {
            myputs "issue not provided, no match simply means found issue"
            myputs2 "but nomatch_means_issue set $::nomatch_means_issue,\
                indicating issue appearing!"
            return 1
        } else {
            myputs2 "and nomatch_means_issue not set, \
                indicating issue NOT appearing!"
        }

    }
}

set code_update_template {    ;#{{{3}}}
    myputs "\n"
    myputs "==>enter code_update_template now"
    if {[info exists regex_info($login_index)] && \
        ![string equal $regex_info($login_index) ""]} {
        #regex_info defined {{{4}}}

        #availble vars now:
        #cmd_output, cout_list cout_llen cout_line count_aline(n)
        #cmd_output_prev, cout_list_prev cout_llen_prev cout_line count_prev_aline_prev(n)

        #if $debug {puts "regex_info looks:";parray regex_info}
        myputs "regex_info looks $regex_info($login_index)"
        if $debug {
            if {[info exists issue_info($login_index)] && \
               ![string equal $issue_info($login_index) ""]} {
                puts "issue_info looks: -$issue_info($login_index)-";
            } else {
                puts "issue_info not configured for $login_index"
            }
        }

        #iterate regex_info {{{4}}}
        myputs "regex_info looks $regex_info($login_index)"
        foreach regex4onecmd $regex_info($login_index) {
            #regex_info(r1) "1@@Input  packets:\s+(\d+)\s+(\d+) pps@packets@pps"
            #issue_info(r1) "1@pps==0"

            #parse regex data : {{{5}}}
            #regex_vars_list: 1   "Input  packets:\s+(\d+)\s+(\d+) pps"  packets  pps
            #set regex_vars_list [split $regex_info($cmd_num) "@"]
            myputs "get a regex $regex4onecmd" 1
            set regex_vars_list [split $regex4onecmd "@"]
            #myputs "get list |$regex_vars_list| from string |$regex_info($cmd_num)|"
            myputs "get list:|$regex_vars_list| from string |$regex4onecmd|"
            set cmd_num [lindex $regex_vars_list 0]
            set line_num [lindex $regex_vars_list 1]
            set regex [lindex $regex_vars_list 2]
            myputs "get regex as a string: |$regex|"
            set vars [lrange $regex_vars_list 3 end]
            myputs "get vars as a list: |$vars|"

            #special handling for -I (issue) data
                
            #this looks no need. coz when substitue (either by string map or
            # regsub, both abc and abc_prev with be replaced as $abc and
            # $abc_prev. adding below code will make:
            # "pps!=pps_prev" be changed to "$pps!=$$pps_prev"
            #
            ##generate the "prev" version of the var names to save captured values
            #foreach avar $vars { append vars_prev "${avar}_prev " }
            #myputs "get vars_prev as a list: -$vars_prev-"


            #regex all "words", if belong to vars_list, then replace, otherwise
            #don't replace
            #   {pps 0}                                  "pps==0"
            #if [info exists issue_info($cmd_num)] {}
            #debug 1
            
            #substitute regex4onecmd in code template {{{5}}}
            regsub -all \
                {\$regex4onecmd} $code_template \
                "\{$regex4onecmd\}" temp


            #check if mapping issue defined {{{5}}}
            myputs "looking for issue for the regex with the same cmd"
            set isthere_issue4regex 0
            set issue4onecmd ""
            if { [info exists issue_info($login_index)] && \
                ![string equal $issue_info($login_index) ""]} {

                foreach aaa $issue_info($login_index) {
                    myputs "get an issue definition:$aaa" 3
                    set issue_as_list [split $aaa "@"]
                    myputs "split to list: -$issue_as_list-" 3
                    set cmd_num_issue [lindex $issue_as_list 0]
                    if [string equal $cmd_num_issue $cmd_num] {
                        myputs "got same cmd number $cmd_num_issue" 3
                        set isthere_issue4regex 1
                        set issue4onecmd $aaa
                        break
                    }
                }
            }

            #mapping issue not defined {{{5}}}
            if !$isthere_issue4regex {
                myputs "can't find an issue for regex4onecmd:$regex4onecmd"
            } else {
                #mapping issue defined {{{5}}}

                if $easyvar {
                    #easyvar {{{6}}}
                    myputs "easyvar set, will check issue expression (-I or\
                        issue_info) and compose vars from bare-words"

                    myputs "will do vars substitutions now.."
                    if [string equal $cmd_num_issue $cmd_num] {
                        myputs "issue defined for {$regex4onecmd} ==> {$issue4onecmd}"
                        #set issue_words [regexp -all -inline {(\w+)} $issue_info($cmd_num)]
                        set issue_words [regexp -all -inline {(\w+)} $issue4onecmd]

                        myputs "extracted words from |$issue4onecmd| are |$issue_words|"
                        foreach {word word_rep} $issue_words {
                            if {[lsearch -exact $vars $word]!=-1} {
                                myputs "get a word $word, looks in vars $vars, \
                                    will prefix a \"\$\"" 3
                                regsub -all $word $issue4onecmd "\$$word" issue4onecmd
                                #set issue4onecmd [string map "$word \$$word" $issue4onecmd]  
                            } else {
                                myputs "get a word $word, looks not a variable" 3
                            }
                        }
                        myputs "code_update_template:issue4onecmd now looks\
                            $issue4onecmd after substitutions"

                    } else {
                        myputs "no issue defined for regex:$regex4onecmd"
                        #unset issue4onecmd
                        set issue4onecmd ""
                    }

                } else {
                    #no easyvar {{{6}}}
                    myputs "easy var not set, won't do any varible substitutions for -I"
                }
            }

            #substitude issue4onecmd in code template {{{5}}}
            regsub -all {\$issue4onecmd_holder} $temp "\{$issue4onecmd\}" temp

            #generate "code var": {{{4}}}
            #  will be used to compose the real proc from within check_flag
            #variables in the code will NOT be substituded
            myputs "defining code |code_${login_index}_$cmd_num| now"

            set code_${login_index}_$cmd_num $temp

            myputs "generated code for code_${login_index}_$cmd_num looks" 4
            myputs "[set [subst {code_${login_index}_$cmd_num}]]" 4
        }
    } else {
        #regex_info not defined {{{4}}}
        myputs "regex_info not provided"
    }
    myputs "<==leaving code_update_template now"
    myputs "\n"
}

#code: action handler {{{2}}}
set code_return_expect_user_interupt {  ;#{{{3}}}
    #whenever got user intput (to get control)
    #detected need to go interact, and repeat the cmd after
    #user #exit interact and return control
    
    while {$myexpect_return=="RETURN_EXPECT_USER_INTERUPT"} {

        set automation_non_complete_msg "<<<<\
            \[session $router\]:you have unfinished \
            automations (stack $myinteract_depth)!\n\ 
            press !R to  continue, ^\\ or !s to stop, \
            !Q to quit script"
            set options(automation_non_complete_msg) \
                $automation_non_complete_msg
            set options_inline(automation_non_complete_msg) \
                $automation_non_complete_msg

        incr myinteract_depth
        myputs "increase myinteract_depth to $myinteract_depth"

        myinteract $router
        #interpreter
        #stty -raw

        set automation_non_complete_msg ""
            set options(automation_non_complete_msg) \
                $automation_non_complete_msg
            set options_inline(automation_non_complete_msg) \
                $automation_non_complete_msg

        set myexpect_return [myexpect $router $pattern     \
            $datasent $pattern_timeout [expr !$pa_pair] 0   \
        ]

        if {$hideinfo==2} {
            myputs2 "$cmd "
            if {$myexpect_return!=0} {
                myputs2 "!"
            } else {
                myputs2 "."
            }
            myputs2 "\n"
        }
    } 

    #this is IMPORTANT in current implementation - myexpect while loop in
    #do_pag, to break out of the loop and proceed
    break
}

set code_return_expect_sendfirst {      ;#{{{3}}}
    #continue with next data-pattern in for loop
    set do_pag_return "RETURN_DO_PA5_NORMAL"
    break
}

set code_return_reconnect {     ;#{{{3}}}

    global session

    #if $persistent {
    #    #if not set persistent, ignore "RECONNECT" action from
    #    #user_patterns (by not to return, meaning to continue
    #    #next iteration)

    #    myputs "persistent set, will return $myexpect_return"
    #    return $myexpect_return

    #    #this doesn't work well, kind of tricky...
    #    #from proc myreturn:
    #    # uplevel [list return [lindex $args 0]]
    #    #issue is: after uplevel executed return from
    #    #"uplevel"(that is inside do_pag?), flow still continue
    #    #in do_pag instead of stop. this ends up to generate
    #    #another return (RETURN_DO_PA5_NORMAL) in this case.
    #    #
    #    #myreturn $myexpect_return "do_pag"
    #}
    
    if {$persistent==1 || $persistent==3} {

        if !$reconnect_interval {
        } else {
            puts "persistent $persistent, will reconnect after\
                ${reconnect_interval}s!"
            mysleep $reconnect_interval
        }

        #$session is a must, other wise have issues
        #
        #but this now report an error:
        # can not find channel named "exp5"
        #close $process;wait $process
        #
        #per man expect, this should be:
        #close -i $process;wait -i $process

        close ;wait 

        myputs "==> calling recursive spawn_login"
        spawn_login $router
        myputs "<== leaving recursive spawn_login"

        #should break out of while loop in do_pag?
        #why not? (2016-11-21) 
        #this will break only expect loop in do_pag, not cmd loops
        break

    } else {
        puts "persistent set $persistent, not to reconnect !"
    }
}

set code_return_retry {       ;#{{{3}}}
    set do_pag_return $myexpect_return
    global timeout
    myputs "timeout from eval code looks $timeout seconds!"

    #check during_login and during_cmd to figure out where
    #we are, and for spawn_login and exec_cmds, process
    #differently - this method seems to be better than doing
    #same processing in caller (spawn_login and exec_cmd),
    #by looking at the return values

    #if the previous pattern looks like "sword", "ogin", etc, don't
    #repeat the p-a - you won't get another "sword" prompt until the
    #even earlier login cmd is resent...
    #otherwise, if pattern looks just a normal prompt, then it makes
    #sense to wait for it again and resent the previous cmd...
    if ![regexp "$pattern_common_prompt" "$pattern_prev"] {
        set pattern_prev $pattern
        set datasent_prev $datasent
    }

    if $during_login {      ;#{{{4}}}

        #this should have been covered in spawn_login
        #if reconnect_on_event==RETURN_EXPECT_TIMEOUT
        #then recursive spawn_login
        #break


        #IMPORTANT: absorbing any possible extra prompts or whatever
        #(2016-05-31) but why?
        set timeout_old $timeout
        set timeout 1
        expect -i $process -re ".+" {exp_continue -continue_timer}
        set timeout $timeout_old

        #after the absorbing, 
        #* then under pa_pair, a ctrl-c need to be sent, to trigger the next
        #  pattern
        #* under non pa_pair, just send command, so no need to send ctrl-c

        #press a double "ctrl-c" to interupt
        #exp_send -i $process "[CONST CTRL_C]\r"
        #puts "pressed a ctrl-c to escape just in case..."

        #if not under pa pair mode (just send cmds)
        #wait for the prompt to appear before proceeding - this is to confirm
        #we do get out of the pending status before proceeding
        #if get timeout again, then send ctrl-c again,
        #and repeat this until we get a prompt, before going next (that is to
        #call same myexpct again since we are in a while loop!)
        #puts "then expecting a prompt -$pattern-"
        
        myputs "pa_pair set to $pa_pair"
        if !$pa_pair {          ;#{{{5}}}
            #
            #this seems to be no use: during_login always set pa_pair?
            #
            #use an escape_count to limit the amount of ctrl-c sent to escape
            #from the timeout situation
            set escape_count 0
            expect {
                -i $process -re $pattern {
                    myputs "expected pattern -$pattern- matched!"
                    puts "will sleep for $reconnect_interval and retry"
                    mysleep $reconnect_interval
                    puts "retry current cmd -$datasent- now..."
                    continue
                }
                timeout {
                    if {$escape_count < 3} {
                        incr escape_count
                        puts "timeout (${timeout}s) without match to -$pattern-\
                            press ctrl-c again to escape ..."
                        #just repeat sending ctrlc if got timeout
                        exp_send -i $process "[CONST CTRL_C]\r"
                        exp_continue
                    } else {
                        puts "not able to escape(not seeing expected prompt\
                            -$pattern-, will exit"
                        exit
                    }
                }
            }
        } else {                ;#{{{5}}}
            #for pa_pair, better to resend the previous command, instead of
            #current one..:
            #
            #1. ssh abc ...
            #2. expect "sword" and send password
            #if timeout in 2, need to resend 1.
            #
            set retry_count 0

            #send an ctrl-c to invoke a new prompt
            puts "press ctrl-c to get the previous prompt -$pattern_prev-..."
            exp_send -i $process "[CONST CTRL_C]\r"

            puts "awaiting for a -$pattern_prev-..."
            expect {
                -i $process -re $pattern_prev {
                    myputs "expected pattern_prev -$pattern_prev- matched!"
                    mysleep $reconnect_interval
                    myputs "retry previous cmd -$datasent_prev- now..."
                    exp_send -i $process "$datasent_prev\r"
                    continue
                }
                timeout {
                    if {$retry_count < $retry_max } {
                        incr retry_count
                        puts "timeout (${timeout}s) without match to\
                            -$pattern_prev- press ctrl-c again to escape ..."
                        #just repeat sending ctrlc if got timeout
                        exp_send -i $process "[CONST CTRL_C]\r"
                        exp_continue
                    } else {
                        puts "reach retry_max $retry_max without matching to\
                            -$pattern_prev-! will exit"
                        exit
                    }
                }
            }
        }

    } elseif $during_cmd {  ;#{{{4}}}

        #this is to provide a feature: when sending a command and get timed
        #out, press a ctrl-c and retry the same cmd. without this crtc may wait
        #for next pattern that may never occur due to the breaking of the whole
        #"event chain" caused by an previous timeout ... 
        #
        #this may not be often useful, but may be in some corner cases
        #
        #this is duplicated with myexpect retry code
        #for now put it here for easy maintain
        #
            
        #IMPORTANT: absorbing any possible extra prompts or whatever
        set timeout_old $timeout
        set timeout 1
        expect -i $process -re ".+" {exp_continue -continue_timer}
        set timeout $timeout_old

        #press a double "ctrl-c" to interupt
        exp_send -i $process "[CONST CTRL_C]\r"
        puts "pressed a ctrl-c to escape just in case..."

        #if not under pa pair mode (just send cmds)
        #wait for the prompt to appear before proceeding - this is to confirm
        #we do get out of the pending status before proceeding
        #if get timeout again, then send ctrl-c again,
        #and repeat this until we get a prompt, before going next (that is to
        #call same myexpct again since we are in a while loop!)
        puts "then expecting a prompt -$pattern-"
        
        myputs "pa_pair set to $pa_pair"
        if !$pa_pair {          ;#{{{5}}}
            #use an escape_count to limit the amount of ctrl-c sent to escape
            #from the timeout situation
            set escape_count 0
            expect {
                -i $process -re $pattern {
                    myputs "expected pattern -$pattern- matched!"
                    puts "will sleep for $reconnect_interval and retry"
                    mysleep $reconnect_interval
                    puts "retry current cmd -$datasent- now..."
                    continue
                }
                timeout {
                    if {$escape_count < 3} {
                        incr escape_count
                        puts "timeout (${timeout}s) without match to\
                            -$pattern-, press ctrl-c again to escape ..."
                        #just repeat sending ctrlc if got timeout
                        exp_send -i $process "[CONST CTRL_C]\r"
                        exp_continue
                    } else {
                        puts "not able to escape(not seeing expected prompt\
                            -$pattern-, will exit"
                        exit
                    }
                }
            }
        } else {                ;#{{{5}}}
            #puts "exit!"
            #exit
            #for pa_pair, better to resend the previous command, instead of
            #curent one..:
            #
            #1. ssh abc ...
            #2. expect "sword" and send password
            #if timeout in 2, need to resend 1.
            #
            set retry_count 0
            expect {
                -i $process -re $pattern_prev {
                    myputs "expected pattern_prev -$pattern_prev- matched!"
                    mysleep $reconnect_interval
                    puts "retry previous cmd $datasent_prev- now..."
                    exp_send -i $process "$datasent_prev\r"
                    continue
                }
                timeout {
                    if {$retry_count < $retry_max } {
                        incr retry_count
                        puts "timeout (${timeout}s) without match to\
                            -$pattern_prev-, press ctrl-c again to escape ..."
                        #just repeat sending ctrlc if got timeout
                        exp_send -i $process "[CONST CTRL_C]\r"
                        exp_continue
                    } else {
                        puts "reach retry_max $retry_max! will exit"
                        exit
                    }
                }
            }
        }
    }
}


set code_return_ctrlc {       ;#{{{3}}}
    #TODO: to be merged with normal command, no need as a special handler
    #
    set do_pag_return $myexpect_return

    #check during_login and during_cmd to figure out where
    #we are, and for spawn_login and exec_cmds, process
    #differently - this method seems to be better than doing
    #same processing in caller (spawn_login and exec_cmd),
    #by looking at the return values

    if $during_login {      ;#{{{4}}}

        #this should have been covered in spawn_login
        #if reconnect_on_event==RETURN_EXPECT_TIMEOUT
        #then recursive spawn_login
        break

    } elseif $during_cmd {  ;#{{{4}}}

        #press ctrl-c and continue

        exp_send -i $process "[CONST CTRL_C]"
        break

        #uplevel 1 {exp_send -i $session1 "[CONST CTRL_C]"}

        #extra return to generate a new prompt more
        #robust, but not reliable in some cases
        #(upgrade,yes/no,etc)
        #exp_send -i $process "\r"  
    }
}

set code_return_exit {       ;#{{{3}}}
    #TODO: "exit" processed in dynamic myexpect, seems no use here
    set do_pag_return $myexpect_return

    #check during_login and during_cmd to figure out where
    #we are, and for spawn_login and exec_cmds, process
    #differently - this method seems to be better than doing
    #same processing in caller (spawn_login and exec_cmd),
    #by looking at the return values

    if $during_login {      ;#{{{4}}}

        #this should have been covered in spawn_login
        #if reconnect_on_event==RETURN_EXPECT_TIMEOUT
        #then recursive spawn_login
        break

    } elseif $during_cmd {  ;#{{{4}}}

        exit
    }
}

set code_return_close {       ;#{{{3}}}
    #TODO: seems no use

    set do_pag_return $myexpect_return

    #check during_login and during_cmd to figure out where
    #we are, and for spawn_login and exec_cmds, process
    #differently - this method seems to be better than doing
    #same processing in caller (spawn_login and exec_cmd),
    #by looking at the return values

    if $during_login {      ;#{{{4}}}

        #this should have been covered in spawn_login
        #if reconnect_on_event==RETURN_EXPECT_TIMEOUT
        #then recursive spawn_login
        break

    } elseif $during_cmd {  ;#{{{4}}}

        myputs "will close this session"
        close $process;wait $process;
        #return value here seems no use
        return "CLOSE"
    }
}

set code_return_continue {       ;#{{{3}}}
    #TODO: seems no use
    #
    set do_pag_return $myexpect_return

    #check during_login and during_cmd to figure out where
    #we are, and for spawn_login and exec_cmds, process
    #differently - this method seems to be better than doing
    #same processing in caller (spawn_login and exec_cmd),
    #by looking at the return values

    if $during_login {      ;#{{{4}}}

        #this should have been covered in spawn_login
        #if reconnect_on_event==RETURN_EXPECT_TIMEOUT
        #then recursive spawn_login
        break

    } elseif $during_cmd {  ;#{{{4}}}

        #don't do anything special, just continue as if
        #all good done processing this condition

        break
    }
}


#set action_handler {{{3}}}

set action_handler(RETURN_EXPECT_USER_INTERUPT) \
    "code_return_expect_user_interupt"
set action_handler(RETURN_EXPECT_SENDFIRST0_NORMAL) \
    "code_return_expect_sendfirst"
set action_handler(RETURN_EXPECT_SENDFIRST1_NORMAL) \
    "code_return_expect_sendfirst"
set action_handler(RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN) \
    "code_return_expect_sendfirst"
set action_handler(RECONNECT) "code_return_reconnect"
set action_handler(RETRY) "code_return_retry" 
#set action_handler(RETURN_EXPECT_TIMEOUT) "code_return_timeout"

#code: myexpect {{{2}}}
#send_user_expect_out {{{3}}}
set send_user_expect_out {
    #these code do some "polish" work on cmd output and send to user by
    #`send_user`
    #
    #cmd output can be:
    #1. by default `expect_out(buffer)`
    #2. can also be the var `buf`, which is the accumulated chars collected
    #from `.+` match
    #
    #currently "polish" work is to:
    #
    #. add a configurable prefix_mark, e.g. prefix a hostname in each line
    #. TODO: a timestamp can also be added, if needed. later.

    if {$prefix_mark != 0} {
        #this "buf", was set previously within myexpectcmd->expect when eval.ed
        myputs "original buf looks \n$buf"
        if {$prefix_mark=="HOST"} {set prefix_mark $host}

        #split output into list of each line
        set output_list [split $buf "\n"]
        set output_new ""
        
        #for each line, insert prefix_mark into the head
        #then compose lists back to a new output
        foreach line $output_list {
            set line_new [sinsert $line 0 "$prefix_mark:"]
            set line_new [append line_new "\n"]
            append output_new $line_new
        }
        myputs "with prefix_mark set the output_new looks \n$output_new"
    } else {
        #if prefix_mark not set, just send original content of var buf
        set output_new $buf
    }
    
    catch {
        #send_user "$expect_out(buffer)\n"
        #myputs "output looks -$expect_out(buffer)-"
        send_user "$output_new\n"
    }
}

#write_cmd_output {{{3}}}
set write_cmd_output {
    #write cmd output to seperate file, with filename can be configured by user

    if {$prefix_mark !=0} {
        #this "buf", was set previously within myexpectcmd->expect when eval.ed
        myputs "original buf looks \n$buf"
        if {$prefix_mark=="HOST"} {set prefix_mark $host}
        set output_list [split $buf "\n"]
        set output_new ""
        foreach line $output_list {
            set line_new [sinsert $line 0 "$prefix_mark: "]
            set line_new [append line_new "\n"]
            append output_new $line_new
        }
        myputs "with prefix_mark set the output_new looks \n$output_new"
    } else {
        set output_new $buf
    }

    if [info exists cmd_file($cmd)] {
        set file_ori $cmd_file($cmd)

        #set h_cmd_file [open $file_new a]

        set h_cmd_file [open [info_subs2 $file_ori] a]
        catch {
            #puts -nonewline $h_cmd_file $expect_out(buffer)
            puts -nonewline $h_cmd_file $output_new
        }
        close $h_cmd_file
    }
}

#code_expect_user_patterns {{{3}}}
set code_expect_user_patterns {

    #according to "user_pattern" array configured in the config file
    #build 2 expect clauses, for later usage:
    #1. user patterns and actions:      expect_user_patterns
    #2. timeout process:                timeout_clause

    if [expr {$enable_user_patterns && [array exists user_patterns]}] {

        #set user_patterns(nsr_not_active)
        #  [list "warning: GRES not configured" cmds3 eventscript]
        set expect_user_patterns ""

        myputs "enable_user_patterns set and user_patterns array is not empty!"
        if {$debug==3} {
            puts "user_patterns looks:"
            parray user_patterns
        }

        #iterating user_patterns {{{4}}}
        foreach user_pname [array name user_patterns] {

            #first var in list is user_pattern
            set user_pattern [lindex $user_patterns($user_pname) 0]

            #skip if entry is empty {{{5}}}
            if [string equal $user_pattern ""] {
                myputs "user_patterns($user_pname) looks empty!"
                continue
            }

            #skip if entry is interact_only {{{5}}}
            if [in "interact_only" $user_patterns($user_pname)] {
                myputs "user_patterns($user_pname) looks empty!"
                continue
            }

            #expect flags {{{5}}}
            #for pattern "timeout" - removing expect flags
            #for expect_matchany, do the same to fit in "switch"
            if {($user_pattern=="timeout") || $expect_matchany} {
                set pat_flag ""
            } else {
                set pat_flag "-nocase -re"
            }

            if {[llength $user_patterns($user_pname)] == 1} {
                #pattern without action {{{5}}}
                #return pattern name

                #if only pattern exists, just return pattern name, so
                #caller may add handlers for these names (?)
                myputs "user_pattern $user_pname contains no cmd" 3
                myputs "will return pattern name $user_pname"

                append expect_user_patterns [subst -nocommands {
                    $pat_flag {$user_pattern} {
                        myputs "detected -$user_pattern-"
                        myputs "will return pattern name"

                        set buf_match_loc [string first [lindex [set match] 0] [set buf]]
                        set buf_rm_bef_matched [string replace [set buf] 0 [set buf_match_loc]-1 ]
                        set buf [string trimleft [set buf_rm_bef_matched] [set match]]

                        return $user_pname
                    }
                }]

                #when not configured, the default action is to "continue"
                set action_handler($user_pname) "code_return_continue" 


            } else {

                #pattern with actions {{{5}}}
                #
                #                         user_pname 
                #                           ^
                #                           |
                #set user_patterns(login_retry_diff_account) 
                #   [list "ogin: $" "RECONNECT $reconnect_eval" interact]
                #            ^              ^       ^
                #            |              |       |
                #      user_pattern user_action  user_action_eval
                #                   -----------------------------
                #                   goes into user_action_list
                #
                set user_action_list [lindex $user_patterns($user_pname) 1]
                set user_action [lindex $user_action_list 0]
                set user_action_eval [string trimleft $user_action_list $user_action]

                #switch looks much neat than if else
                #if [ni $user_action "RECONNECT"] {}
                
                #by default is to send cmd and do exp_continue
                #but (only) for some reserved cmds, process differently

                myputs "user_patterns $user_pname contains an action $user_action" 3
                if {$user_action_eval != ""} {
                    myputs "and a user_action_eval\n-$user_action_eval-" 3
                }

                set timeout_old $timeout

                #set a default timeout clause
                set timeout_clause {
                    timeout {
                        myputs "timeout in ${timeout}s without any data!"
                        return "RETURN_EXPECT_TIMEOUT"
                    }
                }

                #build timeout_clause under expect_matchany {{{6}}}
                if {$expect_matchany && $user_pattern=="timeout"} {
                    myputs "expect_matchany set $expect_matchany" 3
                    myputs "user_pattern looks $user_pattern" 3
                    myputs "will need to build a timeout clause ..." 3

                    #expect_matchany will collect cmd output and do matches (in
                    #switch) in realtime. it will match "timeout" literally
                    #without special treatment as what native "expect" will
                    #do. 
                    #workaround here is don't generate expect pattern for
                    #"timeout" under expect_matchany
                    #
                    #TODO: then expect_matchany won't support actions for timeout
                    #event, since pattern "timeout" will be missed!

                    switch -regexp -- $user_action {

                        "RETRY" -
                        "RECONNECT" {   ;#{{{7}}}

                            #return "RECONNECT" or "RETRY" literally, and the
                            #reconnection action will be processed by upper
                            #caller based on that value
                            myputs "will compose timeout clause to return\
                                user_action $user_action"
                            set timeout_clause [subst {
                                $pat_flag {timeout} {
                                    puts "detected timeout after $timeout"
                                    puts "user_action configured as $user_action"
                                    myputs "will return this user_action"
                                    return $user_action
                                }
                            }]
                        }

                        "EXIT" {        ;#{{{7}}}
                            myputs "will compose timeout clause to exit on timeout"
                            set timeout_clause [subst {
                                $pat_flag {$user_pattern} {
                                    puts "detected -$user_pattern-"
                                    puts "user_action configured as EXIT"
                                    puts "will just exit the script!"
                                    exit [CONST EXIT_ON_CONFIGURED_ACTION]
                                }
                            }]
                        }

                        default {       ;#{{{7}}}
                            myputs "this is not a \"special command\", will\
                                send it as a normal command"

                            set timeout_clause [subst \
                                -nobackslashes -nocommands {
                                $pat_flag {$user_pattern} {
                                    myputs "detected -$user_pattern-"
                                    myputs "will send cmd -$user_action_list-, and\
                                        continue expect"
                                    exp_send -i [set process] "[info_subs2 $user_action_list]\r"
                                    mysleep $retry_interval
                                    exp_continue
                                }
                            }]
                        }   ;#done default
                    }   ;#done switch

                } else {
                    #build expect_user_patterns {{{6}}}

                    myputs "expect_matchany set 0" 3
                    switch -exact -- $user_action {

                        "RECONNECT" {   ;#{{{7}}}

                            #return "RECONNECT" literally, and the reconnection
                            #action will be processed by upper caller
                            myputs "will compose expect clause to return\
                                user_action the value $user_action"

                            #set a flag, to determine whether to execute eval
                            #or not in user pattern claus built
                            if ![string equal "$user_action_eval" ""] {
                                set do_eval 1
                            } else {
                                set do_eval 0
                            }

                            append expect_user_patterns [subst -nocommands {
                                $pat_flag {$user_pattern} {
                                    puts "detected -$user_pattern-"
                                    if $do_eval {
                                        puts "now execute user_action_eval..."
                                        eval {$user_action_eval}
                                    }

                                    puts "user_action configured as $user_action"
                                    puts "will reconnect..."

                                    set buf_match_loc [string first \
                                        [lindex [set match] 0] [set buf]]
                                    set buf_rm_bef_matched [string replace \
                                        [set buf] 0 [set buf_match_loc]-1 ]
                                    set buf [string trimleft \
                                        [set buf_rm_bef_matched] [set match]]

                                    myputs "will return user_action $user_action"
                                    return $user_action
                                }
                            }]
                        }

                        "RETRY" {       ;#{{{7}}}

                            myputs "will compose expect clause to return\
                                user_action the value $user_action"
                            #repeat the previous cmd and exp_continue

                            append expect_user_patterns [subst -nocommands {
                                $pat_flag {$user_pattern} {
                                    myputs "timeout in $timeout"
                                    expect -i [set process] *
                                    myputs "expect_out(buffer) now looks\r
                                        -[set expect_out(buffer)]-"
                                    puts "detected -$user_pattern-"
                                    puts "user_action configured as RETRY"
                                    puts "will repeat same command and continue..."

                                    set buf_match_loc [string first \
                                        [lindex [set match] 0] [set buf]]
                                    set buf_rm_bef_matched [string replace \
                                        [set buf] 0 [set buf_match_loc]-1 ]
                                    set buf [string trimleft \
                                        [set buf_rm_bef_matched] [set match]]

                                    return $user_action

                                }
                            }]
                        }
                                    #moving out below code which are duplicated to
                                    #the same implementation in do_pag, for now do
                                    #it do_pag for easy maintain
                                    #
                                    #this is to "escape" the coming prompt
                                    #characters following the mapped user patterns,
                                    #see comments after this switch
                                    #
                                    #set timeout 2
                                    #expect -i $process -re ".+" exp_continue
                                    #set timeout $timeout_old;

                                    #exp_send -i $process "$cmd\r"
                                    #mysleep $retry_interval
                                    #exp_continue

                        "EXIT" {        ;#{{{7}}}
                            myputs "will compose expect clause to exit\
                                on match to the pattern"
                            append expect_user_patterns [subst {
                                $pat_flag {$user_pattern} {
                                    puts "detected -$user_pattern-"
                                    puts "user_action configured as EXIT"
                                    puts "will just exit script!"
                                    exit [CONST EXIT_ON_CONFIGURED_ACTION]
                                }
                            }]
                        }

                        default {       ;#{{{7}}}
                            myputs "this is not a \"special command\""

                            #for "normal cmd" just to send it and exp_continue
                            #tricky tips:
                            #1. use [set process] instead of $process + -nocommand
                            #2. use -nobackslashes + "user_action\r" instead of
                            #{user_action\r}
                            #
                            #
                            #reason: 
                            #1. $process needs some delay to be evaluated only after
                            #login process, not in here. so use -nocommand to skip
                            #evaluating commands, and use [set process] to make it
                            #not being evaluated at this time.
                            #
                            #2. use -nobackslashes, to skip the evaluation of \r,
                            #this is to make the whole command string looks better.
                            #otherwise the final command string may look messy:
                            #
                            #myputs "will send cmd -show system uptime-, "
                            #  send -i exp6 "show system uptime"
                            #mysleep 30
                            #
                            #-nobackslashes will skip evaluating \r, and the
                            #command will look better:
                            #    myputs "will send cmd -show system uptime-, "
                            #    send -i [set process] {show system uptime\r}
                            #    mysleep 30
                            #
                            #but problem is eval won't evaluate anything in {}, so
                            #\r will be sent literally, which is wrong. change {}
                            #to double quote will do correct it:
                            #
                            #    myputs "will send cmd -show system uptime-, "
                            #    send -i [set process] "show system uptime\r"
                            #    mysleep 30
                            #

                            set temp {
                                if [array exists expect_out] {
                                    foreach index [array name expect_out] {
                                        lappend match $expect_out($index)
                                    }
                                }
                            }

                            append expect_user_patterns [subst \
                                -nobackslashes -nocommands {
                                    $pat_flag {$user_pattern} {
                                        myputs "detected -$user_pattern-"
                                        myputs "will send cmd -$user_action_list-,\
                                            and continue expect"

                                        #this does not support substitution
                                        #send -i [set process] "$user_action_list\r"

                                        #add substitution feature, see config file
                                        #user_patterns key_changed
                                        eval {$temp}
                                        set user_action_list_subs \
                                            [info_subs2 "$user_action_list" [set match]]
                                             
                                        #(2016-11-18) this will only to send
                                        #  one cmd, not resolvable
                                        #exp_send -i [set process] \
                                        #    "[set user_action_list_subs]\r"
                                        exec_cmds $login_index {$user_action}

                                        #why sleep?
                                        #mysleep $retry_interval

                                        set buf_match_loc [string first \
                                            [lindex [set match] 0] [set buf]]
                                        set buf_rm_bef_matched [string replace \
                                            [set buf] 0 [set buf_match_loc]-1 ]
                                        set buf [string trimleft \
                                            [set buf_rm_bef_matched] [set match]]

                                        exp_continue
                                    }
                                }]
                        }
                    }   ;#done switch
                }   ;#done expect_matchany && "timeout" pattern check
            }   ;#done special commands
        }   ;#done iterating user_patterns
        myputs "expect_user_patterns looks $expect_user_patterns" 3


                #regarding the nested exp_continue in "RETRY":
                #
                #labroot@getafix-PE9-re1> request sys...
                #Mar 25 21:35:36
                #Chassis ISSU Check Done   
                #[Mar 25 21:35:36]:ISSU: Validating Image 
                #error: Backup RE not ready for ISSU ...    #<------
                #error: ISSU Aborted!                    
                #[Mar 25 21:35:36]:ISSU: Error          
                #Chassis ISSU Aborted                  
                #[Mar 25 21:35:36]:ISSU: IDLE         
                #                                    
                #{master}                           
                #labroot@getafix-PE9-re1>                   #<------
                #exec_cmds2:..detected -error: Backup RE not        
                #exec_cmds2:..will repeat cmd, and continue expect..
                #                                  
                #<<<<count {30}s before proceeding... 
                #timed out (30s) without interuption..... 
                #expected pattern -(% |> |# |$ |%|>|#|$)$- captured..    
                #myexpect_return looks -RETURN_EXPECT_SENDFIRST1_NORMAL-.
                #


        #there is one issue in the dynamic coding:
        #the later "subst" on the composed tcl statement (`myexpectcmd` in this
        #case) will resolve any vars (anything looks like $blabla) into it's
        #value - even in the comments. `subst $bla` does not recognize what is
        #in it's body $bla and can't tell the difference between comments or
        #normal tcl statement in it , it simply just look for any var-looking
        #thing and resolve it.  
        #
        #in this current case,  below expect_out var will be resolved,
        #unfortunately into possible very long strings depending on what is the
        #output of a command (can be 10M), also it may contain unmatched braces
        #or other unexpected strings that breaks the whole expect statement in
        #the later `eval`...
        #
        #the solution here, is to save any structures that we prefer to be
        #evaluated later by `eval`, but not by `subst`, into a new var, and put
        #this new var into the composed command. so `subst` will evaluate it
        #the the original structures that contains the original vars, which
        #will be finally evalulated by `eval`.
        #

    } else {
        myputs "either enable_user_patterns not set or user_patterns not defined!"
    }
}

#myexpectcmd {{{3}}}
#enable_user_patterns, no matchany
set myexpectcmd {
    expect {            
    -i "$user_spawn_id" ;#{{{4}}}
        -re [CONST $key_interact] {   ;#{{{5}}}               
            myputs2 "session:\\\[$router\\\]:you typed $key_interact key\
                here..."
            myputs2 "\nyou have the control now...\n"
            mycatch "stty -raw"
            #set oldmode [stty -raw]
            myputs "myexpect return RETURN_EXPECT_USER_INTERUPT"
            return "RETURN_EXPECT_USER_INTERUPT"
        }
        -re ".+" { ;#{{{5}}}
            puts "you typed something here when the automation is still\
                progressing...type $key_interact if you want to interupt the\
                script and to interact manually..."
            exp_continue
        }

    -i $process ;#{{{4}}}

        -re {$pattern} {        ;#{{{5}}}
            myputs "expected pattern -$pattern- captured"

            if $isSendFirst {   ;#{{{6}}}
                incr i;if {$i <= $host_num} {

                    if $parallel {
                        send_user "==output for \
                            $session2host($spawn_id):==\n"
                    }

                    #whenever log_user was set 0, send expect_out info
                    if ![log_user -info] {
                        $send_user_expect_out
                    }

                    $write_cmd_output

                    #if $i<$host_num {exp_continue}
                }
                #no need?
                #log_user 1
                return "RETURN_EXPECT_SENDFIRST1_NORMAL"

            } else {    ;#{{{6}}}

                if {[string equal {$cmd} "MATCH_AGAIN"]} {
                    return "RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN"

                } else {
                    if $timestamp {
                        myputs "timestamp is enabled"
                        send_user "\n[subst $current_time_cmd](local)\n"
                    } else {
                    }
                    myputs "sending data -[info_subs2 {$cmd}]- now after pattern match"
                    #exp_send -i $process {$cmd\r}
                    if $datasent_noreturn {
                        myputs "send without return"
                        exp_send -i $process "[info_subs2 {$cmd}]"
                    } else {
                        exp_send -i $process "[info_subs2 {$cmd}]\r"
                    }
                    return "RETURN_EXPECT_SENDFIRST0_NORMAL"
                }
            }
        }

        #expect_user_patterns {{{5}}}
        $expect_user_patterns

        -re {$pattern_more} {   ;#{{{5}}}
            exp_send -i $process "$pattern_more_key"
            exp_continue
        }

        timeout {       ;#{{{5}}}
            puts "timeout after ${timeout}s without a match for -$pattern-!"
            return "RETURN_EXPECT_TIMEOUT"
        }
        eof {           ;#{{{5}}}
            myputs "spawned process terminated!"
            return "RETURN_EXPECT_EOF"
            #exit 2
        }
        full_buffer {   ;#{{{5}}}
            myputs2 "got full buffer!"
            #return "RETURN_EXPECT_FULL_BUFFER"
            exit [CONST EXIT_ON_FULL_BUFF]
        }
    }
}

#myexpectcmd_matchany {{{3}}}
#enable_user_patterns, plus matchany
set myexpectcmd_matchany {
    #set oldtimeout $timeout
    #set timeout 10
    set buf ""
    expect {
        -i "$user_spawn_id" ;#{{{4}}}
        #-i [set tty_spawn_id] ;#{{{4}}}
            -re [CONST $key_interact] {   ;#{{{5}}}               
                myputs2 "session:\\\[$router\\\]:you typed $key_interact key\
                    here..."
                myputs2 "\nyou have the control now...\n"
                mycatch "stty -raw"
                #set oldmode [stty -raw]
                myputs "myexpect return RETURN_EXPECT_USER_INTERUPT"
                return "RETURN_EXPECT_USER_INTERUPT"
            }
            -re ".+" { ;#{{{5}}}
                puts "you typed something here...type $key_interact if you\
                    want to interupt crtc..."
                exp_continue
            }

        -i $process ;#{{{4}}}

            #if data is flowing, collect them in buf
            -re "..+" {  ;#{{{5}}}
                #append buf($expect_out(spawn_id)) [set expect_out(buffer)]
                set str_len [string length [set expect_out(buffer)]]
                myputs "get new strings:>>>"
                myputs "[set expect_out(buffer)], [set str_len]<<<" 2
                #collect all output to a buf, for later use - write to file or
                #send_user when "log_user 0"
                append buf [set expect_out(buffer)]
                myputs "this make the buf looks:\n>>>[set buf]<<<" 2

                #from buf, "manually" look for a match to expected pattern
                #
                #consideration1: per P150-151, just do pattern matching within
                #the new coming strings, instead of whole, will make it faster?
                #this exposes a possible issue - the patterns, make "span" both
                #new coming strings, and existing buf, in that case pattern
                #won't match
                #
                #switch -regexp -matchvar match -- [set expect_out(buffer)] {}
                
                #consideration2: this "matchall" method, defeats the usage of
                #exp_continue - unlike expect(buffer), a "manual buf" here will
                #never be removed by itself, this will make exp_continue
                #continue to match immediately, and endlessly... 
                #
                #one typical usage of exp_continue here, is the auto_paging
                #features. to support this in "matchall" version of dynamic
                #myexpect, we need to simulate what expect's default pattern
                #matching behavior - remove any matched pattern and all earlier
                #strings!
                switch -regexp -matchvar match -- [set buf] {
                    {$pattern} {
                        #patterns {{{6}}}
                        #if found
                        myputs "expected pattern -$pattern- captured"

                        #extract the captures
                        #if [info exists expect_out(1,string)] {
                        #    set 
                        #}

                        if $isSendFirst {   ;#{{{7}}}

                            incr i;if {$i <= $host_num} {
                                if $parallel {
                                    send_user "==output for \
                                        $session2host($spawn_id):==\n"
                                }
                                if ![log_user -info] {
                                    $send_user_expect_out
                                }

                                $write_cmd_output

                                #if $i<$host_num {exp_continue}
                            }
                            #log_user 1

                            #simulating default expect_out(buffer) behavior:
                            #removing all matched pattern and earlier strings
                            set buf_match_loc [string first \
                                [lindex [set match] 0] [set buf]]
                            set buf_rm_bef_matched [string replace \
                                [set buf] 0 [set buf_match_loc]-1 ]
                            set buf [string trimleft \
                                [set buf_rm_bef_matched] [set match]]

                            myputs "buf now looks:\n-[set buf]-" 3

                            return "RETURN_EXPECT_SENDFIRST1_NORMAL"

                        } else {    ;#{{{7}}}

                            if {[string equal {$cmd} "MATCH_AGAIN"]} {
                                return "RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN"

                            } else {
                                if $timestamp {
                                    myputs "timestamp is enabled"
                                    send_user "\n[subst $current_time_cmd](local)\n"
                                } else {
                                }
                                myputs "sending data -[info_subs2 {$cmd} [set match]]- now after\
                                    pattern match"
                                #this works, but may have issue if cmd contains
                                #backslashes-looking chars , which will be
                                #substituted (when no "-nobackslashes" was given)
                                #exp_send -i $process {$cmd\r}

                                #use command instead of values to protect var
                                #cmd from being substituted by subst
                                #exp_send -i $process "[set cmd]\r"
                                
                                myputs "datasent_noreturn looks $datasent_noreturn" 3
                                if $datasent_noreturn {
                                    myputs "send without a return"
                                    exp_send -i $process "[info_subs2 {$cmd} [set match]]"
                                } else {
                                    myputs "send with a return"
                                    exp_send -i $process "[info_subs2 {$cmd} [set match]]\r"
                                }

                                set buf_match_loc [string first \
                                    [lindex [set match] 0] [set buf]]
                                set buf_rm_bef_matched [string replace \
                                    [set buf] 0 [set buf_match_loc]-1 ]
                                set buf [string trimleft \
                                    [set buf_rm_bef_matched] [set match]]

                                return "RETURN_EXPECT_SENDFIRST0_NORMAL"
                            }
                        }
                    }

                    {$pattern_more} {
                       #pattern_more{{{6}}}
                        myputs "send pattern_more_key -$pattern_more_key- now" 
                        #clear current whole buff since it has been matched once
                        exp_send -i $process "$pattern_more_key"

                        #simulating default expect_out(buffer) behavior:
                        #removing all matched pattern and earlier strings
                        set buf_match_loc [string first \
                            [lindex [set match] 0] [set buf]]
                        set buf_rm_bef_matched [string replace \
                            [set buf] 0 [set buf_match_loc]-1 ]
                        set buf [string trimleft \
                            [set buf_rm_bef_matched] [set match]]

                        exp_continue
                    }

                    $expect_user_patterns

                    default {           ;#{{{6}}}
                        myputs "buf:no pattern match" 1
                        myputs "exp_continue on no match" 1
                        exp_continue
                    }
                }       ;#end switch
            }           ;#end -re .+

            #timeout_clause {{{5}}}
            #otherwise just a short timeout will detect this situation
            $timeout_clause

            eof {           ;#{{{5}}}
                myputs "spawned process terminated!"
                return "RETURN_EXPECT_EOF"
                #exit 2
            }
            full_buffer {   ;#{{{5}}}
                myputs2 "got full buffer!"
                #return "RETURN_EXPECT_FULL_BUFFER"
                exit [CONST EXIT_ON_FULL_BUFF]
            }
    }
    #set timeout [set oldtimeout]
}

#code: myinteract {{{2}}}
#myinteract_user_input_patterns {{{3}}}
set myinteract_user_input_patterns {       
    #no need per P342
    #eof { puts "spawned process exited!" }

    -echo "!?" usage_inline             ;#{{{4}}}
    "!!" {send -i $process "!"}         ;#{{{4}}}
    {\\} {send -i $process "\\"}        ;#{{{4}}}

    -echo -reset -re "!a" {             ;#{{{4}}}
        #set/display attributes/options values
        eval $interact_a 

        #special processing
        if $auto_paging {
            set pattern_more $pattern_more_const
        } else {
            set pattern_more $pattern_no_match
        }
        set options(pattern_more) $pattern_more
        myputs "pattern_more looks $options(pattern_more) now"
        set options_inline(pattern_more) $pattern_more

        #can't disable auto_paging after enabled, so testing with a return
        return
    }  

    -echo -re "!A" { interact_A;return }        ;#{{{4}}}
    -echo -reset "!b" { eval $interact_b } ;#close sharing tempararily {{{4}}}
    -echo -reset "!B" {      ;#to close sharing permanently {{{4}}}
        #TODO
    }
    -echo -re "!d" { interact_d; return}       ;#{{{4}}}
    -echo -re "!f" { interact_f; return}       ;#{{{4}}}
    #-echo -re "!M" { interact_M }      ;#{{{4}}}
    -echo -re "!H" { interact_H }       ;#{{{4}}}
    -echo -re "!n" { eval $interact_n }       ;#{{{4}}}
    -echo -re "!o" { interact_o }       ;#{{{4}}}
    -echo -re "!p" { interact_p }       ;#{{{4}}}
    -echo -re "!P" { interact_P }       ;#{{{4}}}
    -echo -re "!q" { interact_q }       ;#{{{4}}}
    -echo -re "!t" { interact_t; return }       ;#{{{4}}}
    -echo -re "!T" { interact_T; return }       ;#{{{4}}}
    -echo -re "!u" { interact_u; return }       ;#{{{4}}}
    -echo -re "!y" { interact_y }       ;#{{{4}}}
    -echo -re "!z" { interact_z; return }       ;#{{{4}}}
    -echo -reset "!c" { interact_c router }      ;#{{{4}}}
    -echo -reset -re "!r" { interact_r $router }       ;#{{{4}}}
    #-echo -reset "!n" { interact_n }    ;#{{{4}}}

    -echo -re "!h" { usage }    ;#{{{4}}}
    -echo -re "!v" { eval $interact_v }  ;#{{{4}}}
    -echo -re "!V" { version }  ;#{{{4}}}
    -echo -reset -re "!A" { interact_A }        ;#{{{4}}}
    -echo -reset -re "!k" { interact_k;return }        ;#{{{4}}}
    -echo -re "!m" { puts "host list: \n[parray login_info]" }  ;#{{{4}}}
    -echo -re "!D" { interact_D }       ;#{{{4}}}
    -echo -re "!E" { interact_E }       ;#{{{4}}}
    -echo -re "!C" { puts "edit config file";system vim $config_file }  ;#{{{4}}}
    -echo -re "!i" { if [file exists $help_file] {system less $help_file}} ;#{{{4}}}
    -echo -re "!O" { interact_O;return }        ;#{{{4}}}
    -echo -reset -re "!R" { if {[interact_R]==1} inter_return }         ;#{{{4}}}
    -echo "!s" { interact_s }    ;#{{{4}}}
    -echo "!+" { interact_plus; return }        ;#{{{4}}}
    -echo "!-" { interact_minus; return }       ;#{{{4}}}
    -echo -re "!I" {    ;#{{{4}}}
        puts "enter interpreter mode, type (literal) 'return' to go\
            back to crtc session"

        #this doesn't work
        #if {$tcl_interactive} {
        #    package require tclreadline
        #    ::tclreadline::Loop
        #}    

        interpreter
        puts "returning back to crtc..."
    }
    #-reset "\032" {}
    #use !^z to send to trigger SIGTSTP to local script
    #leave ^z to be sent literally to spawned process
    -reset "![CONST $key_background]" {      ;#{{{4}}}
        puts "\[session $router\]: you pressed a keystroke\
            \"!$key_background\" that moves this session background,\
            type `fg` to move it foreground when needed!"
        exec kill -STOP [pid]
    }
    #-nobuffer -re "$pattern_timestamp" {  ;#{{{4}}}
    #    #without -nobuffer, need following to "suppliment" the
    #    #return (which was suppressed by interact match)
    #    #puts -nonewline "\r"
    #    #send -i $process "\r"
    #    send_user $automation_non_complete_msg
    #    if $timestamp {
    #        set totimestamp 1
    #        set is_usertyping 0
    #        myputs "will timestamp"
    #    }
    #    myputs "\nmatch enter from pattern_timestamp"
    #    #if $timestamp {
    #    #    #Dec 01 09:34:26
    #    #    send_user "\n[exec date $dateformat](local)"
    #    #} else {
    #    #}
    #}
    #sequence matter here, put this behind pattern_timestamp match
    #-nobuffer -re "\r" {  ;#{{{4}}}
    #    send_user $automation_non_complete_msg
    #    myputs "\nmatch enter from slash r"
    #    set is_usertyping 0

    #    #during kibitz, whenever another folk start typing, send a notice to
    #    #others indicating who is typing
    #    if $ownertyping {
    #    } else {
    #        send -i $kibitz_list "\r\n<---$env(USER) is typing ...\r\n"
    #        set ownertyping 1
    #        foreach asid [array name sid2typing] {
    #            set sid2typing($asid) 0
    #        }
    #    }

    #}
    -nobuffer -re "\[^!\\\\]+|$pattern_timestamp" {            ;#{{{4}}}
        eval $interact_any
    }
    #-re "\\\\(\\d)" {
    #}
    #-reset -re "\\\\(\[isq\]|(\\d+))" {}
    -reset -re "\\\\(\[iksqlc\]|(\\d+))" {       ;#{{{4}}}
        eval $interact_multi_session
    }
    -reset -re "!N" { interact_N; return }  ;#{{{4}}}
    -echo -reset -re "!M" {                 ;#{{{4}}}
        set eventmonitor 1
        puts "eventmonitor is 1"
        return 
    }
    -echo -reset "!Q" {  ;#{{{4}}}
        puts "uit the script!"
        exit            
    }
    
    -echo -re "!Z" { interact_Z; return } ;#{{{4}}}

    -echo -reset "!l" {         ;#{{{4}}}
        eval $interact_l
    }           ;#!l

    -echo -reset "!g" {         ;#{{{4}}}
        incr anti_idle_timeout_user_input 2; 
        send_tty "timeout increased to $anti_idle_timeout_user_input    \r"
        return
    }

    -echo -reset "!G" {         ;#{{{4}}}
        incr anti_idle_timeout_user_input -2; 
        send_tty "timeout reduced to $anti_idle_timeout_user_input    \r"
        return
    }

    #seems better to monitor ingress flows instead of user typing?
    timeout $anti_idle_timeout_user_input {       ;#{{{4}}}
        eval $interact_timeout 
    }

}

#code_myinteract_user_patterns {{{3}}}
set code_myinteract_user_patterns {
    set event_action_list ""
    set myinteract_process_input_user_patterns ""

    #check user_patterns array {{{4}}}
    #
    #set user_patterns(nsr_not_active) 
    #    [list "warning: GRES not configured" cmds3 interact_only]

    #                         user_pname 
    #                           ^
    #                           |
    #set user_patterns(login_retry_diff_account) 
    #   [list "ogin: $" "RECONNECT $reconnect_eval" interact_only]
    #          -------   -------------------------
    #            ^       ^ ------    -------------
    #            |       |      ^       ^
    #            |       |      |       |
    #            |       |      |       |
    #            |       | action_name user_action_eval
    #      user_pattern user_action  

    if {$enable_user_patterns >= 2} {
        #use info in user_patterns array only when 
        #enable_user_patterns set 2 (use the info for interact only) or 
        #enable_user_patterns set 3 (use the info for both)
        foreach user_pname [array name user_patterns] {

            global $user_pname

            #skip when expect_only
            if [ni "expect_only" $user_patterns($user_pname)] {

                #use the pattern, only when "user_pname" defined, and not 0
                #this allows a control to each single user pattern
                if {(![info exists $user_pname]) || \
                    ([set $user_pname] != 0) \
                   } {
                    #first var in list is user_pattern
                    set user_pattern [lindex $user_patterns($user_pname) 0]
                    #2nd var in list is user_action
                    set user_action [lindex $user_patterns($user_pname) 1]
                    #puts "user_pattern:user_action looks -$user_pattern:$user_action-"

                    #convert the array to a pattern - action list 
                    #user_patterns:
                    #  user_patterns(pa) "p1 a1"
                    #  user_patterns(pb) "p2 a2"
                    #=>
                    #event_action_list:
                    #  "p1 a1 p2 a2"
                    lappend event_action_list "$user_pattern" "$user_action"
                    myputs "$user_pname not exists or is not 0, use this pattern" 3
                } {
                    myputs "$user_pname exists and is 0, turn off this user\
                    pattern" 3
                }
            }
        }

        #merge with eventscript array {{{4}}}
        #
        #set eventscript(myrouter)       [list      \
        #    "$event1"        "cmds3"               \
        #    "$event2"        "cmds4"               \
        #]
        #
        if [info exists eventscript($router)] {

            foreach a $eventscript($router) {
                lappend event_action_list $a
            }

        }

        myputs "event_action_list looks $event_action_list" 3

        #nested eval, caused issues
        #set eval_action_handler_reconnect {eval [set $action_handler(RECONNECT)]}

        #iterate event_action_list to 
        #generate myinteract_process_input_user_patterns {{{4}}}
        set i 0;set j 1

        for {set i 0} {$i<=[expr [llength $event_action_list]-1]} {incr i} {

            #set user_patterns(login_retry_diff_account) \
            #   [list "ogin: $" "RECONNECT $reconnect_eval"]
            #
            #event is "ogin: $"
            set event [lindex $event_action_list $i]
            incr i
            #user_action is "RECONNECT $reconnect_eval"
            set user_action [lindex $event_action_list $i]
            #action_name is RECONNECT


            #this is to workaround a tricky tcl behavior:
            #1.for a string with only blanks, lindex returns none, instead of
            #spaces:
            #
            #expect [~]set abc [lindex "   " 0]
            #expect [~]puts "abc is -$abc-"
            #abc is --
            #
            #2.for non-spaces string, lindex returns non-spaces
            #expect [~]set abc [lindex "   x y" 0]
            #x
            #expect [~]puts "abc is -$abc-"
            #abc is -x-
            #

            if [regexp {^\s+$} $user_action] {
                #otherwise action_name will be none
                set action_name $user_action
            } else {
                set action_name [lindex "$user_action" 0]
            }

            myputs "event: -$event-" 3
            myputs "user_action: -$user_action-" 3
            myputs "action_name: -$action_name-" 3

            append myinteract_process_input_user_patterns [subst -nocommands {
                -reset -nobuffer -re {$event} {

                    myputs2 "\n\n"
                    myputs2 "<<<interact: detected event:\n"
                    myputs2 "<<<-[set interact_out(0,string)]-\n"
                    myputs2 "<<<which matches defined pattern(event):\n-"
                    myputs2 {<<<$event-\n}
                    
                    switch -regexp -- "$action_name" {
                        "RECONNECT.*" {   ;#{{{5}}}
                            myputs2 "\r\nconfigured action is RECONNECT"
                            #this caused constant coredump, don't know why?...
                            #maybe because too complicated nested eval?
                            #
                            #eval_action_handler_reconnect
                            #
                            #this works.
                            if {[set persistent]>1} {
                                myputs2 "persistent mode set [set persistent]"
                                puts -nonewline "\r\n<<<[clock format [clock\
                                    seconds]]:CRTC will reconnect in \
                                    ${reconnect_interval}s\n"
                                myputs2 "type !p to toggle persistent mode"
                                mysleep $reconnect_interval
                                #below line worked fine previously when spawn was not
                                #put in spawn_login , there is issue afterward: "puts
                                #no stdout", or "exp0 not open"
                                #
                                #issue found to be "spawn_id" not set as "global" in
                                #spawn_login proc
                                puts "\r\nreconnecting..."
                                close; wait
                                set is_respawn 1
                                return 1
                            } else {
                                puts "persistent mode set [set persistent],\
                                    won't reconnect\n"
                            }

                        }
                        "EXIT.*" {   ;#{{{5}}}
                            exit
                        }
                        "RETRY.*" {   ;#{{{5}}}
                        }
                        "CTRLC.*" {   ;#{{{5}}}
                        }
                        "CONTINUE.*" {   ;#{{{5}}}
                        }
                        "EMAIL.*" {       ;#{{{5}}}
                            postanemail $emailto "crtc:event captured!" \
                                "monitored event:\n$event\n is captured!"
                            if [regexp "attach" $action_name] {
                                sendanemail $log_fullname_cur $emailto
                            }
                        }
                        default {       ;#{{{5}}}

                            #why don't we simply use the user_action instead of
                            #action_name? 
                            if [string equal {$user_action} ""] {
                                send_user -- "no action name configured!"
                            } else {
                                if [regexp {^\s+$} {$user_action}] {
                                    send -i $process {$user_action\r}
                                } else {
                                    send_user -- {\r\n<<<CRTC:will execute\
                                        configured action group -$user_action-!!\r\n}
                                    myputs2 {<<<CRTC: \n\\\"$user_action\\\" \
                                        looks a normal cmdgroup, will execute}
                                    exec_cmds $router {$user_action}
                                }
                            }
                        }
                    }

                }
            }]
        }

        #generate myinteract_process_input_patterns_misc {{{4}}}
        append myinteract_process_input_patterns_misc [subst -nocommands {

            -nobuffer -re {$pattern_more} {         ;#{{{5}}}
                myputs "there is a match!!"
                puts "[set interact_out(0,string)]"
                if $auto_paging {
                    myputs "auto_paging set, send intial cr"
                    send -i $process "$pattern_more_key"
                }
            }

            -nobuffer [CONST CR] {                ;#{{{5}}}
                if [set totimestamp] {
                    myputs "totimestamp set to 1, timestamp!" 3
                    if [set timestamp] {
                        #Dec 01 09:34:26
                        send_user "\n[subst $current_time_cmd](local)\n"
                    } else {
                    }
                } else {
                    myputs "totimestamp set to 0, no timestamp!" 3
                }
                set totimestamp 0
            }

            -re {$pattern_timestamp_verbose} {    ;#{{{5}}}
                myputs "get a return from cmd output"
                #puts "[set interact_out(1,string)] \[[clock format [clock seconds]]\]"
                puts "[set interact_out(1,string)] [clock format [clock seconds]]"
                #puts -nonewline "[set interact_out(0,string)]"
            }

            timeout $anti_idle_timeout_proc_input {        ;#{{{5}}}
                eval {$interact_timeout}
            }

        }]
            #-iwrite -re $pattern_cmd_input {                          ;#{{{4}}}
            #    myputs "get an input -[set interact_out(0,string)]-"
            #    interact_pattern_cmd_input [set interact_out(0,string)]
            #}

        #this doesn't work
        #append myinteract_process_input_patterns_misc [subst -nocommands {
        #    -iwrite -nobuffer -exact "[set kibitz_shell_prompt]" {   ;#{{{4}}}

        #        puts "detected -[set kibitz_shell_prompt]-"

        #        #move back (from kibitz_shell list) into shell_list
        #        lappend shell_list  [set interact_out(spawn_id)]
        #        ldelete kibitz_list [set interact_out(spawn_id)]
        #        ldelete kibitz_user_list [set sid2user(interact_out(spawn_id))]
        #        set kibitz_list_ori [set kibitz_list]

        #        send -i "[set user_spawn_id] [set kibitz_list]"\
        #            "remote user [set sid2user([set interact_out(spawn_id)])]\
        #            disconnected!"

        #        #kill shell if remote user exit, seems better to keep
        #        #it?
        #        #
        #        #set a [set kibitz_list]
        #        #exec kill -9 [exp_pid -i [set kibitz_list]]
        #        #close -i [set a]
        #        #wait -i [set a]

        #    }
        #}]

        myputs "myinteract_process_input_user_patterns looks\
            $myinteract_process_input_user_patterns" 3
        myputs "myinteract_process_input_patterns_misc looks\
            $myinteract_process_input_patterns_misc" 3
    }
}

#myinteract_process_input_patterns_static {{{3}}}
set myinteract_process_input_patterns_static {

    #timeout $anti_idle_timeout_proc_input {        ;#{{{4}}}
    #    #this will never be matched, due to the last "timeout 1" clause
    #    #interact_timeout 
    #    eval $interact_timeout
    #}

    #these, seriously affact the performance in a slow system!
    #but a good/normal server has no problem!
    #TODO: better move to user pattern
    -nobuffer -re $pattern_more {         ;#{{{4}}}
        myputs "there is a match!!"
        puts "$interact_out(0,string)"
        #if $auto_paging {send -i $process "\r"}
        if $auto_paging {
            myputs "auto_paging set, send intial cr"
            send -i $process "$pattern_more_key"
        }
    }
    -nobuffer "\r" {                ;#{{{4}}}
        if $totimestamp {
            myputs "totimestamp set to 1, timestamp!" 3
            #send_user "\r\n"
            if $timestamp {
                #Dec 01 09:34:26
                send_user "\n[subst $current_time_cmd](local)\n"
            } else {
            }
        } else {
            myputs "totimestamp set to 0, no timestamp!" 3
        }
        set totimestamp 0
    }
    -re $pattern_timestamp_verbose {    ;#{{{4}}}
        myputs "get a return from cmd output"
        puts "$interact_out(1,string) \[[clock format [clock seconds]]\]"
        #puts -nonewline "$interact_out(0,string)"
    }
    #(2016-06-23) to be "static", seems no need to keep these "reconnect"
    #features, otherwise still invoke reconnect due to command output
    #-nobuffer -re $pattern_connection_close_msg {  ;#{{{4}}}
    #    #don't detect connection close msg in interact mode,to prevent
    #    #these text from "show log message" invoke an reconnection
    #    interact_connection_close; 
    #    #puts "pattern_more now looks: $pattern_more"
    #    return
    #}
    #-nobuffer -re $pattern_broken_pipe {  ;#{{{4}}}
    #    interact_connection_close; 
    #    return
    #}

    -nobuffer null {
        send_user "detected a null during automation!"
    }

    eof {       ;#{{{4}}}
        myputs "detected eof during interaction..."
        exit
    }

    #this defeated kibitz feature!  why?
    #disable tempararily (2016-07-05) 
    #symptom is, typing from owner or from remote user, only display in owner
    #terminal, not in remote user's terminal...
    #-iwrite -re $pattern_cmd_input {                          ;#{{{4}}}
    #    myputs "get an input -$interact_out(0,string)- from process input"
    #    interact_pattern_cmd_input $interact_out(0,string)
    #}

    #-re "^(?!$clockcmd).*$pattern_common_prompt$" {
    #    puts "$interact_out(0,string)"
    #    send "$clockcmd\r"
    #}

    #disable this to make other normal timeout take effect (2016-06-18) 
    ##this is to detect any pause of command output (session input from
    ##Expect perspective), and dump output from other session only after
    ##the pause were detected; 
    ##the goal is the avoid messed output due to the random mixture of
    ##text from different sessions
    #-iwrite timeout 1 {                 ;#{{{4}}}
    #    #on detection of a small timeout in the cmd output stream,
    #    #reset the does_holdsession flag and return (to while loop)
    #    #where the process_input will be reset to all sessions
    #    if $parallel==2 {
    #        myputs "input seems paused from $currenthost, release it" 2
    #        set does_holdsession 0
    #        #set process_input [arrayvalue host2session]
    #        #send_user "set session input to $process_input\n"
    #        return
    #    }
    #    myputs "-iwrite timeout 1 for multi hosts" 1
    #}
}

#myinteract_kibitz_input_patterns {{{3}}}
set myinteract_kibitz_input_patterns {
    #for invitelocal, just detect eof(the other user exit)
    #directly, then clear kibitz_list (not to close it) 
    #this is to prevent spawn_id being closed and script will
    #bail out
    -iwrite eof {       ;#{{{4}}}
        myputs "detected eof from [set interact_out(spawn_id)]"
        #lappend shell_list  [set interact_out(spawn_id)]
        ldelete kibitz_list [set interact_out(spawn_id)]
        ldelete kibitz_user_list\
            [set sid2user([set interact_out(spawn_id)])]
        set kibitz_list_ori [set kibitz_list]

        send -i "[set user_spawn_id] [set kibitz_list]"\
            "local user [\
                set sid2user([set interact_out(spawn_id)])\
            ] get disconnected!"
    }

    #for inviteremote, kibitz running in a new shell, so no way
    #to detect eof, so just monitor the kibitz shell prompt,
    #and determine if other user exit
    #this does not seem to be reliable
    #put this under process_input does not work
    -iwrite -nobuffer -exact "$kibitz_shell_prompt" {   ;#{{{4}}}

        puts "detected -$kibitz_shell_prompt-"

        #move back (from kibitz_shell list) into shell_list
        lappend shell_list  $interact_out(spawn_id)
        ldelete kibitz_list $interact_out(spawn_id)
        ldelete kibitz_user_list $sid2user($interact_out(spawn_id))
        set kibitz_list_ori $kibitz_list

        send -i "$user_spawn_id $kibitz_list"\
            "remote user $sid2user($interact_out(spawn_id)) disconnected!"

        #kill shell if remote user exit, seems better to keep
        #it?
        #
        #set a [set kibitz_list]
        #exec kill -9 [exp_pid -i [set kibitz_list]]
        #close -i [set a]
        #wait -i [set a]

    }



    #during kibitz, whenever another folk start typing, send a
    #notice to others indicating who is typing
    -iwrite -nobuffer -re "\r" {        ;#{{{4}}}
        set kibitz_list_backup $kibitz_list
        set curr_sid $interact_out(spawn_id)
        set curr_user $sid2user($curr_sid)

        if $sid2typing($curr_sid) {
        } else {
            send -i "$user_spawn_id [ldelete kibitz_list_backup $curr_sid]"\
                "\r\n<---$curr_user is typing ...\r\n"
            set ownertyping 0
            foreach asid [array name sid2typing] {
                set sid2typing($asid) 0
            }
            set sid2typing($curr_sid) 1
        }
    }
}


#libs {{{1}}}

#to reduce number of files, include procs directly
#source ~/bin/mylib.tcl
proc myputs {msg {level 1} args} { ;#{{{2}}}
    global debug login_index
    if ![info exists login_index] {
        set sessionname ""
    } else {
        set sessionname $login_index
    }
    set procname [lindex [info level 1] 0]
    set msg1 "\[[clock format [clock seconds]]\]:\[$sessionname\]:$procname:..$msg.."

    #make use of meaningless "-1", as a knob, to print with myputs2
    #  which, won't be affacted by pipe |, and print to terminal anyway.
    #  puts, instead, will be piped with |, so grep will work on puts, not on
    #  send_tty
    if {$level==-1} {
        send_tty $msg
    } elseif {$debug>=$level} { 
        #in debugging, if file name provided at the end:
        #1. write into the file
        #2. start extensive debug
        if {[llength $args]} {
            set debugfile [lindex $args 0]
            set h_debugfile [myopen $debugfile w]
            #puts $h_logfile "\[[exec date]:[lindex [info level -1] 0]:..$msg..\]"
            if {$h_debugfile != 0} {puts $h_debugfile "$msg1"}
            if {$debug>=3} {exp_internal -f $debugfile 0}
            close $h_debugfile         ;#very important
        #if no filename,
        #1. only start extensive debug
        } else {
            if {$debug>=3} {
                #this is too much info ...
                #exp_internal -f crtc.debug.log 0
            }
            puts -nonewline "$msg1\r\n"
            #send_tty "$msg1\n"
            #mycatch "send_tty [list $msg1]\n"
        }
    } else {

    }
}

proc myputs2 {msg} {    ;#{{{2}}}
    global redirect_inshell verbose
    #global global_data; eval $global_data
    if $verbose {
        if $redirect_inshell {
            #if redirected in a shell script, use puts so everything can be
            #redirected. remove \n but append a \r to emulate send_ behavior,
            #this can be used to replace all send_*, useful under slow
            #interact (when, all send_ will also be slow down). and it also
            #work well under raw mode
            puts -nonewline "$msg\r"
        } else {
            #if redirected interactively in bash, use send_tty to bypass the
            #redirection, easier to monitor the progress
            send_tty $msg
        }
    }
}

proc myputs3 {msg} {    ;#{{{2}}}
    #same as myputs2, and it will ignore verbose and redirect_inshell options
    puts -nonewline "$msg\r"
}

proc catchevalexec {cmd} { ;#{{{2}}}
    global debug
    if { 					\
            [catch  				\
                {eval exec 			\
                    $cmd 			\
                }  				\
                msg 				\
            ] 					\
        } {
       myputs "Something seems to have gone wrong:"
       myputs "Information about it: $::errorInfo"
       return 1
    } else {
	return 0
    } 
}

proc mycatch {cmd} {    ;#{{{2}}}
    if { [catch {eval $cmd} msg] } {
       puts "Something seems to have gone wrong:"
       puts "Information about it: $::errorInfo"
       return 1
    } else {
	return 0
    } 
}

proc sendanemail {file emailto} { ;#{{{2}}}
    #global debug compress_log
    #get file from glob (like unix)
    set files [glob -nocomplain $file]
    myputs "get file lists: $files"
    if $::compress_log {
        myputs "zip set, will send zipped file"
        set attachname "$file.zip"
        set execcmd \
            "zip -jq - {expand} [glob -nocomplain $file] |\
            uuencode $attachname |\
            mail -s \"log file:$file\" $emailto"
    } else {
        set attachname [exec basename $files]
        if $debug {myputs "zip not set, will send plain text file"}
        #looks only 1 file is support at a time with uuencode
        #this broke after upgrading to 12.04LTS
        set execcmd "uuencode [glob -nocomplain $file] $attachname |  \
            mail -s \"log of case:$file\" $emailto"

        #set execcmd "sendemail -s pod51010.outlook.com:587 -f \
        #  pings@juniper.net -t pings@juniper.net -u \"log of case:$caseid\" \
        #  -m \"this is the log file: $file\" -xu pings@juniper.net -xp \
        #  \"EMAILPASSWORD\" -o tls=auto -a [glob -nocomplain $file]"
        #set execcmd "sendthisfile.sh [glob -nocomplain $file] pings@juniper.net \
        #  \"log of case:$caseid\" "
    }

    if {[catchevalexec $execcmd]} {
    } else {
        myputs "send email to $emailto with \
            logfile:$files as attachment:$attachname"
    }
}

proc postanemail {emailto {emailsub "No subject"} {emailbody}} {  ;#{{{2}}}
    #using mail

    global emailapp

    #puts "email_on_event set, will send email with \
    #    log as attachment to $emailto"
    #stty cooked;debug 1

    #set emailcmd \
    #    [subst "echo \"$emailbody\" | [set emailapp] \
    #    -s \"$emailsub\" $emailto"]

    set emailcmd \
        "echo \"$emailbody\" | [set emailapp] \
        -s \"$emailsub\" $emailto"

    myputs "emailcmd looks -$emailcmd-"
    catchevalexec $emailcmd
    myputs "email sent..."

    #system $emailcmd
    #mycatch $emailcmd

    #exec echo "$emailbody" | $emailapp -s $emailsub $emailto

}

proc postanemail2 {emailto {emailsub "No subject"} {emailbody}} {  ;#{{{2}}}
    #using sendmail

    myputs "sending email..."
    global env
    ##this does not seem to be working
    #set replyto "no-reply-$env(USER)@juniper.net"
    #set body $emailbody
    #
    #exec sendmail -t << "To: $emailto 
    #    Subject: $emailsub 
    #    From: $replyto
    #    In-reply-to: $replyto
    #    $emailbody"
    #

    set from "$env(USER)@juniper.net"
    set replyto "no-reply-$env(USER)@juniper.net"
    
    #only this works, no indentation, no continuation...
    exec /usr/sbin/sendmail -t << "To: $emailto\r\nFrom:\ 
    $replyto\r\nSubject: $emailsub\r\nIn-reply-to: $replyto\r\n\r\n\
    $emailbody"

    myputs "email sent..."
}

#myexpect {{{2}}}
proc myexpect {router pattern cmd {mytimeout 60} {isSendFirst 1} {isPersis 1}} { 
    myputs "==>entering myexpect"

    #return: {{{3}}}
    #set constant(RETURN_EXPECT_SENDFIRST0_NORMAL) 111010
    #    isSendFirst 0, matched a pattern and sent a cmd
    #set constant(RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN)   111011
    #    isSendFirst 0, send "expect_out" "fake data" (won't really send) 
    #    just to aquire the previous cmd output
    #set constant(RETURN_EXPECT_SENDFIRST1_NORMAL) 111012
    #    isSendFirst 1, first sent cmd and then got pattern match

    #set constant(RETURN_EXPECT_USER_INTERUPT)     111110
    #    if user typed anything (request control), before cmd was sent

    #set constant(RETURN_EXPECT_CONN_UNABLE)       111210
    #    got "telnet: Unable to connect to remote host"
    #set constant(RETURN_EXPECT_CONN_CLOSED)       111211
    #    got "connection closed"
    #set constant(RETURN_EXPECT_CONN_CONSOLE1)     111213
    #    got console msg

    #set constant(RETURN_EXPECT_TIMEOUT)           111310
    #    got timeout
    #set constant(RETURN_EXPECT_EOF)               111311
    #set constant(RETURN_EXPECT_FULL_BUFFER)       111312
    
    global global_data;eval $global_data

    global expect_user_patterns send_user_expect_out timeout_clause
    global write_cmd_output myexpectcmd myexpectcmd_matchany

    #parallel {{{3}}}
    #in parallel mode, use expect's "indirect spawn_id list" ability to
    #send/expect multiple sessions .of course for expect it's still expecting
    #one (whoever first come) session at a time, so exp_continue will be used
    #below to make the output looks less messed out
    
    if $parallel {
        #suppress default output under parallel mode
        #will send "manually" later
        set process [arrayvalue host2session]
        myputs "parallel set $parallel, log_user set 0!"
        log_user 0
    } else {
        set process $host2session($router)
    }
    set host_num [llength $process]

    #set controlC \x03
    set timeout $mytimeout

    #sendfirst mode {{{3}}}
    #exp_send -i $process "\r"
    #if in "send-n-expect" mode, send data before expect
    if $isSendFirst {

        #log_user 0 if prefix_mark set {{{4}}}
        #for now just do it in "sendfirst mode", or non pa_pair situation
        if $during_login {

        } elseif $during_cmd {

            #(only) during cmd sending, if prefix_mark given, then block default
            #display and only send_user modified one
            if {$prefix_mark != 0} {
                myputs "during_cmd and prefix_mark not 0, log_user set 0!"
                log_user 0
            } else {
            }

        } else {

        }

        #set timestamp {{{4}}}
        if $timestamp {
            myputs "timestamp is enabled"
            #send_user "\n[exec date $dateformat](local)\n"
            send_user "\n[subst $current_time_cmd](local)\n"
        } else {
            myputs "timestamp is not enabled"
        }

        myputs "sending data \"$cmd\" to $process even before pattern\
            ($pattern) match"
        #send_user "[time_now](local)\n"
        exp_send -i $process "[info_subs2 $cmd]\r"
        myputs "expecting pattern ($pattern) after already sent string \"$cmd\""

    } else {
        myputs "awaiting for pattern ($pattern) before sending string \"$cmd\""
    }
    
    #this doesn't work well, this expect_before effect will also be "prefixed
    #before" all other (later) expect command...need more study on it
    #expect_before -i $user_spawn_id -re $key_interact {
    #    puts "--------------------------------------->"
    #    send_tty "you want to type sth here? go ahead...\n"
    #    stty -raw
    #    return 5
    #}

    #VERY IMPORTANT! without this the below -i $user_spawn_id may not work well
    #   - it works only the first iteration, then won't work
    #   (2016-05-30)    #<------is it true? why? comment it out and testing...
    #
    #mycatch "stty raw"
    
    set i 0

    if ![array exists expect_out] {
        set expect_out(buffer) ""
        set expect_out(spawn_id) ""
        set expect_out(0,string) ""
    }

    #expect {{{3}}}
    #
    #if set enable_user_patterns {{{4}}}
    #
    #check user_patterns(pattern) array and compose expect dynamically,
    #the "user_pattern" array looks:
    #
    ##connection management
    #set user_patterns(pattern_not_resolve_msg)              [list "ould not resolve"]

    if [expr {$enable_user_patterns && [array exists user_patterns]}] {

        myputs "enable_user_patterns set ($enable_user_patterns) and\
            user_patterns array not empty"
        myputs "will eval the dynamically pre-composed expect!"

        #pattern original is "(% |> |# |\\\$ |%|>|#|\\\$)$"
        #     will looks -re "(% |> |# |\$ |%|>|#|\$)$" {...} after subst
        #     need to "compensate" some '\'s, to recover it's original value
        #     here we replace literal "\$" to "\\\$"
        #
        #if ![regsub -all {\\\$} $pattern {\\\\\$} pattern_slash] {
        #    set pattern_slash $pattern
        #}
        #
        #this is necessary if later use -re "$pattern", 
        #but no need if use -re {$pattern}
        #
        #-re "$pattern" is quite like tcl do subst first, so some "\"s were
        #absorbed
        if ![regsub -all "\"" $cmd "\\\"" cmd_no_quote] {
            set cmd_no_quote $cmd
        }

        #eval myexpectcmd {{{5}}}
        set myexpectcmd [expr {$expect_matchany ? $myexpectcmd_matchany : $myexpectcmd}]

        #if [string equal $cmd "show version"] {exp_internal 1}
        myputs "original myexpectcmd looks:\n$myexpectcmd" 3

        set myexpectcmd_subs [subst -nocommands $myexpectcmd]
        #testing ... doesn't work (2016-10-01) 
        #set myexpectcmd_subs [subst -nocommands -nobackslashes $myexpectcmd]
        #
        #issue:
        #in cmds1:
        #
        #       " (\d+) " "sudo -k virsh vcpuinfo %1" \
        #
        #after substitution the final expression becomes " (d+) " in expect
        #
        #solution:
        #
        #       { (\d+) } "sudo -k virsh vcpuinfo %1" \

        myputs "substituted myexpectcmd looks:\n$myexpectcmd_subs" 3
        #sleep 1

        #myputs "subst looks ---[subst $expect_user_patterns]---" 

        #eval [subst -nocommands -nobackslashes $myexpectcmd]
        #exp_internal 1
        eval $myexpectcmd_subs
        #exp_internal 0

    #if no enable_user_patterns {{{4}}}
    #  or user_patterns doesn't exists, use "static" expect statement
    #
    #  TODO: need to phase out this block when user_patterns become stable...
    #
    } else {

        myputs "enable_user_patterns not set ($enable_user_patterns) or\
            user_patterns array empty"
        myputs "will use static expect!"

        #exp_internal 1
        expect {            
            #this user pattern (\r) will be completing with others and so
            #may not be captured - device input normally is faster 
            #this is why we need to press enter for a while to capture it.
            #need some improvement, but no harm to leave it, better than nothing..
            -i $user_spawn_id                                       ;#{{{5}}}
            -re [CONST $key_interact] {                                 ;#{{{6}}}
                myputs2 "process:\[$router\]:you typed $key_interact key here..."
                myputs2 "\nyou have the control now...\n"
                mycatch "stty -raw"
                #set oldmode [stty -raw]
                myputs "myexpect return RETURN_EXPECT_USER_INTERUPT"
                return "RETURN_EXPECT_USER_INTERUPT"
            }
            -re ".+" {
                puts "you typed something here...type $key_interact if you want \
                      to interupt crtc..."
            }
            -i $process                                              ;#{{{5}}}
            #user_patterns {{{6}}}

            -nocase -re $pattern_broken_pipe {                      ;#{{{7}}}
                #"Write failed: Broken pipe"
                myputs "detected -$pattern_broken_pipe-\r"
                return "RETURN_EXPECT_BROKEN_PIPE"
            }
            -nocase -re $pattern_connection_close_msg {             ;#{{{7}}}
                myputs "detected -$pattern_connection_close_msg- ... msg\r"
                return "RETURN_EXPECT_CONN_CLOSED"

                #these works, but too dirty/mess and should abandon
                #persistent should be implmented in higher level, not in here
                #if $isPersis {
                #    #moved the reconnection code to "reconnect_todo"
                #} else {
                #    return
                #    #exit 1   ;#something wrong, simply exit script
                #}
            }
            -re $pattern_not_resolve_msg {                          ;#{{{7}}}
                myputs2 "detected -$pattern_not_resolve_msg-\r"
                return "RETURN_EXPECT_NOT_RESOLVED"
            }
            #for console
            -re $pattern_console_msg {                              ;#{{{7}}}
                myputs2 "looks a console msg\r"
                exp_send -i $process "\r"; exp_continue
                return "RETURN_EXPECT_CONN_CONSOLE1"
            }
            -nocase -re $pattern_connection_unable {                ;#{{{7}}}
                myputs "detected -$pattern_connection_unable-\r"
                return "RETURN_EXPECT_CONN_UNABLE"
            }

            -re "$pattern" {                                        ;#{{{6}}}
                myputs "expected pattern -$pattern- captured"
                myputs "output looks: $expect_out(buffer)" 2
                #myputs "loguser is [log_user -info]"

                if $isSendFirst {
                    #for multiple hosts, need to do multiple expect iterations so
                    #each will catch output from one process
                    
                    #todo: add similiar sessionhold/release as did for interact
                    #  to have a better format in multihost scenario
                    #  it looks different for expect than interact.
                    #  here only to match "pattern", anything before this had been
                    #  printed to the terminal - possibly output from both process
                    #  had mixed together
                    #
                    #  one solution is to turn off log_user and just print buf -
                    #  which was cached seperately..
                    incr i;if {$i <= $host_num} {
                        #set process $expect_out(spawn_id)
                        #append buf($expect_out(spawn_id)) $expect_out(buffer)
                        if $parallel {
                            send_user "==output for\
                                $session2host($expect_out(spawn_id)):==\n"
                        }
                        send_user "$expect_out(buffer)\n"

                        set buf $expect_out(buffer)
                        eval $write_cmd_output

                        if $i<$host_num {exp_continue}
                    }
                    myputs "log_user set 1!"
                    log_user 1
                    return "RETURN_EXPECT_SENDFIRST1_NORMAL"
                    #return only code, instead of cmd output to caller, 
                    #share cmd output via global var
                    #return $expect_out(buffer)

                } else {

                    #when matching pattern, instead of send any new cmd, send a
                    #fake cmd "MATCH_AGAIN", just to match the pattern one more
                    #time, and nothing will be sent.the purpose is to just to get a
                    #new expect_out(buffer) - which is the previous cmd output
                    if {$cmd == "MATCH_AGAIN"} {
                        return "RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN"
                        #return $expect_out(buffer)

                    } else {
                        #"expect-n-send" mode, send data only after expect
                        if $timestamp {
                            myputs "timestamp is enabled"
                            send_user "\n[subst $current_time_cmd](local)\n"
                        } else {
                            #myputs "timestamp is not enabled"
                        }
                        myputs "sending data -$cmd- to $process now after pattern match"
                        #send_user "[time_now]"

                        if $datasent_noreturn {
                            myputs "send without a return"
                            exp_send -i $process "$cmd"
                        } else {
                            exp_send -i $process "$cmd\r"
                        }

                        return "RETURN_EXPECT_SENDFIRST0_NORMAL"
                    }
                }
            }
            -re $pattern_more {                                      ;#{{{6}}}
                exp_send -i $process "$pattern_more_key"
                exp_continue
            }
            #-i $process -re $pattern_more {
            #    puts "$expect_out(0,string)"
            #    if $auto_paging {send " ";exp_continue}
            #}
            timeout {                                       ;#{{{6}}}
                puts "timeout after ${timeout}s without a match for -$pattern-!"
                return "RETURN_EXPECT_TIMEOUT"
            }
            eof {                                           ;#{{{6}}}
                puts "spawned process terminated!"
                return "RETURN_EXPECT_EOF"
                #exit 2
            }
            full_buffer {                                   ;#{{{6}}}
                puts2 "got full buffer!"
                #return "RETURN_EXPECT_FULL_BUFFER"
                exit 3
            }
        }
        exp_internal 0
    }

}

#proc do_pag {{{2}}}
proc do_pag {\
    router cmds_array cmd_output_array  \
    {pa_intv 0} {pattern_timeout 120} {pa_pair 1}  \
    } { 

    myputs "==>entering do_pags"
    global global_data;eval $global_data

    global action_handler
    global code_return_expect_user_interupt
    global code_return_expect_user_interupt 
    global code_return_expect_sendfirst
    global code_return_reconnect
    global code_return_retry
    global code_return_ctrlc
    global code_return_exit
    global code_return_close
    global code_return_continue

    global during_login during_cmd action_handler_evaled 
    set action_handler_evaled 0
    #return:
    #set constant(RETURN_DO_PA5_NO_PA)             121010
    #    login_info not configured
    #set constant(RETURN_DO_PA5_NORMAL)            121110
    #    all good
    #set constant(RETURN_EXPECT_CONN_CLOSED)       111211
    #    expect timeout and session need to be closed
    #set constant(RETURN_DO_PA5_SIGQUIT)           121210
    #    pressed sigquit key ctrl-\
    #

    upvar $cmds_array p_cmds_array
    upvar $cmd_output_array p_cmd_output_array

    set process host2session($router)

    myputs "start pattern-action sequence:"

    set send_initial_cr_ori $send_initial_cr
    #verify cmds array {{{3}}}
    if {[info exists p_cmds_array($router)] && \
       ![string equal $p_cmds_array($router) ""]} {
        #cmds array exists {{{4}}}
	myputs "pattern-action data for $router now looks:"
	myputs "  -$p_cmds_array($router)-"

        #TODO:REPEAT 2 10
        #seems not easy, need to supported in regex_info and issue_info
        set cmd_list $p_cmds_array($router) 
        set does_cmds_array_exist 1
    } else {
        #cmds array not exist {{{4}}}
        if {$cmds_array == "login_info"} {
            #if it's login_info, RETURN_DO_PA5_NO_PA {{{5}}}
            myputs "pattern-action data for $router doesn't exist, check config!"
            return "RETURN_DO_PA5_NO_PA"
        } elseif [info exists $cmds_array] {
            myputs "pattern-action data $cmds_array for $router\
                ${cmds_array}($router) doesn't exist as an array, but exists \
                    as a list, use [set $cmds_array] as cmd list!"
            set does_cmds_array_exist 1
            set cmd_list [set $cmds_array]
        } else {
            #if not, use it as cmd list {{{5}}}
            myputs "pattern-action data $cmds_array for $router\
                ${cmds_array}($router) doesn't exist, use $cmds_array as cmd list!"
            set does_cmds_array_exist 0
            set cmd_list $cmds_array

            #disable initial cr under this condition, this is to make sure
            #user_pattern works
            set send_initial_cr 0 
        }
    }


    #initial cr {{{3}}}
    #if {$debug==3} {send_log "[parray p_cmds_array]\n"}
    if $send_initial_cr {
        myputs "send_initial_cr set, send an initial cr"
        send -i $process "\r"
    }

    set send_initial_cr $send_initial_cr_ori

    #sigtect: SLEEP_ALL/PEND_ALL/CONT_ALL {{{3}}}
    set filename [sigdetect "SLEEP_ALL"]
    if  [regexp "SLEEP_ALL_(\d+)" $filename -> sleep_all_time] {
        myputs "forced to sleep for $sleep_all_time seconds by other instances"
        mysleep $sleep_all_time
        sigclean "SLEEP_ALL"

    } elseif [regexp "PEND_ALL" $filename] {

        #how to ?


    } elseif [regexp "CONT_ALL" $filename] {

        #how to ?

    }


    #start walk-through {{{3}}}
    #use 2 counters, to count all element, or just command -- same for
    #non-pa, diff for pa:
    #cmds1: {ifconfig uptime}
    #          ^
    #          i==1;j==1
    #cmds1: {$ ifconfig $ uptime}
    #          ^
    #          i==2;j==1

    set do_pag_return "RETURN_DO_PA5_NORMAL"
    set i 0;set j 1         
    for {set i 0} {$i<=[expr [llength $cmd_list]-1]} {incr i} {

        #pressing c-\ to stop the iteration
        if {$sigquit==1} {
            puts "SIGQUIT received,will stop the pattern-action executions!"
            return "RETURN_DO_PA5_SIGQUIT"
        }

        #set time_now [exec date +"%s"]
        set time_now [clock click -milliseconds]

        array unset p_cmd_output_array $router,$j,*

        #addclock {{{4}}}
        if {[info exists addclock] && $addclock} {
            if $debug { myputs "send a clock" }
            if [info exists clockcmd] { 
                myexpect $router ".*" "$clockcmd" $pattern_timeout 0 0
            }
        }

        #get pattern/data {{{4}}}
        if $pa_pair {
            set pattern_last    [lindex $cmd_list $i-2]	
            set pattern         [lindex $cmd_list $i]	
            set pattern_next    [lindex $cmd_list $i+2]	
            incr i
        } else {
            #if no pa_pair -> meaning just send commands and no need to wait
            #for a prompt first, presume a "common" prompt
            set pattern $pattern_common_prompt
        }
        
        #for 1st data pair, _prev is same as current
        if !$i {set pattern_prev $pattern}
        set datasent  [lindex $cmd_list $i]
        if !$i {set datasent_prev $datasent}


        #foreach pa_group $cmd_list {
        #    myputs "parsing \"$pa_group\".."
        #    global $pa_group
        #    if [info exists $pa_group] {
        #        myputs "\"$pa_group\" is nested (defined)"
        #        set nested 1
        #    } else {
        #        myputs "\"$pa_group\" is not nested (not defined)"
        #        set nested 0
        #    }
        #    break
        #}

        #if it contains sub-node, repeat this proc recursively
        global $datasent
        #nested cmd {{{4}}}
        #if the "command" happen to be also an array defined in the config,
        #then go nest. the exception is pa_pair type of array , eg.
        #"login_info" array. don't do recursion on login_info, or any other
        #pa_pair type of cmds array (match-and-send mode)
        #   && [string equal $cmds_array "login_info"]
        if { [array exists $datasent] && !$pa_pair || \
             [info exists $datasent]} {

            myputs "this pa_group \"$datasent\" is not an end 'leaf' node"
            #this is assume to define array as nested data structure
            myputs "it was defined as an array: [subst ${datasent}($router)]"
            myputs "and it contains: [subst $${datasent}($router)]"
            
            #this is buggy, no need to iterate through list elment and call
            #   do_pag for each, will cause duplicate executions
            #foreach pa_group [subst $${datasent}($router)] {
            #    myputs "get a pa_group \"$pa_group\""
            #    eval global $pa_group   ;#important:to refresh data on-the-fly
            #    myputs "call do_pag recursively..."
            #    do_pag $router $datasent cmd_output_array_pags \
            #                         $pa_intv $pattern_timeout $pa_pair
            #}
            set do_pag_return [do_pag $router $datasent cmd_output_array_pags \
                                 $pa_intv $pattern_timeout $pa_pair]
                                 

        #non-nested cmd {{{4}}}
        } else {       ;#if it's a leaf list, execute the list

            myputs "this pa_group \"$datasent\" is end 'leaf' node, will execute it..."
            #do_pag $host p_pags cmd_output_array_pags \
            #    $pa_intv $pattern_timeout $pa_pair

            #GRES {{{5}}}
            #if {$datasent == "GRES"} {}
            if {[regexp {GRES\s*(\d*)} $datasent -> interval_gres]} {
                myputs "GRES command detected!"
                if {[string equal $interval_gres ""]} {set interval_gres 300}
                set return_gres [switchover $router $interval_gres]
                set p_cmd_output_array($router,$j,$datasent,$time_now) $datasent

                if {$return_gres=="RETURN_GRES_SUCCESS" ||  \
                    $return_gres=="RETURN_GRES_FORCE_RPD" || \
                    $return_gres=="RETURN_GRES_SESSION_CLOSED" \
                } {
                    myputs "GRES succeeded"

                    #1. old method:
                    ##this seems doesn't work
                    ##catch {close $process;wait $process}
                    #send -i $process "exit\r"

                    ##expect -i $process -nocase -re "onnection.*closed.*" {}
                    #expect -i $process -nocase -re $pattern_connection_close_msg {
                    #    puts "will reconnect in ${reconnect_interval}s"
                    #    mysleep $reconnect_interval
                    #    #persist_login $login_script $router
                    #    #do_pag $login_index login_info
                    #    close;wait
                    #    spawn_login $router
                    #}
                    
                    #test: 2.new method: (2016-02-25) 
                    #this looks better and DUT independent - no need to send
                    #"exit" to device in order to trigger disconnection!
                    catch {close $process;wait $process}
                    #send -i $process "exit\r"

                    #expect -i $process -nocase -re "onnection.*closed.*" {}
                    puts "will reconnect in ${reconnect_interval}s"
                    mysleep $reconnect_interval
                    #persist_login $login_script $router
                    #do_pag $login_index login_info
                    #close;wait
                    puts "reconnecting ..."
                    spawn_login $router

                } else {
                    puts "GRES not succeeded"
                    return return_gres
                }

            } elseif [regexp {SLEEP\s*(\d+)\s*;?(.*)} $datasent -> sleeptime cmd] {
                #SLEEP {{{5}}}
                if {[string equal $sleeptime ""]} {set sleeptime 3}
                if $debug {myputs "sleep for ${sleeptime}s"}
                if $pa_pair {
                    expect -i $process -re "$pattern" {
                        mysleep $sleeptime
                        send -i $process "[info_subs2 $cmd]\r"
                    }
                } else {
                    mysleep $sleeptime
                    send -i $process "[info_subs2 $cmd]\r"
                }
                set p_cmd_output_array($router,$j,$datasent,$time_now) $datasent

            } elseif [regexp {UPGRADE (\S+)} $datasent -> rel] {
                #UPGRADE {{{5}}}
                #to be tested
                upgrade $rel
                set p_cmd_output_array($router,$j,$cmd,$time_now) $datasent
                send -i $process "exit\r"

                expect -i $process -nocase -re $pattern_connection_close_msg {
                    puts "will reconnect in ${reconnect_interval}s"
                    mysleep $reconnect_interval
                    #persist_login $login_script $router
                    #do_pag $login_index login_info
                    close;wait
                    spawn_login $router
                }

            } elseif {[regexp {SLEEP_ALL\s*(\d+)} $datasent -> sleeptime]} {
                #SLEEP_ALL X {{{5}}}

                sigraise "SLEEP_ALL_$sleeptime"

            } elseif [regexp {LOCALPRINT (.*)} $datasent -> msg] {

                puts $msg; send -i $process "\r"

            } elseif {[string equal $datasent "GOBACKGROUND"]} {
                #GOBACKGROUND {{{5}}}
                myputs "will send control chars of GOBACKGROUND if expected pattern seen"
                if $pa_pair {
                    expect -i $process -re "$pattern" {
                        myputs "pa_pair set and expected -$pattern- seen, will \
                        send interupt pattern $key_interact and then \
                        key_background $key_background"
                        send -i $process [CONST $key_interact]
                        #wait a little while for the process to go interact mode
                        sleep 1
                        
                        #send keys to move process into background
                        send -i $process [CONST $key_background]
                    }
                } else {
                    myputs "pa_pair not set, will just send key_background \
                        $key_background without expecting anything"
                    send -i $process [CONST $key_background]
                }
                set p_cmd_output_array($router,$j,$datasent,$time_now) $datasent

            } elseif {[string equal $datasent "PEND_ALL"]} {
                #PEND_ALL {{{5}}}

                sigraise "PEND_ALL"

            } elseif {[string equal $datasent "CONT_ALL"]} {
                #CONT_ALL {{{5}}}

                sigraise "CONT_ALL"

            } elseif {[string equal $datasent "USER_INPUT"]} {
                #USER_INPUT {{{5}}}
                set initoldmode [stty -raw]
                myputs "initoldmode looks $initoldmode"
                ##1. don't ask at all (current)
                #
                ##2. simply just ask about "$pattern"
                #send_user "\n<<<CRTC:please input answer to \"$pattern\":\n"
                #
                ##3. display the question in the right place, also make sure
                ##(via capture) the pattern does appear in the last line, before ask
                #expect -i $process -re "$pattern\[^\n\]*$" {
                #    send_user "\n<<<CRTC:please input answer to \"$pattern\":\n"
                #}
                #
                myputs "pattern/_next/last looks $pattern/$pattern_next/$pattern_last"
                if [regexp -nocase "sword" $pattern] {
                    myputs "current pattern looks a prompt for password, will hide input"
                    set oldmode [stty -echo]
                    myputs "oldmode $oldmode saved"
                    set ispass 1
                } else {
                    set ispass 0
                }

                if [string equal $pattern_last "$"] {
                    set pattern_last "\\\$"
                }

                #exp_internal 1
                set timeout $pattern_timeout
                if ![string equal $pattern_next ""] {
                    #if there are next pattern, check it to see if answer is
                    #right
                    expect {
                        -i $user_spawn_id 
                            -re "(\[^\n\]*)\n" {
                                myputs "you answered $expect_out(1,string)\n"
                                myputs "will send your input and exp_continue\
                                    to check the next pattern match"
                                send -i $process "$expect_out(1,string)\r"
                                if $ispass {
                                    myputs "recover old terminal mode:$oldmode"
                                    eval stty $oldmode
                                }
                                exp_continue
                            }
                        -i $process 
                            -re "$pattern" {
                                #get the same pattern back, indicating a wrong
                                #answerk
                                myputs "\nmatching current pattern\
                                    -[list $pattern]- \n"
                                myputs "will exp_continue and wait for input\n"

                                if [info exists oldmode] {eval stty $oldmode}
                                if [regexp -nocase "sword" $pattern] {
                                    myputs "this looks a prompt for password,\
                                        will hide info"
                                    set oldmode [stty -echo]
                                    myputs "oldmode $oldmode saved"
                                    set ispass 1
                                } else {
                                    set ispass 0
                                }

                                exp_continue
                            }
                            #put pattern_next before pattern_last, so in case
                            #they are the same, always assume we did it right
                            #and we are moving forward...
                            #get next pattern, indicating answer is correct
                            -notransfer -re "$pattern_next" {
                                myputs "\nmatching next pattern\
                                    -[list $pattern_next]- \n"
                                myputs "good, will go next pa-pair!\n"
                            }
                            -re "$pattern_last" {
                                #get the the last pattern back, indicating a
                                #wrong answer
                                myputs "\nmatching last pattern\
                                    -[list $pattern_last]- \n"
                                myputs "will exp_continue and wait for input\n"

                                if [info exists oldmode] {eval stty $oldmode}
                                if [regexp -nocase "sword" $pattern_last] {
                                    myputs "this looks a prompt for password,\
                                        will hide info"
                                    set oldmode [stty -echo]
                                    myputs "oldmode $oldmode saved"
                                    set ispass 1
                                } else {
                                    set ispass 0
                                }

                                exp_continue
                            }
                    }
                } else {
                    #if no next pattern anymore, no need to check next pattern
                    expect {
                        -i $user_spawn_id 
                            -re "(\[^\n\]*)\n" {
                                if $debug {
                                    myputs "you answered $expect_out(1,string)\n"
                                }
                                send -i $process "$expect_out(1,string)\r"
                            }
                    }
                }
                exp_internal 0
                eval stty $initoldmode


            } elseif [regexp {SET\s*(\S+):(.*)} "$datasent" -> settype setvalue] {
                #SETOPTION {{{5}}}
                #TODO, need to make the option change permanent

                myputs "settype:setvalue looks -$settype:$setvalue-"

                if {$settype == "OPTION"} {
                    #backup options
                    array set options_bak [array get options]

                    #execute the configured option setting statement
                    if [catch {eval $setvalue} msg] {
                        puts $msg
                    }
                    myputs "executed -$setvalue-"

                    #absorb in options
                    foreach idx [array name options] {
                        set options($idx) [set $idx]
                    }

                    #check what has been changed
                    set diff [arraycomp options_bak options]

                    myputs "these options have been changed: -$diff-"

                    #save only the diff in options_inline
                    foreach idx $diff {
                        set options_inline($idx) $options($idx)
                    }
                } elseif {$settype == "SHELL"} {
                    if [catch {exec $setvalue} msg] {
                        puts $msg
                    }
                } else {
                }

            } else {
                #normal cmds {{{5}}}

                #NOCR {{{6}}}
                if [regexp {(.*)NOCR} $datasent -> datasent] {
                    set options_inline(datasent_noreturn) 1
                    set options(datasent_noreturn) 1
                    set datasent_noreturn 1
                } else {
                    set options_inline(datasent_noreturn) 0
                    set options(datasent_noreturn) 0
                    set datasent_noreturn 0
                }

                #DECRY {{{6}}}
                if [regexp {DECRY(.*)} $datasent -> datasent] {
                    #str_polisher return a list, sometime it looks "blalba"
                    #sometime it looks {blabla}, in the later case, further
                    #abstract the element out of the list is more robust.
                    set datasent [lindex "[str_polisher "$datasent" 2]" 0]
                }

                if {$hideinfo>=2} { 
                    log_user 0
                }
                
                #myexpect in loop {{{6}}}
                #use "while" loop as a "GOTO" - from anywhere just goto
                #beginning by a "continue", until a "break" is seen.
                set retry_count 1
                while {$retry_count <= $retry_max} {
                    incr retry_count

                    #[expr {!($pa_pair==0)?"$pattern":"$pattern_common_prompt"}]
                    myputs "\[do_pags\]timeout:-$pattern_timeout-,\
                            pattern:-$pattern-, datasent:-$datasent-,\
                            pa_pair:-$pa_pair-"
                    if $does_cmds_array_exist {
                        set myexpect_return [myexpect $router $pattern     \
                            $datasent $pattern_timeout [expr !$pa_pair] 0   \
                        ]
                    } else {
                        send -i $process "$datasent\r"
                        set myexpect_return "RETURN_EXPECT_SENDFIRST1_NORMAL"
                    }
                    
                    #give a "progress" bar with hideinfo set 1
                    if {$hideinfo==1} { 
                        send_user "."
                    }

                    myputs "myexpect_return looks -$myexpect_return-"

                    #if not processed seperately, just inheritate myexpect
                    #return value
                    set do_pag_return $myexpect_return

                    #process myexpect return {{{7}}}
                    if [info exists action_handler($myexpect_return)] {
                        myputs "action defined as\
                            $action_handler($myexpect_return), eval it"

                        #parray action_handler
                        myputs "code to be eval.ed looks like" 3
                        myputs "[set $action_handler($myexpect_return)]" 3

                        #puts "myexpect_return looks $myexpect_return"
                        eval [set $action_handler($myexpect_return)]
                        #TODO: for some reason, this doesn't work
                        #the goal is to execute action chain
                        #
                        #foreach one_return $myexpect_return {
                        #    puts "one_return looks $one_return"
                        #    eval [set $action_handler($one_return)]
                        #}
                        #(2016-11-21) 
                        set action_handler_evaled 1
                        myputs "action_handler_evaled looks $action_handler_evaled"

                    } else {

                        myputs "action not defined"

                        #(2016-11-21) 
                        set action_handler_evaled 0

                        break
                    }

                }       ;#while

                #fill cmd_output_array {{{6}}}
                #set p_cmd_output_array($router,$j,$datasent,$time_now)
                #  $myexpect_return
                set p_cmd_output_array($router,$j,$datasent,$time_now) \
                    $expect_out(buffer)
            }   ;#end normal cmds
        }       ;#end non-nested cmd

        #update _prev version of the data pair, for "retry" use...
        set datasent_prev $datasent
        set pattern_prev $pattern

        incr j;mysleep $pa_intv
        
        myputs "during_login looks $during_login, $action_handler_evaled"
        if $during_login {
            #if during_login, better not to proceed the original p-a sequence
            #after reconnection, already evaled action_handler ? (2016-11-21) 
            if $action_handler_evaled {
                puts "break the original p-a =================>"
                break
            }
        }

    }           ;#end walk-through
    myputs "<==leaving do_pags"
    #return "RETURN_DO_PA5_NORMAL"    ;#all good
    return $do_pag_return
}

proc spawn_login {login_index} {   ;#{{{2}}}

    global global_data; eval $global_data
    global argc

    myputs "==> enter spawn_login now"
    set during_cmd 0
    set during_login 1

    #return:
    #actions_on_timeout: close, return
    #actions_on_timeout: none

    #spawn {{{3}}}
    #spawn -noecho $env(SHELL)

    #remove "-noecho"for debug purpose
    #if [catch "spawn $env(SHELL)" reason] {}
    #below code is trying to find a "bash" and use it to spawn
    set shell_to_spawn $env(SHELL)
    set shell_dir [file dirname $env(SHELL)]
    set shell_bash_full_path "$shell_dir/bash"
    if [file exists $shell_bash_full_path] {
        set shell_to_spawn $shell_bash_full_path
    }

    if [catch "spawn -noecho $shell_to_spawn" reason] {
        send_user "failed to spawn program: $reason\n"
        exit 1
    }

    #TODO: this needs to be fixed: crtc -h a b a, two sesson for same host...
    set host2session($login_index) $spawn_id
    set session2host($spawn_id) $login_index
    myputs "process spawned is $spawn_id"

    #calc hideinfo {{{3}}}
    if {$hideinfo>0} {
        log_user 0
    } else {
        log_user 1
    }

    log_user [expr !$hideinfo]

    #do_pag if host given{{{3}}}
    #only if host name is provided explicitly, so this is to diff between:
    #1) crtc 
    #   will just spawn a local shell regardless of cmdsN config
    #2) crtc LOCALHOST
    #   will check if cmdsN(LOCALHOST) configured, if yes then execute them
    #

    if [regexp {(.+)\.clone} $login_index -> login_index_ori] {
        puts "this looks a clone"
        set login_index $login_index_ori
    }

    if {$argc>=1} {

        #looks redundent, but necessary for reconnect_eval
        set login_info($login_index) [info_subs1 $login_info($login_index)]
        #if login_info provided, use it to login (after spawn bash)
        #otherwise, presumely use telnet to login...
        #unless "crtc LOCAL", which simply spawn a local shell
        set do_pag_return [do_pag $login_index \
                        login_info cmd_output_array_login_info \
                        $interval_cmd $timeout_login]

        #todo: there is one issue to be resolved: if the very last command command
        #timeout, it won't be detected in dpa5 - reason is, it works in p-a mode
        #for login process, so the expect_out(buffer) is still unknown by the time
        #dpa5 returned
        expect_compensation $login_index ;#{{{4}}}

        #calculate reconnnect {{{4}}}
        #set isreconnect 0
        #foreach event $reconnect_on_event {
        #    if {$do_pag_return=="$event"} {
        #        set isreconnect 1
        #    }
        #}

        #do_pag_return in reconnect_on_event? {{{5}}}
        #
        #this works, but not supported in lower tcl version (<8.1?)
        #if {$do_pag_return in $reconnect_on_event} {}
        #this works, but less "intuitive":
        #if {[lsearch $reconnect_on_event $do_pag_return]>=0} {}
        #if [in $do_pag_return $reconnect_on_event] { 

        #    myputs "do_pag_return looks $do_pag_return"
        #    myputs "reconnect_on_event set to one of \"$reconnect_on_event\""
        #    puts "will reconnect in ${reconnect_interval}s"
        #    mysleep $reconnect_interval

        #    #$process is a must, otherwise have issues
        #    close ;wait 
        #    return [spawn_login $login_index]

        ##do_pag_return in terminate_on_event? {{{5}}}
        #} elseif [in $do_pag_return $terminate_on_event] {

        #    myputs "do_pag_return looks $do_pag_return"
        #    myputs "reconnect_on_event not set, don't reconnect"
        #    myputs "terminate_on_event set to one of:"
        #    myputs "  \"$terminate_on_event\""
        #    myputs "exit"
        #    exit

        #} else {

        #    myputs "do_pag_return looks $do_pag_return"
        #    myputs "not in either terminate_on_event and reconnect_on_event \
        #            just proceed"
        #}

        #if $isreconnect {
        #    myputs "do_pag_return looks $do_pag_return"
        #    myputs "reconnect_on_event set to $reconnect_on_event, reconnect"
        #    puts "will reconnect in ${reconnect_interval}s"
        #    mysleep $reconnect_interval
        #    close;wait
        #    spawn_login $login_index
        #} elseif {[lsearch $terminate_on_event $do_pag_return]>=0} {
        #    myputs "reconnect_on_event not set, don't reconnect"
        #    myputs "terminate_on_event set to $terminate_on_event, exit"
        #    exit
        #} else {
        #}

        #do_pag return code process{{{4}}}
        #RETURN_DO_PA5_NO_PA {{{5}}}
        if {$do_pag_return=="RETURN_DO_PA5_NO_PA"} {

            if {$login_index=="LOCALHOST" || $local_task} {
                #myreturn "RETURN_SPAWN_LOGIN_LOCALSHELL" "spawn_login"
                return "RETURN_SPAWN_LOGIN_LOCALSHELL"

            } else {
                puts "\nprocess \"$login_index\" not defined in config file:"
                puts "current config file in use is: \"$config_file\"!"

                puts "FYI a \"grep\" in above config file return this:"
                puts -nonewline "\n\"\n  "

                #this doesn't work well when grep got nothing and got this error:
                #  "child process exited abnormally while executing
                #    system grep $login_index $config_file"
                #this is because: 
                #  "exec returns an error if the command returns
                #    non-zero or if it sends anything to stderr"
                #same to system as with exec, 
                #solution is to simply "catch" it, this will suppress the error
                #catch [system grep $login_index $config_file]
                catch {system grep $login_index $config_file}
                puts "\n\"\n"

                puts "This is most probably caused by one of below reasons:"
                puts "1.the session was not configured in the above config file"
                puts "2.a suffix name (ex.\"$login_index@jtac\") is missing"
                puts "3.typo of session name: \"$login_index\"\n"
                puts "to confirm, exit and check config file"

                puts "or, select from below options:"
                puts "  C)heck: check config files"
                puts "  f)tp: connect with ftp"
                puts "  r)sh: connect with rsh"
                puts "  t)elnet: connect with telnet"
                puts "  s)sh: connect with ssh"
                puts "  q)uit: quit (exit) this script"
                
                mycatch "stty raw"

                set timeout 10000
                expect_user {
                    -re "C" {
                        puts "edit config file";system vim $config_file
                    }
                    -re "t" {
                        send_user "elnet ..."
                        set spawn_id [persist_login1 telnet $login_index]
                        puts "spawn_id looks $spawn_id"
                    }
                    -re "s" {
                        send_user "sh ..."
                        set spawn_id [persist_login1 ssh $login_index]
                    }
                    -re "r" {
                        send_user "sh ..."
                        set spawn_id [persist_login1 rsh $login_index]
                    }
                    -re "f" {
                        send_user "ftp ..."
                        set spawn_id [persist_login1 ftp $login_index]
                    }
                    -re "q" {
                        send_user "uit!";exit
                    }
                }

                #if login failed, recurse and user will be given another chance to
                #select other options from the menu
                if {$spawn_id == 0} {
                    spawn_login $login_index
                    mysleep 5
                }

                #calculate reconnect {{{6}}}
                #these were copied from exec_cmds
                myputs "start to calculate reconnect"
                #set isreconnect 0
                #foreach event $reconnect_on_event {
                #    if $do_pag_return=="$event" {
                #        set isreconnect 1
                #        myputs "isreconnect set to $isreconnect:$do_pag_return"
                #    }
                #}


                #this "in" syntax seems not supported in expect 5.43
                #if {$do_pag_return in $reconnect_on_event} {}
                #if {[lsearch $reconnect_on_event $do_pag_return]>=0} {

                #    myputs "do_pag_return looks $do_pag_return"
                #    myputs "reconnect_on_event set to $reconnect_on_event, reconnect"
                #    puts "will reconnect in ${reconnect_interval}s"
                #    mysleep $reconnect_interval

                #    #$process is a must, other wise have issues
                #    #but this now report an error:
                #    # can not find channel named "exp5"
                #    #close $process;wait $process

                #    close ;wait 
                #    spawn_login $login_index

                #} elseif {[lsearch $terminate_on_event $do_pag_return]>=0} {

                #    myputs "reconnect_on_event not set, don't reconnect"
                #    myputs "terminate_on_event set to one of:"
                #    myputs "  \"$terminate_on_event\""
                #    myputs "exit"
                #    exit

                #} elseif {$do_pag_return eq "RECONNECT"} {

                #    myputs "do_pag_return looks $do_pag_return"
                #    puts "regardless of reconnect_on_event ... \
                #        will just reconnect in ${reconnect_interval}s"
                #    mysleep $reconnect_interval

                #    #$process is a must, other wise have issues
                #    #but this now report an error:
                #    # can not find channel named "exp5"
                #    #close $process;wait $process

                #    close ;wait 
                #    spawn_login $login_index

                #} else {

                #    myputs "none of terminate_on_event and reconnect_on_event set\
                #            ,and do_pag_return code is not RECONNECT,so just proceed"
                #}

            }

        #RETURN_DO_PA5_NORMAL {{{5}}}
        } elseif {$do_pag_return=="RETURN_DO_PA5_NORMAL"} {
            #everything good, continue in the loop

        } else {

            #stop looping,return the orignial code to process
            return $do_pag_return 

        }

    } else {    ;#{{{3}}}

        return "RETURN_SPAWN_LOGIN_LOCALSHELL"

    }

    return "RETURN_SPAWN_LOGIN_NORMAL"
}


proc exec_cmds {login_index {cmds "cmds1"}} {  ;#{{{2}}}

    myputs "\n"
    myputs "==> enter exec_cmds now"
    #pending issue:  {{{3}}}
    #hard to set return values -- there are multiple cmd groups
    #executed, can't just return based on 1 group ..

    global global_data; eval $global_data 
    global $cmds cmd_output_array_$cmds cmd_output_array_${cmds}_prev
    global cmd_output_array_post_$cmds cmd_output_array_pre_$cmds
    global active_monitor pa_pair

    set process $host2session($login_index)
    set during_cmd 1
    set during_login 0

    proc list_cmds {cmds_group_name login_index} {      ;#{{{3}}}
        global global_data; eval $global_data
        upvar $cmds_group_name p_cmds_gn

        #puts [format "| %*d | %*ld |" $w1 $i $w2 $p]
        set ii 0
        foreach cmd $p_cmds_gn($login_index) {
            #send_user "<<<<  $cmd\n"
            myputs2 "<<<<  $cmd\n"
            incr ii
            if {$ii > 5} {myputs2 "<<<<   ...";break}
        }
        puts ""
    }


    #calculate pa_pair {{{3}}}
    set is_special_char_in_cmd 0
    set is_expect [info exists options_cli(expect)]
    if [info exists ${cmds}($login_index)] {
        #to support nested on array
        set cmds_list ${cmds}($login_index)
        foreach cmd [set ${cmds}($login_index)] { 
            #if any cmd contains special CH as the last CH
            #treat it as a pattern(prompt)
            if [regexp "(#|>|%|\\\$)$" $cmd] {set is_special_char_in_cmd 1} 
        }
    } elseif [info exists $cmds] {
        #to support nested on list
        set cmds_list [set $cmds]
        foreach cmd $cmds_list { 
            #if any cmd contains special CH as the last CH
            #treat it as a pattern(prompt)
            if [regexp "(#|>|%|\\\$)$" $cmd] {set is_special_char_in_cmd 1} 
        }
    } else {
        set cmds_list $cmds
        myputs "<<<CRTC: $cmds_list does not exist!"
    }

    if {$is_expect ==1 ||\
        $is_special_char_in_cmd && $treat_special_char_as_pa\
    } {
        set pa_pair 1
    } else {
        set pa_pair 0
    }
    myputs "pa_pair set $pa_pair!"

    #if cmds contains pa pair instead of just command, but -e not in use, sth
    #will go wrong
    if [expr [info exists options_cli(expect)] ^ $pa_pair] {
        puts "<<<warning: -e not in use but pa_pair set, check cmds array in\
        case sth goes wrong!"
    }

    #calc hideinfo {{{3}}}
    if {$hideinfo<2} {
        log_user 1
    } else {
        log_user 0
    }


    #calc interval_cmds/min/max {{{3}}}
    set interval_cmds_min $options(interval_cmds)
    set interval_cmds_max $options(interval_cmds)
    set options_inline(interval_cmds_min) $interval_cmds_min
    set options_inline(interval_cmds_max) $interval_cmds_max

    if {[info exists options_cli(interval_cmds)]} {
        set interval_cmds_min [lindex $options_cli(interval_cmds) 0]
        set options(interval_cmds_min) $interval_cmds_min
        set options_cli(interval_cmds_min) $interval_cmds_min

        if {[llength $options_cli(interval_cmds)] > 1} {
            set interval_cmds_max [lindex $options_cli(interval_cmds) 1]
            set options_cli(interval_cmds_max) $interval_cmds_max
            set options(interval_cmds_max) $interval_cmds_max
        } else {
            set interval_cmds_max [lindex $options_cli(interval_cmds) 0]
            set options_cli(interval_cmds_max) $interval_cmds_max
            set options(interval_cmds_max) $interval_cmds_max
        }
    } else {
    }

    #proc for do_pag return values {{{3}}}
    #process return values from do_pag
    #this is currently almost do nothing and effectively deprecated
    #
    proc do_pag_return_processing_code {do_pag_return} {
        #need to refer the upper stack frame var "process", but don't want to 
        #bother another global var, not tested yet
        global host2session login_index
        set process $host2session($login_index)
        #upvar process session1
        #upvar controlC controlC1

        
        if {$do_pag_return=="RETURN_DO_PA5_NO_PA"} {

            #puts "command group not defined!"
            #exit

        } elseif {$do_pag_return=="RETURN_EXPECT_TIMEOUT"} {


        } elseif {$do_pag_return=="RETURN_DO_PA5_NORMAL"} {

        } else {

        }
    }

    #calc active_monitor {{{3}}}
    #if $issue_monitor {}
    #myputs "enter \"issue monitor\" mode since issue_monitor set"

    #diff between 2 conditions:
    #   1. blind monitor: just send commands, don't "look at"
    #      returned values  => not active_monitor
    #   2. active monitor: send commands and "look into" the returned
    #   value to calculate the issues => active_monitor
    #
    #TODO: seems no need to check issue_info, regex_info is enough?
    if {![string equal $regex_info($login_index) ""] ||       \
        ![string equal $issue_info($login_index) ""]} {
        #use set one of regex_info and issue_info, meaning not only
        #crtc need to send command blindly, but also need to
        #calculate the issues. this is not "send only", and so
        #better to print more messages about the calculation process
        set active_monitor 1
        myputs2 "<<<CRTC:either regex_info or issue_info not empty, \
            active_monitor set"
    } else {
        #none of regex_info and issue_info defined, indicating user
        #just want to "blindly" send commands
        if $verbose {
            myputs2 "both regex_info or issue_info are empty, \
            not active_monitor"
        }
        set active_monitor 0
    }


    #action processing code {{{3}}}
    #resolving and processing configured actions, when issue hit or not hit
    set actions_code {             
        if $active_monitor {
            myputs2 "<<<< actions_on_event is:$actions_on_event"
        }
        if [string equal $actions_on_event ""] {
            myputs2 "\n<<<< no action configured.\n\n"
        }
        foreach action $actions_on_event {

            #myputs "get an action $action from actions list $actions_on_event"
            if ![string equal $action ""] {
                if $active_monitor {
                    myputs2 "\n<<<< next action configured as :$action\n"
                }
            } 

            if [regexp {EXEC_(\w+)} $action -> cmds_group] {

                #run EXEC_CMDGROUP {{{4}}}
                #run the embeded cmdgroup if given
                if ![string equal $cmds_group ""] {

                    #calc num of cmd arr {{{5}}}
                    #these code will be inserted literally when eval.ed, so be
                    #careful about vars confliction within the calling code
                    set cmds_array_num 0
                    for {set ij 1} {$ij<=10} {incr ij 1} {
                        global $cmds_group$ij
                        if [info exists $cmds_group${ij}($login_index)] {
                            incr cmds_array_num
                        }
                    }

                    #"groupN" if defined {{{5}}}
                    if $cmds_array_num {
                        myputs2 "<<<< and $cmds_array_num $cmds_group\"N\" \
                            defined, will alternate among them..\n\n"

                        #myputs "$cmds_array_num \"${cmds_group}N\" arrays were \
                        #    defined, will execute one of them in each iteration"

                        if $alternate_on_hit {
                            set k [expr $hit % $cmds_array_num]
                        } else {
                            set k [expr $i % $cmds_array_num]
                        }

                        if !$k {set k $cmds_array_num}

                        set do_pag_return [do_pag $login_index \
                            $cmds_group$k cmd_output_array_$cmds_group \
                            $interval_cmd $timeout_cmd $pa_pair]

                        #send_routers test$k
                        #outputs_parser test$k

                    } else {

                        if $active_monitor {
                            myputs2 "\n<<<< and $cmds_group\"N\" not\
                            defined, will just execute $cmds_group (if defined)\n"
                        }

                        #"group" otherwise{{{5}}}
                        #myputs "no \"${cmds_group}N\" arrays defined, \
                        #    will execute just $cmds_group array in each round"

                        set do_pag_return [do_pag $login_index \
                            $cmds_group cmd_output_array_$cmds_group \
                            $interval_cmd $timeout_cmd $pa_pair]

                    }

                    do_pag_return_processing_code $do_pag_return

                } else {
                    puts "cmds group not provided in \"EXEC_\" action"

                }

            } elseif [string equal $action "EMAIL"] {
                #EMAIL {{{4}}}

                #overide the "email_on_event" setting
                #if {"EMAIL_ON_HIT" in $email_on_event} {}
                
                myputs2 "\n<<<<issue hit the ${hit}th time!"
                myputs2 "\n<<<<post an email..."
                if [info exists emailto] {
                    postanemail $emailto $emailsub $emailbody
                } else {
                    myputs2 "\n<<<<email destination was not provided"
                }

                #else {

                #    puts "action \"EMAIL\" configured but\
                #         \"EMAIL_ON_HIT\" not set, conflicting!"

                #}
            } elseif [string equal $action "EMAIL_MAX"] {
                #EMAIL_MAX {{{4}}}

                if {$hit==$max_hits} {
                    myputs2 "\n<<<<issue hit max number ($max_hits) times!"
                    myputs2 "\n<<<<post an email..."

                    if [info exists emailto] {
                        postanemail $emailto $emailsub $emailbody
                    } else {
                        myputs2 "\n<<<<email destination was not provided"
                    }

                } else {
                    myputs2 "<<<<issue hit just $hit times (<$max_hits), \
                        won't send email yet!"
                }
                

            } elseif [string equal $action "EXIT_MAX"] {
                #EXIT_MAX {{{4}}}
                if {$hit==$max_hits} {
                    puts "<<<<issue hit max number ($max_hits) times! exit"
                    exit 8
                } else {
                    puts "<<<<issue hit $hit times (<$max_hits), continue!"
                }
                
            } elseif [string equal $action "EXIT"] {
                #EXIT {{{4}}}
                puts "exit!"
                exit

            } elseif [string equal $action "EXIT_ALL"] {
                #EXIT_ALL {{{4}}}
                puts "raise a STOP signal!"
                sigraise STOP
            }
        }
    }

    #sigclean "STOP"

    #pre_cmds group {{{3}}}
    if {[info exists pre_${cmds}($login_index)] && \
       ![string equal [set pre_${cmds}($login_index)] ""]} {

        set do_pag_return [do_pag $login_index \
                        pre_$cmds cmd_output_array_pre_$cmds \
                        $interval_cmd $timeout_cmd $pa_pair]
        do_pag_return_processing_code $do_pag_return
        myputs "done pre_$cmds"
    } else {
        myputs "no pre_$cmds"
    }


    #loop cmds groups {{{3}}}
    #   only if cmds1(router) is not empty
    if [string equal $cmds_list  ""] {
            myputs "no $cmds!"
    } else {

        #calc baseline{{{4}}}
        #  only if issue definition (issue_info) contains sth like pps"_prev"
        #  this looks buggy, need improve
        set exist_prev 0
        if [info exists issue_info($login_index)] {
            foreach issue_each $issue_info($login_index) {
            #if [info exists options_cli(regex_vars)] {}
                if [regexp "_prev" $issue_each] {
                    set exist_prev 1
                }
            }
            if $exist_prev {
                send_user "<<<< issue definition involves comparision\n"
                send_user "<<<< get a baseline of cmd outputs\n"
                set do_pag_return [do_pag $login_index \
                    $cmds cmd_output_array_${cmds}_prev \
                    $interval_cmd $timeout_cmd $pa_pair]

                do_pag_return_processing_code $do_pag_return
            } else {
                myputs "no comparision in issue definition, no need baseline"
                array set cmd_output_array_${cmds}_prev \
                    [array get cmd_output_array_$cmds]
            }
        }

        #formal iterations {{{4}}}
        myputs2 "\n<<<< start the iterations ($max_rounds rounds)\n"
        set hit 0
        for {set i 1} {$i<=$max_rounds} {incr i 1} {

            #calc sig STOP {{{5}}}
            if {[sigdetect "STOP"] != 0} {

            } else {

                puts "STOP signal found, will exit!"
                sigclean "STOP"
                exit

            }


            if $sigquit {puts "will stop cmds iterations!";break}

            if ![info exists options_cli(expect)] {
                if {$max_rounds > 1} {
                    if {$hideinfo<3} {
                        if $active_monitor {
                            myputs2 "\n\n[string repeat "- " 10]\
                                        iteration:${i} (hit $hit)\
                                        [string repeat "- " 10]\n"
                            myputs2 "\n\n<<<<\[iteration:${i}(hit $hit)\]=>\
                                $login_index:\n"
                        } else {
                            myputs2 "\n\n[string repeat "- " 10]\
                                        iteration:${i} \
                                        [string repeat "- " 10]\n"
                            myputs2 "\n\n<<<<\[iteration:${i}\]=>\
                                $login_index:\n"
                        }
                        list_cmds $cmds $login_index
                    }
                }
            }

            #do_pag {{{5}}}
            #myputs "============>do_pag"
            set do_pag_return [do_pag $login_index \
                            $cmds cmd_output_array_$cmds \
                            $interval_cmd $timeout_cmd $pa_pair]

            #if no "prev" appeard, so no baseline was taken, then _prev DB is
            #empty, so "does_match1" won't match, making the 1st iteration
            #always fail
            if !$exist_prev {
                array set cmd_output_array_${cmds}_prev \
                    [array get cmd_output_array_$cmds]
            }

            myputs "start to calculate reconnect"
            #set isreconnect 0
            #foreach event $reconnect_on_event {
            #    if $do_pag_return=="$event" {
            #        set isreconnect 1
            #        myputs "isreconnect set to $isreconnect:$do_pag_return"
            #    }
            #}

            myputs "do_pag_return looks $do_pag_return"

            do_pag_return_processing_code $do_pag_return

            if {$debug>=3} {
                if [array exists $cmds] {
                    puts "cmd_output_array_cmds data structure \
                        (and the _prev version) now looks:"
                    parray cmd_output_array_$cmds
                    parray cmd_output_array_${cmds}_prev
                }
            }

            #verbose info in iteration {{{5}}}
            if $verbose {
                if [info exists options_cli(expect)] {
                    if {$max_rounds > 1} {
                        if {$hideinfo<3} {
                            myputs2 "\n[string repeat "- " 20]\n"
                            if $active_monitor {
                                myputs2 "\n\n<<<<\[iteration:${i}(hit $hit)\]=>\
                                    $login_index:\n"
                            } else {
                                myputs2 "\n\n<<<<\[iteration:${i}\]=>\
                                    $login_index:\n"
                            }
                            list_cmds $cmds $login_index
                        }
                    }
                }
            }

            #active_monitor {{{5}}}
            if $active_monitor {
                myputs2 "\n<<<CRTC:parsing data to detect issue now...\n"

                #send_tty "\n[string repeat "_" 30]\n"

                if $all_met {
                    myputs2 "<<<CRTC:all_met set:indicate a problem\
                        only if all commands got hit"
                } else {
                    myputs2 "<<<CRTC:all_met not set: hit on any single command\
                        will indicate a problem"
                }

                #actions on hit {{{6}}}
                #TODO: only call check_flag when regex_info or issue_info defined

                if {[check_flag $cmds $flag_check_method]} {
                    incr hit

                    if {$hideinfo<3} {
                        if $active_monitor {
                            myputs2 "\n<<<< overall:monitored condition detected \
                                ($hit time(s))\007!"
                            #send_tty "\n|[string repeat "_" 40]\n"
                        }
                    }

                    #raise STOP flag
                    #sigraise "STOP"

                    set actions_on_event $actions_on_hit
                    if $active_monitor {
                        myputs2 "\n<<<< parsing actions_on_hit:\n"
                    }

                } else {

                    #actions on not hit {{{6}}}

                    if {$hideinfo<3} {
                        if $active_monitor {
                            myputs2 "\n<<<< overall:monitored condition NOT detected!"
                            #send_tty "\n|[string repeat "_" 29]\n"
                        }
                    }

                    set actions_on_event $actions_on_nohit
                    if $active_monitor {
                    myputs2 "\n<<<< parsing actions_on_nohit:\n"
                    #send_tty "\n*****************************\n"
                    }
                }

                eval $actions_code 
            #non-active_monitor {{{5}}}
            } else {
                myputs "not in issue-monitoring mode!"
            }

            #reload data if needed {{{5}}}
            if $reload_conf_inloop {
                myputs "reload_conf_inloop set $reload_conf_inloop, now reload_data"
                reload_data $login_index
            }

            #inter-cmds-mysleep {{{5}}}
            #set mysleep_return [mysleep $interval_cmds]
            set mysleep_return [mysleep \
                [random $interval_cmds_min $interval_cmds_max]\
            ]

            if {$mysleep_return==[CONST RETURN_SLEEP_CONTINUE]} {
                continue
            } elseif {$mysleep_return==[CONST RETURN_SLEEP_BREAK]} {
                #comment this out after adding interupt handling
                #(go myinteract) in mysleep
                #puts " - you just stopped the automation!"
                #return
                #
                #if cmdsN is pa_pair, need to compensate a return before
                #continue to next iteration, this is because the myinteract
                #added in mysleep will effectively consume all previous cli
                #output, making the next myexpect (pa_pair) wait forever...
                if $pa_pair {
                    exp_send -i $process "\r"
                }
            }
        }
        myputs "done $cmds"
    } 

    #post-commands {{{3}}}
    if {[info exists post_${cmds}($login_index)] && \
       ![string equal [set post_${cmds}($login_index)] ""]} {

        set do_pag_return [do_pag $login_index \
                        post_${cmds} cmd_output_array_post_$cmds \
                        $interval_cmd $timeout_cmd $pa_pair]
        do_pag_return_processing_code $do_pag_return
        myputs "done post_$cmds"
    } else {
        myputs "no post_$cmds"
    }

    set timeout 2
    expect -i $process -re ".+" exp_continue

    myputs "<== leaving exec_cmds now"
    myputs "\n"
}

proc exec_cmds2 {login_index {cmds "cmds1"}} {  ;#{{{2}}}
    
    global global_data; eval $global_data 
    global code_update_template

    myputs "\n"
    myputs "==>enter exec_cmds2 now"
    set during_cmd 1
    set during_login 0

    #check auto_resolve
    #  if set, add more features

    #no auto_resolve => same as exec_cmds {{{3}}}
    if !$auto_resolve {
        exec_cmds $login_index $cmds
    } else {
        #auto_resolve feature {{{3}}}
        myputs "auto_resolve set"

        #backup regex_info and issue_info
        array set regex_info_backup [array get regex_info]
        array set issue_info_backup [array get issue_info]

        #split cmds1 to single cmd 
        #  create global arrays: ${cmds}_1 to N
        #  save each cmd to each array
        #
        #iterate and 
        #  call exec_cmds1 with each single-cmd-array
        #  examine vars in each cmd, 
        #   if not existing, execute as normal
        #   if existing, resolve and substitue, then execute
        #
        
        #use cmds101~200 for this auto_resolve feature
        #assuming no more than 100 cmds to resolve!
        set i 101
        set j 1

        #this also works
        #foreach a_cmd [subst $[set cmds]($login_index)] {}
        set cmd_group [set ${cmds}($login_index)]
        foreach a_cmd $cmd_group {
            #a_cmd == show ospf neighbor  
            #  10.192.3.202     ae0.0     Full      192.168.0.8      128    38
            #a_cmd == show interfaces $int
            
            #scan a_cmd, then substitute vars {{{4}}}
            myputs "get a cmd \"$a_cmd\"" 1
            regsub -all {%} $a_cmd "$" a_cmd
            myputs "scan and substitute to \"$a_cmd\"" 1
            set a_cmd_resolved [subst $a_cmd]
            #now: 
            #a_cmd_resolved == "show interfaces ae0.0"
            
            #create a new cmds array{{{4}}}
            #set cmds101(myrouter) "show interface ae0.0"
            set cmds${i}_resolve($login_index) [list $a_cmd_resolved]

            myputs "built an array cmds${i}_resolve: \
                [set [subst cmds${i}_resolve]($login_index)]" 1
            puts ""
            #parray cmds$i

            #create a new regex array {{{4}}}
            #
            #check if regex_info contains current cmd, if yes, need to rewrite
            #the cmd number, and based on it to compose a new regex_info
            # - "regex_info_resolve"
            set has_regex 0
            foreach regex4onecmd $regex_info_backup($login_index) {
                myputs "get a regex \"$regex4onecmd\"" 1
                set regex_vars_list [split $regex4onecmd "@"]
                set cmd_num [lindex $regex_vars_list 0]
                set line_num [lindex $regex_vars_list 1]
                set regex [lindex $regex_vars_list 2]
                set the_vars [lrange $regex_vars_list 3 end]
                if {$cmd_num==$j} {
                    #this tcl "join" is tricky:
                    #this won't work sometime
                    #set regex_info_resolve($login_index) \
                    #    [join [list "1" $line_num $regex $the_vars] "@"]
                    set regex_info_resolve($login_index) \
                        [list [join [list "1" $line_num $regex $the_vars] "@"]]
                    myputs "it's for current cmd $j"
                    myputs "generated a new regex_info_resolve:\
                        -$regex_info_resolve($login_index)-" 1
                    #reload data to update regex_info
                    reload_data $login_index
                    #update code_template per regex_info
                    uplevel {eval $code_update_template}
                    set has_regex 1
                    break
                }
                myputs "but it's for cmd $cmd_num, not for current cmd $j"
            }

            #if no regex defined for this cmd, set resolve array empty, so it
            #will set regex_info empty on reload
            if !$has_regex {
                myputs "clear regex_info data" 0
                set regex_info_resolve($login_index) ""
                reload_data $login_index
                uplevel {eval $code_update_template}
                #unset regex_info($login_index)
            }

            #create a new issue array {{{4}}}
            #check if issue_info contains current cmd, if yes, need to rewrite
            #the cmd number, and based on it to compose a new issue_info array
            # - "issue_info_resolve"
            set has_issue 0
            foreach issue4onecmd $issue_info_backup($login_index) {
                myputs "get an issue \"$issue4onecmd\"" 0
                set issue_vars_list [split $issue4onecmd "@"]
                set cmd_num [lindex $issue_vars_list 0]
                if {$cmd_num==$j} {
                    set issue_info_resolve($login_index) \
                        [string replace $issue4onecmd 0 0 1]
                    myputs "it's for current cmd $j"
                    myputs "generated a new issue_info_resolve:\
                        -$issue_info_resolve($login_index)-" 1
                    reload_data $login_index
                    uplevel {eval $code_update_template}
                    set has_issue 1
                    break
                }
                myputs "but it's for cmd $cmd_num, not for current cmd $j"
            }

            #if no issue defined for this cmd, 
            if !$has_issue {
                myputs "no issue defined for this cmd"
                myputs "clear issue_info_resolve data" 0
                set issue_info_resolve($login_index) ""
                reload_data $login_index
                uplevel {eval $code_update_template}
                #unset regex_info($login_index)
            }

            #set regex_vars_list [split {1@@Count: (\d+) lines@line1} "@"]
            #call exec_cmds {{{4}}}
            
            #reload data to update cmds$i
            reload_data $login_index
            exec_cmds $login_index cmds$i

            #to use those vars captured in regex_info
            #this has to be announce "after" exec_cmds->check_flag->global vars
            global vars
            foreach avar $vars {global $avar}

            incr i
            incr j

        }

    }

    myputs "<==leaving exec_cmds2 now"
    myputs "\n"
}


proc myinteract {router} {    ;#{{{2}}}

    global global_data; eval $global_data
    global anti_idle_timeout_user_input_ori
    global anti_idle_timeout_proc_input_ori
    global myinteract_user_output_patterns
    global myinteract_process_input_patterns_static
    global myinteract_kibitz_input_patterns
    global code_myinteract_user_patterns env

    global myinteract_user_input_patterns
    global interact_a interact_b interact_l interact_any 
    global interact_v interact_multi_session
    global interact_timeout interact_n

    global process_output process_input 
    global kibitz_list kibitz_list_ori
    global kibitz_shell_prompt kibitz_user shell_list
    global inkibitz kibitz_user_list 
    global sid2user sid2typing ownertyping
    global argc select_host

    set kibitz_shell_prompt $pattern_no_match
    set kibitz_list ""
    set kibitz_list_ori ""
    set kibitz_user_list "$env(USER)"
    set inkibitz 0
    set ownertyping 1
    set timedout 0
    foreach asid [array name sid2typing] {
        set sid2typing($asid]) 0
    }

    #backup
    set myinteract_process_input_patterns_static_ori \
        $myinteract_process_input_patterns_static

    #global tcl_interactive

    #init new full name as same with default log file name, only if not set
    #ever
    if ![info exists log_fullname_cur] {
        set log_fullname_cur $log_fullname
    }

    #puts "pattern_more looks $pattern_more when entering myinteract"

    set is_respawn 0
    set totimestamp 0;set is_usertyping 0;
    set cmd_input "";set buf_in ""
    set cmd_output "";set buf_out ""
    set didsave 0; set does_holdsession 0; set currenthost ""
    set command ""
    set kibitz_list ""
    set select_host 1

    if ![file exists $download_folder] {
    } else {
        set download_folder "/var/tmp"
    }

    #set eventmonitor 0
    if [info exists cmds_cli($router)] {
        set commandgroup "cmds_cli"
    } elseif [info exists cmds3($router)] {
        set commandgroup "cmds3"
    } else {
    }

    set anti_idle_timeout_user_input_ori $anti_idle_timeout_user_input
    set anti_idle_timeout_proc_input_ori $anti_idle_timeout_proc_input

    set kibitz 0

    #backup original features
    set features_ori                    $features
    set enable_user_patterns_ori        $enable_user_patterns

    set process $host2session($router)
    if $send_initial_cr {
        myputs "send_initial_cr set, sent an intial cr"
        send -i $process "\r"
    }


    switch -exact -- $features {
        0       {
            set simple_interact 1
        } 
        default {
            set simple_interact 0
            #set enable_user_patterns 3
        }
    }

    #greeting message{{{3}}}
    #puts may not work well here because of the potential raw mode invoked by
    #interact, send_user handle that. P345.
    #put this outside of loop, making it just one time display, otherwise
    #annoying
    if !$simple_interact {
        if {$log_when == 0} {
            set log_fullname "no logging     "
        }
        if $tips_on_login {
            myputs3 "full feature interact:\n"
            myputs3 "\n<<<_____________________________________________________________\n"
            myputs3 "<<<|log file: $log_fullname, !$key_background to move crtc bg   |\n"
            myputs3 "<<<|!t toggle local timestamp,       !l log related cmd        |\n"
            myputs3 "<<<|!c to iterate cmd(s)             !f to start file transfer |\n"
            myputs3 "<<<|!p to enable persistent mode     !A to enable autopaging   |\n"
            myputs3 "<<<|!h print all cli options,        !Q to exit crtc,          |\n"
            myputs3 "<<<|!i for a tutor doc (todo),       !? to list inline options |\n"
            myputs3 "<<<|___________________________________________________________|\n"
        }
        #for nested crtc
        myputs3 "<<<$login_succeed_signature\n"
    } else {
        if $tips_on_login {
            #press !q will escape from previous feature-rich interact, and come
            #in this simplest interact
            myputs3 "simple interact:\n"
            myputs3 "press !N to equip crtc with more features\n"
            myputs3 "!q to exit; !? for list of cmds supported\n"
        }
        #for nested crtc
        myputs3 "<<<$login_succeed_signature\n"
    }

    #calc hideinfo {{{3}}}
    #if {$hideinfo<2} {
    #    log_user 1
    #} else {
    #    log_user 0
    #}
    
    #myputs "pattern_more looks $pattern_more when entering while loop"
    #below codes were used to "detect" if a spawn_id is active
    #packet capture shows this below code caused an potential issue:
    #  sending a "null" means send 1 byte data to the remote device:
    #               Dec Hex   
    #                 0 00 NUL
    #so if user drop into interact mode when the automation was interupted
    #(e.g. by hitting an enter during the initial login procedure), without
    #first erase this "nul" and user just enter login / password, this will
    #fail the authentication...
    #
    #if {[catch {send -i $process -null} err]} {
    #    myputs "process does not exist anymore!"
    #    if $debug {interpreter}
    #    exit 12
    #}

    #calculate in/out process {{{3}}}
    set process_input $host2session($router)
    set process_output $host2session($router)

    #if ![string equal $kibitz_list ""] {
    #    puts "append a new kibitz_list $kibitz_list..."
    #    lappend process_input $kibitz_list
    #    lappend process_output $kibitz_list
    #} 

    if {$parallel==0} {

    } elseif {$parallel==1} {

        set process_input $host2session($router)
        set process_output [arrayvalue host2session]

    } else {

        set process_input [arrayvalue host2session]
        set process_output [arrayvalue host2session]

        if $is_usertyping {
            set process_input $host2session($router)
        } else {
            if $does_holdsession {
                set process_input $interact_out(spawn_id)
            } else {
                set process_input [arrayvalue host2session]
            }
        }

    } 

    while 1 {           ;#{{{3}}}


        #if $kibitz {
        #    set process_input "$process_input $userin"
        #    set process_output "$process_output $userout"
        #    set kibitz 0
        #}

        #for debugging
        #set myputs_interact_out_0_string {myputs "you typed $interact_out(0,string)"}

        #build dynamic myinteract_process_input_user_patterns {{{4}}}
        #
        #this structure is dynamically generated by combination of info
        #taken from:
        #1. user_patterns array
        #2. eventscript array
        eval $code_myinteract_user_patterns

        #enable_user_patterns 0 //turn off user_patterns for both expect/interact
        #enable_user_patterns 1 //turn on for myexpect only
        #enable_user_patterns 2 //turn on for myinteract only
        #enable_user_patterns 3 //turn on for both
        #
        #if {!$enable_user_patterns || $enable_user_patterns==1} {
        #    set myinteract_process_input_user_patterns ""
        #} else  {
        #    #without this, there will be a VERY TRICKY issue, see doc
        #    set myinteract_process_input_patterns_static ""
        #}

        if {$enable_user_patterns >= 2} {
            #ignore the "static" patterns when dynamic patterns were used
            #without this, there will be a VERY TRICKY issue, see doc
            myputs "enable_user_patterns > 1, ignore static myinteract" 
            set myinteract_process_input_patterns_static ""
        } else {
            #ignore "dynamic" patterns for interact, when user_pattern applies
            #to expect only(1) or none(0)
            myputs "enable_user_patterns < 2, ignore dynamic myinteract"
            set myinteract_process_input_user_patterns ""
            set myinteract_process_input_patterns_misc ""
            set myinteract_process_input_patterns_static \
                $myinteract_process_input_patterns_static_ori
        }

        #double_echo (obsoleted) {{{4}}}
        #to generate an extra echo for all chars sent to
        #process also to local terminal, used when script redirected to
        #other folks(terminal) during troubleshooting collabration
        #
        #IMPORTANT: reason to implement in user_output_patterns("-output
        #$user_sapawn_id"): this is to make pattern ".+" to be seperated with
        #other patterns in -input $process_input.
        #otherwise may defeat eventscript - ".+" will be matched before any
        #other patterns got matched!
        #
        #(2016-05-16) seems no need...:
        #1. vim router.log displays the raw file (including all control chars)
        #2. but tail -f router.log looks clean and has the exact same effect!
        #
        #double_echo is no use at all and just for testing purpose
        #
        #pattern matching under -output seems working only under 5.45, 
        #seems not under 5.44, also not supported per expect book
        set myinteract_user_output_patterns ""
        if $double_echo {
            append myinteract_user_output_patterns [subst -nocommands {
                -nobuffer -re ".+" {
                    send_tty -- "[set interact_out(0,string)]"
                    #send_user -- "-[set interact_out(0,string)]-"
                }
            }]
        } else {
            set myinteract_user_output_patterns ""
        }
        #set dest_tty "/dev/ttyp1"
        #
        #if ![string equal $dest_tty ""] {
        #    set myinteract_user_output_patterns [subst -nocommands {
        #        -nobuffer -re ".+" {
        #            #exec echo "[set interact_out(0,string)]" |\
        #               write [set dest_name] [set dest_tty]
        #            catch {exec echo "[set interact_out(0,string)]" >  \
        #               [set dest_tty]}
        #            send_user "-[set interact_out(0,string)]-"
        #        }
        #    }]
        #}

        #code: myinteractcmd {{{4}}}
        #full features, monitor:
        #1. full user cmd
        #2. kibitz
        #3. process input
        #
        #user -------------------- Expect/interact -------- process
        #     -input $user_spawn_id                -output $process_output
        #     =====>                               =======>
        #     -output $user_spawn_id               -input $process_input
        #     <=====                               <=======
        #

        #save this "current" spawn id if not yet
        if ![info exists shell_list] {
            set shell_list ""
        }
        #if not in shell_list yet, insert process spawn_id as the 1st element
        #of shell_list
        if [ni $process_input $shell_list] { 
            set shell_list [linsert $shell_list 0 $process_input]
            myputs "insert:$process_input into shell_list:$shell_list"
        }

        myputs "process - ${process_input}(in) :${process_output}(out)\
            :kibitz($kibitz_list)"
        myputs "shell_list - $shell_list; kibitz_list - $kibitz_list"

        set myinteractcmd [subst -nocommands {\n\
            interact {\n\


                -input $user_spawn_id\n\ 
                    $myinteract_user_input_patterns\n

                -output process_output\n\


                -input kibitz_list\n\
                    $myinteract_kibitz_input_patterns\n\

                -output process_output\n\


                -input process_input\n\
                    $myinteract_process_input_user_patterns\n\
                    $myinteract_process_input_patterns_misc\n\
                    $myinteract_process_input_patterns_static\n\

                -output $user_spawn_id\n\
                    $myinteract_user_output_patterns\n\

                -output kibitz_list\n\

            }\n\
        }]

        myputs "myinteractcmd looks $myinteractcmd" 3

        #code: myinteractcmd_simplified {{{4}}}
        #partial features, monitor:
        #1. full user cmd
        #
        set myinteractcmd_simplified [subst -nocommands {\n\
            interact {\n\


                -input $user_spawn_id\n\ 
                    $myinteract_user_input_patterns\n

                -output process_output\n\

                -input process_input\n\

                -output $user_spawn_id\n\ 

            }\n\
        }]

        #code: interact_simplest {{{4}}}
        #least features, monitor:
        #1. several user cmd
        #
        set interact_simplest {
            interact {
                -echo "!N" {                                    ;#{{{5}}}
                    interact_N;return
                }
                -echo "!q" {                                    ;#{{{5}}}
                    #select q instead of Q like in feature version, is for the
                    #nested crtc call:
                    #server1> crtc -Q jtac-server
                    #server2$ crtc myrouter
                    #...
                    #now !Q to exit only myrouter, and return back to
                    #jtac-server, instead of exiting from jtac-server
                    #
                    exit
                }
                -echo "!?" {                                    ;#{{{5}}}
                    send_error "inline commands:\n"
                    send_error "  !N  load more features"
                    send_error "  !q  exit"
                    send_error "  !?  this help\n"
                }

                -reset "![CONST $key_background]" {             ;#{{{5}}}
                    puts "\[session $router\]: you pressed a keystroke\
                        \"!$key_background\" that moves this session background,\
                        type `fg` to move it foreground when needed!"
                    exec kill -STOP [pid]
                }

                timeout $anti_idle_timeout_user_input {       ;#{{{5}}}
                    log_user 0
                    if [string equal $anti_idle_string "null"] {
                        send -i $process -null
                    } else {
                        send -i $process "$anti_idle_string"
                    }
                    log_user 1

                    #eval $interact_timeout 
                    #to recover back original features, if mode ever changed
                    if {($features_ori == 2) && ($features != $features_ori)} {
                        myputs "original feature was $features_ori and was \
                            changed to $features, "
                        myputs "set to 2 on timed out..."
                        myputs2 "\r\nuser timeout after ${anti_idle_timeout}s,"
                        myputs2 "\r\nswitched back to original (monitoring) mode\n"

                        set features 3
                        set enable_user_patterns $enable_user_patterns_ori

                        return
                    }
                }

                #timeout $anti_idle_timeout_user_input {        ;#{{{6}}}
                #    if {$features==2} {
                #        #under flexible features (2), once user is not typing,
                #        #turn to feature-rich interact
                #        myputs "timeout ${anti_idle_timeout}s"
                #        myputs "flexible features ($features) is configured"
                #        puts "go feature-rich mode...type !? to list all cmds"
                #        #interact_N;return
                #        set simple_interact 0
                #        #set features 3
                #        #set options(features) 3
                #        #set options_inline(features) 3
                #        return
                #    }
                #}
            }
        }

        #how to detect peer kibitz user exit {{{5}}}
        #if: 
        #    1. during kibitz session
        #    2. received a prompt that looks exactly same as
        #    kibitz shell prompt,
        #then:
        #    most probably kibitz is gone
        #    close the kibitz shell, reset kibitz_list

        #when remote user exit, following will be received from kibitz user:
        #TODO: this is NOT reliable - when testing with other folks
        #
        #labroot@seahawks-re0> 0;pings@svl-jtac-tool02pings@svl-jtac-tool02:~$
        #                      ^
        #unknown command.
        #labroot@seahawks-re0> 0;pings@svl-jtac-tool02pings@svl-jtac-tool02:~$
        #Jun 05 15:54:40
        #                      ^
        #unknown command.
        #labroot@seahawks-re0>
        #Jun 05 15:54:41

        myputs "features now looks $features"

        switch -exact -- $features {
            0       {
                set simple_interact 1
            } 
            default {
                set simple_interact 0
                #set enable_user_patterns 3
            }
        }

        #eval interact: featured vs simple{{{4}}}
        myputs "features looks $features"

        #this will catch errors when exiting crtc, and just exit siliently,
        #instead of report errors (spawn_id not found or sth like that)
            if $simple_interact {

                #with no features (0), use simple interact
                #with flexible features(2), start with simple interact, then switch
                #  to rich features on idle timeout

                eval $interact_simplest
                #eval $myinteractcmd_simplified

            } else {

                eval $myinteractcmd

            }

        #save the option var update {{{4}}}
        foreach opt [array name options] {
            if [info exists $opt] {
                set options($opt) [set $opt]
                #myputs "set $options($opt) [set $opt]" 3
            }
        }

        #respawn after interact {{{4}}}
        if $is_respawn {
            set is_respawn 0
            set sigquit 0
            spawn_login $router
        }
        #spawn -noecho $env(SHELL)
        #set host2session($login_index) $spawn_id
        #set session2host($spawn_id) $login_index

        #do_pag $login_index login_info

    }   ;#end while
}


#interact_X procs {{{2}}}

set interact_a {        ;#{{{3}}}
    #assign arbitrary values
    set timeout 60
    send_user "input your tcl command:\n"
    #set oldmode [stty -raw echo]

    catch {set oldmode [stty -raw echo]}

    expect_user {
        -re "(\[^\n]+)\n" {
            set user_tcl $expect_out(1,string)
            set options_inline(attribute) $user_tcl

            set l_tcl [split $user_tcl ";"]
            foreach a_tcl $l_tcl {
                #if [regexp {set\s+(\S+)\s+(\S+)} $a_tcl -> op va] {}
                if [regexp {set\s+(\S+)\s*(\S*)} $a_tcl -> op va] {
                    myputs "you input command: :$a_tcl:$op:$va:"

                    if ![string equal $va ""] {
                        #new value assignment
                        #use catch to catch any user input errors
                        catch {
                            #this seems buggy:
                            #  e.g.: set a "b"
                            #  this will make a's value to be 3 chars: "b" ,
                            #  instead of one char: b
                            #set $op $va
                            #set options($op) $va
                            #set options_inline($op) $va
                            eval $a_tcl
                            set options($op) $op
                            set options_inline($op) $op
                        }
                        #myputs2 "set $op to $va\n"
                        puts "set $op to $va\n"
                        return          ;#return to make change taking effect
                    } else {
                        #just show current value
                        #set $op
                        if [info exists $op] {
                            catch {
                                send_user -- "$op is [set $op]\n"
                            }
                        } else {
                            send_user "$op is not a valid CRTC option!\n"
                        }
                    }
                } else {
                    puts "warning: $a_tcl is not a valid tcl expression!"
                    exp_continue
                }
            }

        }
        -re "\n" {
            send_user "<<<CRTC:eh?\n"
        }
        timeout {
            send_user "you didn't input anything in $timeout second...\n"
        }
    }
}

set interact_b {        ;#{{{3}}}
    send_user "toggle screen sharing..."

    if ![string equal [set kibitz_list] ""] {
        set kibitz_list_ori [set kibitz_list]
        send -i kibitz_list "sharing is turned off tempararily...\r\n"
        set kibitz_list ""
        puts "sharing is blocked among users: $kibitz_user_list"
    } else {
        set kibitz_list [set kibitz_list_ori]
        send -i kibitz_list "sharing is turned on now...\r\n"
        puts "sharing is recovered among users: $kibitz_user_list"
    }
}

set interact_any {      ;#{{{3}}}

    set timedout 0

    #process \r {{{4}}}
    if [string equal $interact_out(0,string) "\r"] {
        myputs "you typed a return" 2
        set is_usertyping 0

        send_user $automation_non_complete_msg

        if $timestamp {
            set totimestamp 1
            myputs "will timestamp"

            #try to provide a simple implementation when no features
            if !$features {
                send_user "\n[subst $current_time_cmd](local)\n"
            }
        }

    } else {
        set is_usertyping 1
        #$myputs_interact_out_0_string
        myputs "you typed -$interact_out(0,string)-"

    } 

    if $ownertyping {           ;#{{{4}}}
        myputs "user is typing" 2

        #user tying triggers:
        #
        #* with flexible "features" (2) AND 
        #* dynamic interact (enable_user_patterns is 2 or 3), 
        #
        #switch to static interact (by setting to 1).
        #
        #this is to get better performance. 
        #for that crtc "return" from current interact to run a new interact

        myputs "not inkibitz" 2

        if {$features_ori == 2} {   ;#{{{5}}}
            #use original features value, since the features value may have
            #already been changed due to last timeout (to 2), but original
            #value remains (hopefully)
            #
            #with flexible features (2), if not in kibitz, a user keystroke
            #will trigger it going to no features mode for better
            #performance
            myputs "flexible features ($features) is configured"

            ##no use. simply set features 0 will be it
            #if $type_to_disable_features {      ;#{{{6}}}
            #    myputs "type_to_disable_features set, will go features 0"
            #    #backup orignal features, and set to 0 (to disable features)
            #    set simple_interact 1
            #    return
            #}

            if {$enable_user_patterns >= 2} {   ;#{{{6}}}
                myputs2 "\r\nswitch to fast mode (user is typing)!\n"
                myputs "change current enable_user_patterns \
                    ($enable_user_patterns) to 1"
                set enable_user_patterns 1
                #return only if need to switch,so this will happen only on
                #1st char
            }

            myputs "set features 1"
            set features 1

            #interact_N;return
            #set features 0
            #set options(features) 0
            #set options_inline(features) 0
            #set simple_interact 1
        }

    } else {                    ;#{{{4}}}

        set ownertyping 1

        #on receiving 1st char from user:
        #during kibitz, will trigger sending of a notice to others
        #indicating owner is typing

        if $inkibitz {          ;#{{{5}}}

            send -i $kibitz_list "\r\n<---$env(USER) is typing ...\r\n"
            foreach asid [array name sid2typing] {
                set sid2typing($asid) 0
            }

        } 

    }

    set pattern_cmd_input ".+"
    if [string equal $interact_out(0,string) '\r'] {
        puts "\nmatch enter from .+"
    }
    return
}

set interact_l {        ;#{{{3}}}

    puts "\nselect from below options:"
    puts "n)ew   : start a new log"
    puts "s)top  : stop logging on current file(will start logging"
    puts "         in original file if a new file is in use)"
    puts "S)top  : stop all logging"
    puts "r)esume: resume logging in last file"
    puts "t)oggle: toggle between new file and original log file"
    puts "v)iew  : view log file"
    puts "l)ist  : list current log file"
    puts "e)mail : email current log"
    puts "q)uit  : quit the menu without doing anything"

    expect_user {
        -re "e" {
            puts "mail current log $log_fullname_cur to $emailto"
            sendanemail $log_fullname_cur $emailto
        }
        -re "n" {
            puts "ew log file name:"
            set log_filename_new [gets stdin]
            set log_fullname_new "$log_dir_new/$log_filename_new"
            log_file
            log_file $log_fullname_new
            set log_fullname_cur $log_fullname_new
            puts "logging in new file $log_fullname_new ..."
        }
        -re "s" {
            log_file
            log_file $log_fullname
            puts "top logging in current file and continue on\
                $log_fullname"
            set log_fullname_cur $log_fullname
        }
        -re "S" {
            log_file
            puts "top logging in any log file"
            set log_fullname_cur "NULL"
        }
        -re "r" {
            if ![string equal $log_fullname_cur "NULL"] {
                #if not fully stopped yet, continue with last file
                puts "esume logging to $log_fullname_cur"
                log_file $log_fullname_cur
            } else {
                #otherwise(fully stopped), continue with intial
                #file
                puts "esume logging to $log_fullname"
                log_file $log_fullname
            }
        }
        -re "v" {
            if ![string equal $log_fullname_cur "NULL"] {
                puts "iew the log file:$log_fullname_cur"
                system less $log_fullname_cur
            } else {
                puts "currently no logging!"
            }
        }
        -re "l" {
            if ![string equal $log_fullname_cur "NULL"] {
                puts "ist current log file: $log_fullname_cur"
            } else {
                puts "currently no logging!"
            }
        }
        -re "q" {
            puts "log file not changed!"
        }
        -re "t" {
        }
        -re "." {
            #puts "invalid input! press one of these:\[ensSrvlq\]"
            #exp_continue
            send_user "eh?\n"
        }
    }       ;#expect_user inside !l

}

proc interact_A {} {    ;#{{{3}}}
    #toggle auto_paging feature
    #obselete, replaced with "arbitrary" setting feature
    global global_data; eval $global_data 
    if $auto_paging {
        set auto_paging 0
        set pattern_more $pattern_no_match
    } else {
        set auto_paging 1
        set pattern_more $pattern_more_const
    }
    puts "\nauto_paging $auto_paging"
    set options(auto_paging) $auto_paging
    set options_inline(auto_paging) 0
    set options(pattern_more) $pattern_more_const
    puts "options(pattern_more) looks $options(pattern_more) now"
    set options_inline(pattern_more) $pattern_more_const
}

proc interact_c {router} {    ;#{{{3}}}

    upvar command command1
    upvar router router1
    upvar commandgroup commandgroup1
    global global_data; eval $global_data

    global cmds_c cmds_c_backup
    array unset cmds_c

    #reload data {{{4}}}
    foreach host1 $hostlist_full { reload_data $host1 }

    #for some reason, with this manual reset, -reset doesn't work..
    #mycatch "stty raw"
    #set oldmode [stty raw]

    #mycatch "stty -raw"
    #save current tty mode, whatever it is
    set oldmode [mystty -info]
    mycatch "mystty raw"

    send_user "\n"
    send_user "select your choice below:\n"
    send_user "1: enter command, or command array($commandgroup1)\n"
    send_user "   configured in config file to be executed\n"
    send_user "\n2: repeat the last commands/command array"
    #send_user "\n3: select command from history"
    send_user "\nq: quit\n"

    set timeout -1
    expect_user {
        -re {\d} {
            set selection $expect_out(buffer)
            if {$selection <=0 || $selection >=3} {
                puts "$selection: not a valid option, select (1,2,q) again:"
                exp_continue
            }
        }
        "q" {
            puts "uit"
            return
        }
        -re "\r" {
            set selection 1
        }
        -re ".+" {
            set selection $expect_out(buffer)
            puts "$selection: not a valid option, select (1,2,q) again:"
            exp_continue
        }
    }

    #set selection [gets stdin]

    mycatch "mystty -raw"

    if {$selection==1} {
        #select 1 {{{4}}}
        #input command or command group array {{{5}}}
        set command_ori $command1
        puts "Enter the command/command array you want to iterate:"
        puts "   \[$command_ori\]"
        flush stdout;

        while 1 {
            #gets stdin row
            #puts $row
            #lappend cmds1($router) $row
            #if {[string equal $row "."]} {break}

            set get_nothing 1
            set read_stdin [gets stdin]
            if [string equal $read_stdin ""] {
                #append previous commands if nothing provided
                if $get_nothing {
                    #lappend looks correct, append won't have space
                    lappend cmds_c($router1) $command_ori
                }
                myputs "seeing empty input, will break loop"
                myputs "so far got:\n$cmds_c($router1)"
                break
            } else {
                #is anything provided, remember this
                set get_nothing 0
                set command1 $read_stdin
                myputs "get command $command1"
                lappend cmds_c($router1) $command1
                myputs "so far got:\n$cmds_c($router1)"
            }
        }
        myputs "eventually got:\n$cmds_c($router1)"
        set command_ori $command1

        set cmds_c_backup($router1) $cmds_c($router1)

        #input rounds/intervals/etc {{{5}}}
        set max_rounds_ori $max_rounds
            puts "Enter how many iterations you want to run:\
                \[$max_rounds\]";flush stdout;

            set read_stdin [gets stdin]
            if ![regexp {(\d+)} $read_stdin -> max_rounds] {
                myputs "no max round inputted"
                set max_rounds $max_rounds_ori
                set options(max_rounds) $max_rounds_ori
                set options_inline(max_rounds) $max_rounds_ori
            } else {
                set options(max_rounds) $max_rounds
                set options_inline(max_rounds) $max_rounds
            }
            set max_rounds_ori $max_rounds

        set interval_cmds_ori $interval_cmds
            puts "Enter intervals between each iteration: \
                \[$interval_cmds\]";flush stdout;

            set read_stdin [gets stdin]
            if ![regexp {(\d+)} $read_stdin -> interval_cmds] {
                myputs "no intervals inputted"
                set interval_cmds $interval_cmds_ori
                set options(interval_cmds) $interval_cmds_ori
                set options_inline(interval_cmds) $interval_cmds_ori
            } else {
                set options(interval_cmds) $interval_cmds
                set options_inline(interval_cmds) $interval_cmds
            }
            set interval_cmds_ori $interval_cmds

        mycatch "stty raw"
        puts "will iterate command/command group \[$command1\] \
            $max_rounds rounds with interval $interval_cmds \
            between each iteration,(y)es/(n)o/(q)uit?\[y\]"

    } elseif {$selection==2} {
        #select 2 {{{4}}}

        mycatch "stty raw"
        puts "will iterate command/command group \[$command1\] \
            $max_rounds rounds with interval $interval_cmds \
            between each iteration,(y)es/(n)o/(q)uit?\[y\]"

        set cmds_c($router1) $cmds_c_backup($router1)

    } else {
        puts "to do"
    }

    #execute cmds group cmds_c{{{4}}}
    #this doesn't work
    #set yn [gets stdin]
    #if {$yn=="y"} {
    #    set cmds1($router) [list $command]
    #    exec_cmds $router 
    #} elseif {$yn=="q"} {
    #    break
    #} else {
    #}
    #
    #this works
    mycatch "mystty raw"
    expect_user {
        -re "y|\r" {
            #set cmds1($router) [list $command1]
            parray cmds_c

            exec_cmds $router1 cmds_c

            send_user "all done!\n"
            set command_ori $command1
            set max_rounds_ori $max_rounds
            set interval_cmds_ori $interval_cmds
        }
        "q" {
            puts ""
        }
        "n" {
            myputs "input your data again"
        }
        -re "." {
            puts "invalid input! press one of these:\[ynq<ENTER>\]"
            exp_continue
        }
    }

    #mycatch "stty -raw"
    mycatch "mystty $oldmode"
}

proc interact_r {router} {      ;#{{{3}}}
    global pa_pair host2session
    set process host2session($router)

    set yn "q"
    #while {($yn!="y") && ($yn!="n")} {}
    while 1 {
        #puts "Enter the command array you configured: ";flush stdout;
        #set commandgroup [gets stdin]

        puts "to repeat the previous cmds1 executions,\
            right((y)es/(q)uit?\[y\])"
        #flush stdout
        #set yn [gets stdin]
        #myputs "get -$yn-"
        #if {$yn=="n"} {
        #} 
        #if {$yn=="y"} {
        #    set sigquit 0
        #    exec_cmds $router
        #}

        mycatch "stty raw"
        expect_user {
            -re "y|\r" {
                set sigquit 0
                #incr myinteract_depth
                if $pa_pair {
                    send -i $process "\r"
                }
                exec_cmds $router
                break
            }
            "q" {
                puts "\n"
                break
            }
            "?" {
                puts "\n"
            }
        }
        mycatch "stty -raw"
    }
}

set interact_multi_session {    ;#{{{3}}}

    myputs "you pressed $interact_out(0,string)"
    for {set i 1} {$i<10} {incr i 1} {
        if [info exists interact_out($i,string)] {
            myputs "interact_out($i,string) is $interact_out($i,string)"
        }
    }

    interact_multi_session $interact_out(1,string)

}

proc interact_multi_session {user_key} {        ;#{{{3}}}
    #switch -exact -- $interact_out(1,string) {}
    global global_data; eval $global_data
    global shell_list kibitz_list kibitz_list_ori
    global process_input process_output
    global select_host inkibitz
    global sid2user sid2typing inkibitz 
    global kibitz_user_list kibitz_user login_index

    upvar process process
    upvar router router
    #upvar process_input process_input
    #upvar process_output process_output

    switch -exact -- $user_key {

        "c" {   ;#{{{4}}}
            #same as !y
            interact_y
        }

        "k" {   ;#{{{4}}}
            #copied from !k
            if [in $process_input [lrange $shell_list 1 end]] {
                #if yet, remember it for later interact
                set spawn_id $process_input
            } else {
                #if not, tell user to select a shell
                puts "you are still in the session to be shared, to share this\
                    session, you need to switch to a shell.\n\
                    type \\l to list available shells; \\NUMBER to select one"
                return
            }
            puts "-----------------------------------"
            set kibitz_user [user_input "which user is this?"]

            set process_input [arrayvalue host2session]
            set process_output [arrayvalue host2session]

            #save current shell in backup kibit_list
            lappend kibitz_list_ori $spawn_id
            set kibitz_list $kibitz_list_ori
            set sid2user($spawn_id) $kibitz_user
            set sid2typing($spawn_id) 0

            #remove current shell from shell_list if kibitz succceed, 
            ldelete shell_list $spawn_id
            #set shell_list [lreplace $shell_list 0 0 $kibitz_list]

            myputs "shell_list: $shell_list: kibitz_list: $kibitz_list" 0
            myputs "kibitz_list_ori: $kibitz_list_ori:current sid:$process_input" 0

            set inkibitz 1

            #set user2kibitz_spawn_id($kibitz_user) $kibitz_list
            #set kibitz_spawn_id2user($kibitz_list) $kibitz_user

            send -i $kibitz_list "session $login_index is being shared between\
                \[$kibitz_user_list\] now...\n"
            send -i $kibitz_list "to exit, type ctrl+\], and then \"exit\""
        }

        "i" {   ;#{{{4}}}
            #for multiple host login scenario
            set hostnum [lsearch [array names session2host] $process]
            send_user "you are in $session2host($process)\
                ([expr $hostnum+1]), press '\\\[NUMBER\]\' to \
                switch to other host!\n"

            send_user "host lists: \n";set i 1
            foreach host $hostlist_full {
                #why puts does'nt work here?
                send_user "$host ($i) ";incr i
                if {$i >=20} {
                    send_user "too much hosts..won't print all in here\n"
                    break
                }
            }
            send_user "\n"

            #if i is pressed, next \2 will select hosts
            set select_host 1   
        }

        "l" {   ;#{{{4}}}
            #similiar to i above, but for kibitz shell list
            send_user "host lists: \n";set i 0
            foreach id $shell_list {
                #why puts does'nt work here?
                send_user "$i:$id/[exp_pid -i $id] ";incr i
                if {$i >= 20} {
                    send_user "too much shells..won't print all in here\n"
                    break
                }
            }
            send_user "\n"

            myputs "shell_list: $shell_list: kibitz_list: $kibitz_list"
            myputs "kibitz_list_ori: $kibitz_list_ori:current sid:$id"

            #if l is pressed, next \2 will select shell, not host
            set select_host 0
        }

        "s" {   ;#{{{4}}}
            #not done yet
            while 1 {
                #for some reason, with this manual reset, -reset
                #doesn't work..
                mycatch "stty -raw"
                set routername_ori $router

                puts "Enter the router name you want to login: \[$routername_ori\]"
                    flush stdout;
                set routername [gets stdin]
                    if [string equal $routername ""] {
                        myputs "no router name was given"
                        set routername $routername_ori
                    }

                puts "login router \[$routername\],(y)es/(n)o/(q)uit?\[y\]"
                    flush stdout;

                mycatch "stty raw"
                expect_user {
                    -re "y|\r" {
                        send_user "login to $routername ...\n"
                        reload_data $routername
                        spawn_login $routername
                        set hostlist_full "$hostlist_full $routername"
                        break
                    }
                    "q" {
                        puts ""
                        break
                    }
                    -re "." {
                    }
                }
                mycatch "stty -raw"
            }
        }

        "q" {   ;#{{{4}}}
            #close; wait
        }

        default {               ;#{{{4}}}
            myputs "select_host looks $select_host"
            if $select_host {   ;#{{{5}}}
                #set hostnum $interact_out(1,string)
                set hostnum $user_key
                myputs "hostlist_full is -$hostlist_full-"
                myputs "you entered hostnum $hostnum"
                if {$hostnum > 0 && $hostnum<=[llength $hostlist_full]} {
                    set router [lindex $hostlist_full $hostnum-1]
                    set process_input $host2session($router)
                    set process_output $host2session($router)
                    puts "switched to #$hostnum host:$router (session\
                        $process_input)"

                    #if [info exist options_cli(parallel)] {
                    #    if {$parallel==1} {
                    #        set process_input $host2session($router)
                    #        set process_output [arrayvalue host2session]
                    #    } elseif {$parallel==2} {
                    #        set process_input [arrayvalue host2session]
                    #        set process_output [arrayvalue host2session]
                    #    } else {
                    #        set process_input $host2session($router)
                    #        set process_output $host2session($router)
                    #    }
                    #} else {
                    #    set process_input $host2session($router)
                    #    set process_output $host2session($router)
                    #}
                    #myputs "process_input set to $process_input"
                    #myputs "process_output set to $process_output"

                    return

                } else {        
                    puts "you entered an unknown host number!"
                    puts "host lists: ";set i 1
                    foreach host $hostlist_full {
                        #why puts does'nt work here?
                        send_user "$host ($i) ";incr i
                    }
                    send_user "\n"
                }
            } else {            ;#{{{5}}}
                set shellnum $user_key
                if {$shellnum >= 0 && $shellnum<[llength $shell_list]} {
                    set id [lindex $shell_list $shellnum]
                    set process_input $id
                    set process_output $id
                    puts "switched to session: $shellnum:$id/[exp_pid -i $id]"

                    #don't share other "normal" shells when selected, make sure
                    #only shell#0 (current session) is shared
                    if {$shellnum > 0} {
                        #"block" sharing when switched to any shell other than
                        #original session #0
                        #set kibitz_list ""
                        

                    } else {
                        #share again when selected shell #0
                        if [info exists kibitz_list_ori] {
                            set kibitz_list $kibitz_list_ori
                        } else {
                            set kibitz_list ""
                        }
                    }

                    myputs "shell_list: $shell_list: kibitz_list: $kibitz_list"
                    myputs "kibitz_list_ori: $kibitz_list_ori:current sid:$id"

                    #TODO: not done yet
                    #Segmentation fault (core dumped)

                    #if [info exist options_cli(parallel)] {
                    #    if {$parallel==1} {
                    #        set process_input $host2session($router)
                    #        set process_output [arrayvalue host2session]
                    #    } elseif {$parallel==2} {
                    #        set process_input [arrayvalue host2session]
                    #        set process_output [arrayvalue host2session]
                    #    } else {
                    #        set process_input $host2session($router)
                    #        set process_output $host2session($router)
                    #    }
                    #} else {
                    #    set process_input $host2session($router)
                    #    set process_output $host2session($router)
                    #}
                    #myputs "process_input set to $process_input"
                    #myputs "process_output set to $process_output"

                    return

                } else {
                    puts "you entered an unknown host number!"
                    puts "host lists: ";set i 1
                    foreach host $hostlist_full {
                        #why puts does'nt work here?
                        send_user "$host ($i) ";incr i
                    }
                    send_user "\n"
                }
            }
        }
    }

    #switch -regexp -matchvar matched_key -- $user_key {}
}

proc interact_t {} {    ;#{{{3}}}
    global global_data; eval $global_data

    if {$timestamp==0} {
        set timestamp 1
        set pattern_timestamp "\r"
        set pattern_timestamp_verbose $pattern_no_match
        puts "imestamp 1 - local timestamp on!"
    } else {
        set timestamp 0
        set pattern_timestamp $pattern_no_match
        set pattern_timestamp_verbose $pattern_no_match
        puts "imestamp 0 - local timestamp off!"
    }

    #puts "\ntimestamp $timestamp"

    set options(timestamp) $timestamp
    set options(pattern_timestamp) $pattern_timestamp
    set options(pattern_timestamp_verbose) $pattern_timestamp_verbose

    set options_inline(timestamp) $timestamp
    set options_inline(pattern_timestamp) $pattern_timestamp
    set options_inline(pattern_timestamp_verbose) \
        $pattern_timestamp_verbose
}

proc interact_T {} {    ;#{{{3}}}
    global global_data; eval $global_data

    if {$timestamp==0} {
        set timestamp 2
        set pattern_timestamp_verbose "(\[^\r\]*)\r\n"
        puts "\ntimestamp $timestamp"
        puts "all cmd output lines will be timestamped, 
                type !T one more time to turn this off"
    } else {
        set timestamp 0
        set pattern_timestamp_verbose $pattern_no_match
        puts "\ntimestamp $timestamp"
    }

    set options(timestamp) $timestamp
    set options(pattern_timestamp_verbose) $pattern_timestamp_verbose
    set options_inline(timestamp) $timestamp
    set options_inline(pattern_timestamp_verbose) \
        $pattern_timestamp_verbose
}

proc interact_u {} {    ;#{{{3}}}
    global global_data; eval $global_data

    switch -exact -- $enable_user_patterns {
        0 {
            set enable_user_patterns 1
        } 1 {
            set enable_user_patterns 2
        } 2 {
            set enable_user_patterns 3
        } default {
            set enable_user_patterns 0
        }
    }

    puts "\nenable_user_patterns $enable_user_patterns"

    set options(enable_user_patterns) $enable_user_patterns
    set options_inline(enable_user_patterns) $enable_user_patterns
}

proc interact_z {} {    ;#{{{3}}}
    global global_data; eval $global_data

    if $compress_log {
        set compress_log 0
    } else {
        set compress_log 1
    }
    puts "\ncompress_log $compress_log"

    set options(compress_log) $compress_log
    set options_inline(compress_log) $compress_log
}

proc interact_Z {} {    ;#{{{3}}}
    global global_data; eval $global_data
    global anti_idle_timeout_user_input_ori anti_idle_timeout_proc_input_ori

    if $no_anti_idle {
        set no_anti_idle 0
        set options_inline(anti_idle_timeout_user_input) $anti_idle_timeout_user_input_ori
        set options_inline(anti_idle_timeout_proc_input) $anti_idle_timeout_proc_input_ori
    } else {
        set no_anti_idle 1
        set options_inline(anti_idle_timeout_user_input) 100000000
        set options_inline(anti_idle_timeout_proc_input) 100000000
        myputs "\nno_anti_idle $no_anti_idle, anti_idle_timeout set to indefinite"
    }

    set options(no_anti_idle) $no_anti_idle
    set options_inline(no_anti_idle) $no_anti_idle
}

proc interact_connection_close {} {     ;#{{{3}}}
    global global_data; eval $global_data

    #todo: reorga these options:
    #   * exit_sync, 
    #   * no_reconnect_on_interact and 
    #   * persistent

    #if this flag is set, when exiting telnet/ssh, also return
    #interact since interact is the last code, so spawned bash exit
    #also,and script exit
    puts "\[crtc:detected connection closed!\]"
    if $no_reconnect_on_interact {
        puts "no_reconnect_on_interact set, won't reconnect\n"

        if $exit_sync {
            #uplevel puts "$interact_out(0,string)"
            puts "exit_sync set, exit crtc"
            exit
        } else {
            #uplevel puts "$interact_out(0,string)"
            myputs2 "exit_sync not set, you are still in crtc!\
                (type !? to confirm this).\nTo exit crtc, \
                type !Q to kill the script...\n"
            #send_tty "make sure you are not in \"persistent mode\"(-p)\n"
        }

    } else {
        if $exit_sync {
            #uplevel puts "$interact_out(0,string)"
            puts "exit_sync set, exit crtc"
            exit
        } else {
            #uplevel puts "$interact_out(0,string)"
            myputs2 "exit_sync not set, you are still in crtc!\
                (type !? to confirm this).\nTo exit crtc, \
                type !Q to kill the script...\n"
            #send_tty "make sure you are not in \"persistent mode\"(-p)\n"
        }

        if {$persistent>1} {
            myputs2 "persistent mode set $persistent,\
                will reconnect in ${reconnect_interval}s\n"
            myputs2 "type !p to toggle persistent mode"
            mysleep $reconnect_interval
            #below line worked fine previously when spawn was not
            #put in spawn_login , there is issue afterward: "puts
            #no stdout", or "exp0 not open"
            #
            #issue found to be "spawn_id" not set as "global" in
            #spawn_login proc
            close; wait
            uplevel {set is_respawn 1}
            return 1
        } else {
            puts "persistent mode set $persistent, won't reconnect\n"
        }
    }
}

proc interact_pattern_cmd_input {user_keystroke} {    ;#{{{3}}}

    #global global_data; eval $global_data
    #send_user "is_usertyping is $is_usertyping\n"
    global parallel session2host

    upvar is_usertyping is_usertyping1
    upvar didsave didsave1
    upvar buf_in buf_in1
    upvar buf_out buf_out1
    upvar cmd_input cmd_input1
    upvar currenthost currenthost1
    upvar does_holdsession does_holdsession1

    if $is_usertyping1 {                ;#{{{4}}}
        #when user is typing:
        #1. to collect the echoed command
        #comparing with user input, this is the ultimate cmd that
        #will be executed by the remote device, also reset the save
        #flag
        append buf_in1 $user_keystroke
        set didsave1 0

        send_user -- $user_keystroke
        #puts "echoed: $interact_out(0,string)"
        
    } else {            ;#{{{4}}}
        #when user stopped typing and hit enter:
        #1. save the collected echoed command line input
        #2. collect the output
        #3. hold the current session before dumping output from
        #   other sessions
        #
        #send_user "is_usertyping is 0 now\n"
        
        #save the collected full command for later use, and reset
        #the buf_in, also set a flag to do it just one time
        if !$didsave1 {
            set cmd_input1 $buf_in1
            set buf_in1 ""
            #send_user "\ninput cmd:\[$cmd_input\]!\n"
            set didsave1 1
        }

        #remove this pattern match if no need to manipulate the
        #outputs, so it's faster and safer?
        #set pattern_cmd_input $pattern_no_match
        #return

        #to collect the command line output
        append buf_out1 $user_keystroke

        #following code doesn't work, the goal was to to make a gap
        #between simultaneous inputs from multi sessions
        #set timeout 2
        #expect -i $interact_out(spawn_id) -re ".+" {
        #    send_user -- $expect_out(0,string)
        #    exp_continue
        #}
        #
        #this work well
        #on detection of output from any session, hold it by:
        #1. set the does_holdsession flag 
        #2. return to while loop, where the process_input will be
        #   rewrite to only current session
        if $parallel==2 {
            uplevel {set currenthost $session2host($interact_out(spawn_id))}
            myputs "input received from $currenthost1, hold it" 2
            uplevel {set process_input $interact_out(spawn_id)}
            set does_holdsession1 1

            #insert a small piece of text to indicate where was the
            #output from
            send_user "==from $currenthost1:==\n"

            send_user -- $user_keystroke
            #puts "echoed: $interact_out(0,string)"
            
            return
        } else {

            send_user -- $user_keystroke
            #puts "echoed: $interact_out(0,string)"
            
        }
    }
}

proc interact_d {} {    ;#{{{3}}}
    global global_data; eval $global_data

    set debug [expr !$debug]
    #if $debug {
    #    set debug 0
    #} else {
    #    set debug 1
    #}
    puts "\ndebug $debug"
    set options(debug) $debug
    set options_inline(debug) $debug
}

proc interact_f {} {    ;#{{{3}}}
    global global_data; eval $global_data
    global host2session login_index
    upvar download_folder download_folder

    send_user "ile get/put (g,p,? for more): "
    expect_user {
        g {get_filename "get"}
        p {get_filename "put"}
        c chdir
        v verbose
        "\\?" {
            send_user "?\n"
            send_user "g  get file from remote system\n"
            send_user "p  put file to remote system\n"
            send_user "c  change/show directory on local system\n"
            send_user "!  send ! to remote system\n"
            send_user "?  this list\n"
            send_user "v  verbose mode toggle (currently [verbose_status])\n"
            send_user "^Z suspend current session\n"
        }
        "[CONST CTRL_Z]" {
            mycatch "stty -raw echo"
            exec kill -STOP [pid]
            stty raw -echo
        }
        -re . {send_user "<<<CRTC:unknown command\n"}
    }
    send_user "<<<CRTC:resuming session of $login_index...\n"
}

proc get_filename {getput} {  ;#{{{4}}}
    global host2session debug login_index env
    upvar download_folder download_folder


    #select local folder {{{5}}}
    set timeout 1800
    send_user "\n<<<CRTC:choose a local file folder as \"$download_folder\",\
        yes/no/quit?\[y\]"
    #this will make user felt like like being pushed
    #send_user "\n<<<CRTC:(you have ${timeout}s to select your option)\n"

    #this does not look safe - spawn_login will set spawn_id which is global
    #too expensive for this temp need
    #if ![info exists host2session(LOCALHOST)] {
    #    spawn_login "LOCALHOST"
    #}

    expect_user {
        -re "y|\r" {
            send_user "\n"
        }
        "q" {
            return
        }
        "n" {
            if [catch "spawn -noecho $env(SHELL)" reason] {
                send_user "failed to spawn program: $reason\n"
                exit 1
            }

            #set spawn_id $host2session(LOCALHOST)
            puts ""
            puts "<<<CRTC:navigate to the local folder where you want to"
            puts "<<<     save the file or pull the file from, and press"
            puts "<<<     \\\\ to record the name.."
            interact {\\} {
                #set pwd [exec pwd]
                send "pwd\r"
                expect -re "\r\n(\[^\n]+)\r\n" {
                    set download_folder $expect_out(1,string)
                }
                send_user "\n<<<CRTC:local folder selected as:\"$download_folder\"\n"
                return
            }
            close;wait

            #interact {
            #    -i $spawn_id_localshell 
            #    {\\} {
            #        #set pwd [exec pwd]
            #        send -i $spawn_id_localshell "pwd\r"
            #        expect -i $spawn_id_localshell -re "\r\n(\[^\n]+)\r\n" {
            #            set download_folder $expect_out(1,string)
            #        }
            #        send_user "\n<<<CRTC:local folder selected as:\"$download_folder\"\n"
            #        return
            #    }
            #}
        }
        -re "." {
            puts "<<<CRTC:invalid input! press one of these:\[ynq<ENTER>\]"
            exp_continue
        }
    }

    #input file name and start transfer {{{5}}}
    set oldmod [mystty -info]
    mycatch "stty -raw echo"

    if {$getput=="get"} {
        send_user "<<<CRTC:provide a remote file to download, and an (optional)\n"
        send_user "        local file name to save as: (seperated by spaces)\n"
    } else {
        send_user "<<<CRTC:provide a local file to upload, and an (optional)\n"
        send_user "        remote file name to save as: (seperated by spaces)\n"
    }
    #send_user "<<<CRTC:you have ${timeout}s to select your option ...\n"

    expect_user {
        -re "(\[^ ]+) +(\[^ ]+)\n" {

            #TODO: support shell glob, and , if only one localfile name was
            #given, append everything in it. otherwise, save accordingly
            set file_list [glob -nocomplain $expect_out(1,string)]

            if {$getput=="get"} {

                set remote_file $expect_out(1,string)
                set local_file "$download_folder/$expect_out(2,string)"
                send_user "downloading (remote) $remote_file to\
                    (local) $local_file\n"
                if [get_file $remote_file $local_file] {
                    send_user "sth gone wrong, input file names again!"
                    exp_continue
                }
            } else {
                set local_file "$download_folder/$expect_out(1,string)"
                set remote_file "$expect_out(2,string)"
                send_user "<<<CRTC:uploading (local) $local_file to\
                    (remote) $remote_file\n"
                if [put_file $local_file $remote_file] {
                    send_user "sth gone wrong, input file names again!"
                    exp_continue
                }
            }
        } -re "(\[^ ]+)\n" {

            #TODO: support shell glob, and , if only one localfile name was
            #given, append everything in it. otherwise, save accordingly
            set file_list [glob -nocomplain $expect_out(1,string)]

            set remote_file $expect_out(1,string)
            set local_file "$download_folder/$expect_out(1,string)"
            if {$getput=="get"} {
                send_user "<<<CRTC:downloading (remote) $remote_file to\
                    (local) $local_file\n"
                if [get_file $remote_file $local_file] {
                    send_user "sth gone wrong, input file names again!"
                    exp_continue
                }
            } else {
                send_user "<<<CRTC:uploading (local) $local_file to\
                    (remote) $remote_file\n"
                if [put_file $local_file $remote_file] {
                    send_user "sth gone wrong, input file names again!"
                    exp_continue
                }
            }
        } -re "\n" {
            if {$getput=="get"} {
                send_user "<<<CRTC:eh?\n"
            } else {
                #TODO: to search some files named "ROUTERNAME.." and provide options
                #set found_files \
                #  [exec find $download_folder -type f -print | grep $login_index]
                #if [llength $found_files] {
                #    send_user $found_files
                #    send_user "<<<CRTC:select a file to upload:"
                #} else {
                #    send_user "<<<CRTC:no local config files found"
                #}
            }
        }
    }

    eval stty $oldmod
}

proc get_file {infile outfile} {        ;#{{{4}}}
    global pattern_common_prompt login_index host2session
    global user_spawn_id
    set spawn_id $host2session($login_index)
    log_user 0
    set out [myopen $outfile w]
    if {$out == 0} {
        return 1
    }
    send_user "downloading\n\r"
    send "cat $infile\r"
    expect {
        #absorb the echoed "cat filename.txt" the 1st line
        -re "^(\[^\n]*)\r\n" {
            myputs "\ndiscard cmd line -$expect_out(1,string)-\r"
            #check the 2nd line, see if any error happened
            expect {
                -re "^(\[^\n]*)\r\n" {
                    switch -regexp -matchvar match -- $expect_out(1,string) {
                        "No such file"      {return 1}
                        default             {
                            if {$out != 0} { puts $out $expect_out(1,string) }
                            myputs "get 1st line -$expect_out(1,string)-"
                        }
                    }
                } 
                timeout {myputs "timeout @ 1st line"}
            }
        }
        timeout {myputs "timeout @ cmd line"}
    }

    set timeout 5
    set i 0;set j 0
    #exp_internal 1
    expect {
        -i $user_spawn_id -re ".+" { }
        -i $spawn_id
            #more lines before the last line
            -re "^(\[^\n]*)\r\n" {
                if {$out != 0} {puts $out $expect_out(1,string)}
                myputs "get a new line -$expect_out(1,string)-"

                #send a dot as progress indicator, every 10 lines
                incr i
                if {[expr $i / 100] > $j} {
                    incr j
                    send_user "."
                }

                exp_continue
            } 
            
            #the last line, sequence matters here. move this upward will have
            #issue
            -re "(^\[^\n]*)\r\n\[^\n]*$pattern_common_prompt" {
                myputs "get the last line -$expect_out(1,string)-" 0
                myputs "pattern_common_prompt is $pattern_common_prompt" 0
                if {$out != 0} { puts $out "$expect_out(1,string)" }
                send_user "."
                puts -nonewline "\r\nfile $outfile ([expr $i+2] lines) is saved!\n\r"
                close $out
            }

            timeout {
                puts "timeout(most probably transfer is done)!"
                close $out
            }
    }
    exp_internal 0
    send_user "\n"		;# after last "."
    log_user 1
    return 0
}

proc put_file {infile outfile} {        ;#{{{4}}}
    global pattern_common_prompt login_index host2session

    set spawn_id $host2session($login_index)
    log_user 0
    send_user "uploading\n"
    send "cat > $outfile\r"
    #if catching any error, return 1 (to repeat same procedure)
    if [catch {open $infile r} fp] {
        return 1
    }
    #set fp [open $infile r]
    #TODO: add error check
    #
    set i 0;set j 0
    while {1} {
        if {-1 == [gets $fp buf]} {
            break
        }

	incr i
	if {[expr $i / 100] > $j} {
	    incr j
	    send_user "."
	}

        send -- "$buf\r"
    }
    send_user "\n"			;# after last "."
    send "\004"				;# eof
    close $fp
    expect -re "$pattern_common_prompt"
    log_user 1
    return 0
}

proc chdir {} {         ;#{{{4}}}
    mycatch "stty -raw echo"
    send_user "c\n"
    send_user "current directory is [pwd], new directory: "
    expect_user -re "(.*)\n" {
        cd $expect_out(1,string)
    }
    mycatch "stty raw -echo"
}


proc interact_H {} {    ;#{{{3}}}
    global global_data; eval $global_data
    set hideinfo [expr !$hideinfo]
    puts "\nhideinfo $hideinfo"
    set options(hideinfo) $hideinfo
    set options_inline(hideinfo) $hideinfo
}

#proc interact_k {} {    ;#{{{3}}}
#    global global_data; eval $global_data
#    set exit_sync [!$expr_sync]
#    puts "\nexit_script_on_exit_session $exit_sync"
#    set options(exit_sync) $exit_sync
#    set options_inline(exit_sync) $exit_sync
#}

proc interact_o {} {    ;#{{{3}}}
    global global_data; eval $global_data
    set login_only [expr !$login_only]
    puts "\nlogin_only $login_only"
    set options(login_only) $login_only
    set options_inline(login_only) $login_only
}

proc interact_p {} {    ;#{{{3}}}
    global global_data; eval $global_data

    #if $persistent {
    #    set persistent 0
    #    set exit_sync $exit_sync_copy 
    #} else {
    #    set persistent 1
    #    set exit_sync 0
    #}
    #puts "\npersistent $persistent"
    #set options(persistent) $persistent
    #set options_inline(persistent) $persistent

    switch -exact -- $persistent {
        0 {
            set persistent 1
        } 1 {
            set persistent 2
        } 2 {
            set persistent 3
        } default {
            set persistent 0
        }
    }

    puts "\npersistent $persistent"

    set options(persistent) $persistent
    set options_inline(persistent) $persistent

}

proc interact_q {} {    ;#{{{3}}}
    global global_data; eval $global_data
    set nointeract [expr !$nointeract]

    puts "\nnointeract $nointeract"
    set options(nointeract) $nointeract
    set options_inline(nointeract) $nointeract
}

proc interact_N {} {    ;#{{{3}}}
    global global_data; eval $global_data
    upvar simple_interact simple_interact

    switch -exact -- $features {
        0       {
            set features 1
            set enable_user_patterns 3
            set simple_interact 0
            myputs3 "user pattern monitoring disabled\n"
        } 1       {
            set features 2
            set enable_user_patterns 3
            set simple_interact 0
            myputs3 "full feature interact\n"
        } 2 {
            set features 3
            set enable_user_patterns 3
            set simple_interact 0
            myputs3 "full feature interact\n"
        } 3     -
        default {
            set features 0
            set simple_interact 1
            myputs3 "simple (no feature) interact\n"
        } 
    }

    puts "features:$features enable_user_patterns:$enable_user_patterns"

    set options(features) $features
    set options_inline(features) $features
    set options(enable_user_patterns) $enable_user_patterns
    set options_inline(enable_user_patterns) $enable_user_patterns

}

set interact_v {    ;#{{{3}}}

    switch -exact -- $verbose {
        0       {
            set verbose 1
        } 1       {
            set verbose 0
        } 
    }

    puts "\nverbose:$verbose"

    set options(verbose) $verbose
    set options_inline(verbose) $verbose

}

proc interact_P {} {    ;#{{{3}}}
    global global_data; eval $global_data

    if {$parallel==1} {
        set parallel 2
    } elseif {$parallel==2} {
        set parallel 0
    } else {
        set parallel 1
    }
    puts "\nparallel $parallel"
    set options(parallel) $parallel
    set options_inline(parallel) $parallel
    return
}

proc interact_A {} {    ;#{{{3}}}
    #todo: currently just "assign" the session to others, 
    #no screen "sharing" at all. need to figure out why
    while 1 {
        puts "who do you want to consult with?";flush stdout;
        set expertname [gets stdin]

        mycatch "stty raw"
        puts "$expertname, you sure\[(y)es/(n)o\]?\[y\]";
        flush stdout;

        expect_user {
            "y" {
                myputs "current session looks $process"
                spawn kibitz -noproc -silent temptemp
                #spawn kibitz temptemp
                myputs "new kibitz session looks $spawn_id"
                interact -u $process -o "stop" {
                    close;wait;return
                }
                break
            }
            "\r" {
                #same as y
                break
            }
            "q" {
                puts "\n";break
            }
            "?" {
                puts "\n"
            }
        }
    }
}

#proc interact_K {} {    ;#{{{3}}}
#    proc mkfifo {f} {
#        if 0==[catch {exec mkfifo $f}] return		;# POSIX
#        if 0==[catch {exec mknod $f p}] return
#        # some systems put mknod in wierd places
#        if 0==[catch {exec /usr/etc/mknod $f p}] return	;# Sun
#        if 0==[catch {exec /etc/mknod $f p}] return	;# AIX, Cray
#        puts "Couldn't figure out how to make a fifo - where is mknod?"
#        abort
#    }
#    proc rmfifos {} {
#        global userinfile useroutfile
#        catch {exec rm -f $userinfile $useroutfile}
#    }
#    trap {rmfifos; exit} {SIGINT SIGQUIT SIGTERM}
#    
#    mkfifo $::userinfile
#    mkfifo $::useroutfile
#    exec chmod 666 $::userinfile $::useroutfile
#
#    spawn -open [open $::useroutfile w]
#    set userout $spawn_id
#
#    spawn -open [open "|cat < $::userinfile" "r"]
#    set userin $spawn_id
#
#    set kibitz 1
#}

proc interact_k {} {    ;#{{{3}}}

    global login_index env debug kibitz_shell_prompt
    global kibitz_list kibitz_user
    global kibitz_spawn_id2user user2kibitz_spawn_id
    global shell_list kibitz_kill_onfail process_input process_output
    global kibitz_list_ori kibitz_list inkibitz env

    if $inkibitz {
        send -i kibitz_list "please hold on while $env(USER) is trying to\
        invite more users...\r\n"
    }

    #change stty mode, seems not reliable...
    set oldmode [mystty -info]
    myputs "original stty mode is $oldmode"
    mystty raw echo
    #set newmode [mystty -info]
    #myputs "new stty mode is $newmode"


    set timeout 30
    send_user "
    - invite a user to share your current terminal session?\[lrq<ENTER>\]
    (l)ocal user: press \"l\" or just hit enter
       - send invitation to a user in local server (where crtc script was started) 
    (r)emote user:press \"r\"
       - spawn a new shell and from which you can login to remote host and then send
       invitation to a user in that host
    (q)uit: press \"q\"
       - quit and return back to current session
    (i)nfo: display current kibitz status\n"

    expect_user {
        -re "l|\r"      invitelocal
        r               inviteremote
        q               {}
        i               {
            if $inkibitz {
                send_user "in kibitz!"
            } else {
                send_user "not in kibitz!"
            }
            send_user "shell_list: $shell_list: kibitz_list: $kibitz_list"
            send_user "kibitz_list_ori: $kibitz_list_ori:current sid:$spawn_id"
        }
        "\\?" {
            send_user "?\n"
            send_user "l  invite a local user\n"
            send_user "r  invite any user\n"
        }
        -re . {send_user "<<<CRTC:unknown command\n"}
        timeout {
            send_user "no valid user selection in ${timeout}s..."
        }
    }
    #send_user "\n<<<CRTC:resuming session of $login_index...\n"
    
    #recover original stty mode
    #mystty $oldmode

    send_user "\n"

}

proc inviteremote {} {        ;#{{{4}}}
    global login_index env debug kibitz_shell_prompt
    global kibitz_list kibitz_user
    global kibitz_spawn_id2user user2kibitz_spawn_id
    global shell_list kibitz_kill_onfail process_input process_output
    global kibitz_list_ori kibitz_list inkibitz kibitz_user_list 
    global sid2user sid2typing user_spawn_id host2session session2host
    set kibitz_user ""
    set tty1 ""

    #select a shell {{{5}}}
    #first session is router, from 2nd is newly spawned shell
    if {[llength $shell_list] == 1} {
        puts "no free shell available, will spawn one..."
        interact_y
        return
    }

    #code to verify if kibitz succeed {{{5}}}
    #set verify_kibitz {
    #    set kibitz_shell_prompt $interact_out(1,string)
    #    myputs "kibitz_shell_prompt detected as -$kibitz_shell_prompt-" 0
    #    set kibitz_user $interact_out(2,string)
    #    myputs "kibitz target user:$kibitz_user.." 0

    #    #assume that other user normally will accept in 2m
    #    set timeout 20
    #    #kibitz succeeded if Escape message seen 
    #    expect {
    #        -re "Escape sequence is \\^\\\]" {
    #            send_user "kibitz succeeded! type \\\\ to start sharing!\n"
    #            set inkibitz 1
    #        }
    #        timeout {
    #            send_user "kibitz not succeed in ${timeout}s! try again later..\n"
    #            exp_send "[CONST CTRL_C]\r"
    #        }
    #    }
    #}

    #verify if currently in a new shell {{{5}}}
    if [in $process_input [lrange $shell_list 1 end]] {
        #if yes, remember it for later interact
        set spawn_id $process_input
    } else {
        #if not, tell user to select a shell
        puts "you are still in the session to be shared, to share this\
            session, you need to switch to a shell.\n\
            type \\l to list available shells; \\NUMBER to select one"
        return
    }

    #get user name and tty {{{5}}}
    send_user "who to invite on this server?\n"

    catch {set oldmode [stty -raw echo]}

    set timeout 120

    expect_user {
        -re "(\[^ ]+) +(\[^ ]+)\n" {
            set kibitz_user $expect_out(1,string)
            set tty1  "-tty $expect_out(2,string)"
            send_user "will invite $kibitz_user on $tty1 ...\n"
        }
        -re "(\[^ ]+)\n" {
            set kibitz_user $expect_out(1,string)
            set tty1 ""
            send_user "will invite $kibitz_user ...\n"
        }
        -re "\n" {
            send_user "<<<CRTC:eh?\n"
            return
        }
        timeout {
            send_user "you didn't type any user name in $timeout second...\n"
            return
        }
    }

    #detect a prompt {{{5}}}
    #
    #this is complicated, and not right. this only record prompt of
    #initial local shell but user can login to a remote machine and
    #start kibitz from there in the latter case, we need to record
    #prompt at the time just before kibitz cmd started, so when the
    #other user exit, we'll get such a prompt.  and we can then use
    #that very prompt to detect that disconnect situation.
    #
    #myputs "detecting kibitz shell prompt now.."
    #set kibitz_shell_prompt ""
    #set timeout 1
    #expect -i $kibitz_list -re ".+" exp_continue
    #send -i $kibitz_list "\r"
    #myputs "expect a shell prompt..."
    #expect -i $kibitz_list -re "\r\n(\[^\n]+)$" {
    #    set kibitz_shell_prompt $expect_out(1,string)
    #    myputs "kibitz_shell_prompt detected as -$kibitz_shell_prompt-"
    #}

    #a simpler method: send a return and collect the output
    #interestingly, this send-expect interaction won't display in the screen,
    #being absorbed?
    #
    #force echo, this is to prevent expect sticking under noecho mode
    send "stty echo\r"
    send "\r"
    expect -re "\r\n(\[^\r]+)$" {
        set kibitz_shell_prompt $expect_out(1,string)
        myputs "original shell prompt before kibitz looks -$kibitz_shell_prompt-"
    }

    #disable echo {{{5}}}
    #to prevent loop on non-detected disconnection. will need to recover back
    #(stty echo) on the shell later if need to type any commands manually...
    send "stty -echo\r"

    #send invitation {{{5}}}
    #same as above, this send-expect interaction won't display in the terminal
    #being aborbed?
    send "kibitz -noproc $tty1 $kibitz_user\r"

    #detect kibitz result {{{5}}}
    #
    #assume that other user normally will accept in some timeout
    set timeout 40

    #kibitz succeeded if Escape message seen 
    expect {
        -i $spawn_id
            "is not logged in" {
                send_user "$kibitz_user is not logged in yet, check and\
                    try again later!"
                set inkibitz 0
            }
            -re "Escape sequence is \\^\\\]" {

                send_user "kibitz succeeded!\n"

                #recover process sid to original shell to be shared
                set process_input [arrayvalue host2session]
                set process_output [arrayvalue host2session]

                #save current shell in backup kibit_list
                lappend kibitz_list_ori $spawn_id
                set kibitz_list $kibitz_list_ori
                set sid2user($spawn_id) $kibitz_user
                set sid2typing($spawn_id) 0

                #remove current shell from shell_list if kibitz succceed, 
                ldelete shell_list $spawn_id
                #set shell_list [lreplace $shell_list 0 0 $kibitz_list]

                myputs "shell_list: $shell_list: kibitz_list: $kibitz_list" 0
                myputs "kibitz_list_ori: $kibitz_list_ori:current sid:$process_input" 0

                set inkibitz 1

                #set user2kibitz_spawn_id($kibitz_user) $kibitz_list
                #set kibitz_spawn_id2user($kibitz_list) $kibitz_user

                send -i $kibitz_list "session $login_index is being shared between\
                    \[$kibitz_user_list\] now...\n"
                send -i $kibitz_list "to exit, type ctrl+\], and then \"exit\""

            }
            timeout {
                set inkibitz 0
                send_user "kibitz not succeed in ${timeout}s! you can try\
                    again later..\n"
                exp_send "[CONST CTRL_C]\r"
            }
        -i $user_spawn_id
            #press anykey (including ctrl-c that people used to) to stop
            #awaiting (but, yet not to terminate the whole crtc)
            -re ".+" {
                send_user "invitation cancelled!\n"
                #TODO: need to kill the onging kibitz
                #send "kill [pid]"
                #set timeout 3
                #exp_continue -continue_timer
                #recover current sid back to orignal shell
                #set process_input [arrayvalue host2session]
                #set process_output [arrayvalue host2session]
            }
    }

    #if kibitz not succeed, also close the kibitz shell
    #TODO: this needs some enhancement:
    #   how about not close, but save them for late use 
    #   (say, come back to where leftoff and retry)
    
    #if $kibitz_kill_onfail {
    #    if {$inkibitz==0} {
    #        send_user "closing the spawned shell/$kibitz_shell_pid..."
    #        set kibitz_list ""
    #        close;wait
    #    }
    #}

    #return

    ##monitor kibitz cmd
    ##seems not an efficient way ... put everything in \\ may be better
    ##
    ##monitor if user started kibitz, and capture the user name
    ##-nobuffer -re "\r\n(\[^\r\]+)kibitz\\s+-noproc\\s+(\\S+)\r\n" {}
    #-nobuffer -re "kibitz\\s+-noproc\\s+(\\S+)\r\n" {
    #    eval $verify_kibitz
    #}

    ##-nobuffer -re "kibitz\\s+-noproc\\s+-tty\\s+(\[^\r\]+)\r\n" {}
    #-nobuffer -re "kibitz\\s+-noproc\\s+-tty\\s+\\S+\\s+(\\S+)\r\n" {
    ##try to capture a prompt and a cmd line
    ##-nobuffer -re "\r\n(\[^\r\]+)kibitz\\s+-noproc\\s+-tty\\s+\\S+\\s+(\\S+)\r\n" {}
    #    #match to "kibitz -noproc -tty ttyri pings\r\n"
    #    eval $verify_kibitz
    #}

    #myputs "exit interact of kibitz shell...\n"
}

proc invitelocal {} {           ;#{{{4}}}
    global login_index kibitz_user
    global kibitz_spawn_id2user user2kibitz_spawn_id
    global kibitz_list kibitz_list_ori
    global shell_list inkibitz kibitz_user_list 
    global sid2user sid2typing
    set kibitz_user ""
    set tty1 ""

    send_user "\nwho are you going to invite?\n"
    
    set oldmode [mystty -info]
    catch {mystty -raw echo}

    set timeout 120
    #expect_user {
    #    -re "(\\w+)" {

    #        set kibitz_user $expect_out(0,string)
    #        #send_user "you want to invite $kibitz_user..\n"

    #        #these code are used to detect if user is online,
    #        #it works, but since kibitz has its own prompt when user is not
    #        #online, so simply detecting that seems a better way...
    #        #
    #        #if [exec w -h $kibitz_user | wc -l] {
    #        #    #just continue
    #        #    send_user "$kibitz_user is online ..\n"

    #        #} else {
    #        #    #when grep got no match, it will exit abnormally and will be
    #        #    #catched

    #        #    send_user "user $kibitz_user haven't logged in yet!\n"
    #        #    send_user "(c)ontinue/(q)uit/try connect (o)ther users ...\n"

    #        #    set selection ""
    #        #    mystty raw echo
    #        #    expect_user {
    #        #        "c" {
    #        #            
    #        #        }
    #        #        "o" {
    #        #            set selection "o"
    #        #        }
    #        #        "q" {
    #        #            return
    #        #        }
    #        #    }

    #        #    if [string equal $selection "o"] {
    #        #        send_user "\nwho are you going to invite ?\n"
    #        #        mystty -raw echo
    #        #        exp_continue
    #        #    }
    #        #}
    #    }
    #    timeout {
    #        send_user "you didn't type any user name in $timeout second...\n"
    #        return
    #    }
    #}

    expect_user {
        -re "(\[^ ]+) +(\[^ ]+)\n" {
            set kibitz_user $expect_out(1,string)
            set tty1  "-tty $expect_out(2,string)"
            send_user "will invite $kibitz_user on $tty1 ...\n"
        }
        -re "(\[^ ]+)\n" {
            set kibitz_user $expect_out(1,string)
            send_user "will invite $kibitz_user ...\n"
        }
        -re "\n" {
            send_user "<<<CRTC:eh?\n"
            return
        }
        timeout {
            send_user "you didn't type any user name in $timeout second...\n"
            return
        }
    }

    #set kibitz_pid [spawn kibitz -noproc $kibitz_user]

    if ![string equal $tty1 ""] {
        eval spawn "kibitz -noproc $tty1 $kibitz_user"
    } else {
        eval spawn kibitz -noproc $kibitz_user
    }

    set timeout 30
    expect {
        "is not logged in" {
            send_user "$kibitz_user is not logged in yet, check and\
                try again later!"
            set inkibitz 0
        }
        #-re "Escape sequence is \\^\\\]|\\\$" {}
        -re "Escape sequence is \\^\\\]" {
            send_user "kibitz succeeded!\n"
            lappend kibitz_list_ori $spawn_id
            set kibitz_list $kibitz_list_ori
            lappend kibitz_user_list $kibitz_user
            set sid2user($spawn_id) $kibitz_user
            set sid2typing($spawn_id) 0

            send -i $kibitz_list "session $login_index is being shared between\
                $kibitz_user_list now...\r\n"

            myputs "shell_list: $shell_list: kibitz_list: $kibitz_list"
            myputs "kibitz_list_ori: $kibitz_list_ori"
            set inkibitz 1
        }
        eof {
            send_user "got eof immediately!"
            #lappend shell_list $kibitz_list
            #ldelete kibitz_list $interact_out(spawn_id)
            #set kibitz_list_ori [set kibitz_list]
            #set kibitz_list ""
            set inkibitz 0
        }
        timeout {
            send_user "user $kibitz_user didn't ack in ${timeout}s...\n"
            set inkibitz 1
        }
    }
}

proc interact_y {} {    ;#{{{4}}}
    #generate a local new shell
    global env shell_list 
    global process_input process_output

    set shell_pid [spawn -noecho $env(SHELL)]
    send_user "spawned new shell\[$shell_pid\]...\n"
    send_user "press \\l to list, \\NUMBER to switch into a session\n"
    lappend shell_list $spawn_id

    #stay on the new shell after creation
    set process_input $spawn_id
    set process_output $spawn_id

}

set interact_n {     ;#{{{4}}}
    #generate a local new shell
    global env shell_list 
    global process_input process_output

    set shell_pid [spawn -noecho $env(SHELL)]
    send_user "spawned new shell\[$shell_pid\]...\n"
    send_user "press \\l to list, \\NUMBER to switch into a session\n"
    lappend shell_list $spawn_id

    #stay on the new shell after creation
    set process_input $spawn_id
    set process_output $spawn_id

    #TODO: not done yet
    spawn_login "$router.clone"

}

#using eval is much more handy
#avoiding uplevel, global things...
#proc interact_timeout {} {      ;#{{{3}}}
#    global global_data;eval $global_data
#    global argc login_index
#
#    uplevel {myputs "timeout after ${anti_idle_timeout}s"}
#    uplevel {myputs "will send $anti_idle_string to $session2host($process)"}
#
#    #this doesn't work, since the configparser may changed whatever
#    #  control char (e.g \177) to literal " \ 7 7 "...
#    #send -i $process $anti_idle_string
#    #this works:
#    uplevel {
#        #sometime send a null might be better and general solution
#        #send -i $process -null
#        send -i $process [subst [string trim $anti_idle_string '"']]
#    }
#    #foreach host $hostlist_full {reload_data $host}
#    
#    #TODO:
#    #check a certain file mtime, if changed, then read the content and send
#    #as a command
#    #capture output and write it back
#    #set mtime [file mtime .crtc_cmd] 
#    #if {$mtime!=$mtime_prev} {
#    #}
#
#    #run scheduler only if run crtc without an arguments: crtc
#    if !$argc {
#        reload_data $login_index
#        do_pag LOCALHOST scheduled_event cmd_output_array_scheduled_event 
#    }
#}

#interact_timeout {{{3}}}
set interact_timeout {      

    #compare user/proc timeout {{{4}}}
    #use the minimum of the two time:
    if {$anti_idle_timeout_user_input > $anti_idle_timeout_proc_input} {
        set anti_idle_timeout $anti_idle_timeout_proc_input
        set user_timeout 0
        myputs "process timeout after ${anti_idle_timeout}s "
    } elseif {$anti_idle_timeout_user_input < $anti_idle_timeout_proc_input} {
        set anti_idle_timeout $anti_idle_timeout_user_input
        set user_timeout 1
        myputs "user timeout after ${anti_idle_timeout}s "
    } else {
        set anti_idle_timeout $anti_idle_timeout_user_input
        set user_timeout 1
        myputs "user and proc both timeout after ${anti_idle_timeout}s "
    }

    #send anti_idle_string when timeout {{{4}}}
    #this works:
    #sometime send a null might be better and general solution
    #send -i $process -null
    #send -i $process [subst [string trim $anti_idle_string '"']]
    #
    #this doesn't work because of configparser - may changed whatever
    #  control char (e.g \177) to literal " \ 7 7 "...
    #(2016-06-19) works after fixed confgparser issue...
    myputs "will send -$anti_idle_string- as KA to $session2host($process)"
    #set oldmode [mystty -info]
    #puts "current tty mode looks $oldmode"
    log_user 0

    #to support multiple hosts
    foreach onehost $hostlist_full {
        set process $host2session($onehost)
        if [string equal $anti_idle_string "null"] {
            send -i $process -null
        } else {
            send -i $process "$anti_idle_string"
        }
    }
    log_user 1

    #if $type_to_disable_features {      ;#{{{4}}}
    #    myputs "recover back features $features_ori" 0
    #    if !$timeoutd {
    #        myputs2 "\r\nrecover back original interact"
    #    }
    #    set simple_interact 0
    #    set timedout 1
    #    return
    #}

    #mode switch (enable_user_patterns based)       ;#{{{4}}}
    #switch to original mode and send prompt msg, only when necessay
    if {$enable_user_patterns != $enable_user_patterns_ori} {

        if !$timedout {
            if $user_timeout {
                #only print these under "verbose", sometime its good to not send.
                myputs2 "\r\nuser timeout after ${anti_idle_timeout}s,"
            } else {
                myputs2 "\r\nprocess timeout after ${anti_idle_timeout}s,"
            }
            set timedout 1
        }

        #set enable_user_patterns 3
        
        #no need after introduced code block AAA
        #recover whatever configured originally
        #set enable_user_patterns $enable_user_patterns_ori
        #if {$enable_user_patterns == 2 || $enable_user_patterns == 3} {
        #    #only print these under "verbose", sometime its good to not send.
        #    myputs2 "switched to original (monitoring) mode\n"
        #} else {
        #    myputs2 "switched to original mode\
        #        (enable_user_patterns $enable_user_patterns_ori)!\n"
        #}


        #here return serves to start a new interact after refreshed options.
        #no need if nothing changed.
        #return
    }

    #foreach host $hostlist_full {reload_data $host}
    
    #TODO:
    #check a certain file mtime, if changed, then read the content and send
    #as a command
    #capture output and write it back
    #set mtime [file mtime .crtc_cmd] 
    #if {$mtime!=$mtime_prev} {
    #}

    #no need after introduced code block AAA
    ##mode switch (features based) {{{4}}}
    #if !$features {
    #    myputs "change features from $features to $features_ori on timeout"
    #    set features $features_ori
    #    return
    #}

    #code block AAA: copied from interact_simple
    if {($features_ori == 2) && ($features == 1 )} {
        #if original features set to 1, but currently changed to 0
        #then when timeout, change it to 3
        myputs "original feature was $features_ori and was \
            changed to $features, "
        myputs "set to 3 on timed out..."
        myputs2 "\r\nuser timeout after ${anti_idle_timeout}s,"
        myputs2 "\r\nswitched back to original (monitoring) mode\n"
        set features 3
        set enable_user_patterns $enable_user_patterns_ori
        return
    }


    #
    #scheduler {{{4}}}
    #run only if run crtc without an arguments: crtc
    if !$argc {
        reload_data "LOCALHOST"
        do_pag LOCALHOST scheduled_event cmd_output_array_scheduled_event 
    }
}

proc interact_D {} {    ;#{{{3}}}

    uplevel {set cmd_output $buf_out}
    uplevel {set buf_out ""}
    uplevel {send_user "\ncmd input:\[$cmd_input\]!\n"}
    uplevel {send_user "\ncmd output:\[$cmd_output\]!\n"}

}

proc interact_E {} {    ;#{{{3}}}
    uplevel {set user $env(USER)}
    #uplevel {set user pings               ;#for testing only}
    #uplevel {set domainname "juniper.net" ;#for testing only}
    uplevel {set emailto $user@$domainname}
    uplevel {sendanemail $log_fullname $emailto}
    uplevel {myputs2 "log file $log_fullname was sent to $user\n"}
}

proc interact_O {} {    ;#{{{3}}}
    global config_file hostlist_full

    if {($config_file != "NONE") && [file exists $config_file]} {
        send_user "reload the configs..."
        myputs "sourcing config file $config_file"
        #eval $config_default
        #source $config_file
        foreach host $hostlist_full {reload_data $host}
        ##apply options after sourcing config, to secure debug setting
        #foreach opt [array name options_cli] {
        #    set $opt $options_cli($opt)
        #    myputs "set $opt $options_cli($opt)" 3
        #}
        send_user "\r\nconfig file reload done.."
    } else {
        puts "no config file (or \"NONE\" was used) to load"
    }
}

proc interact_R {} {    ;#{{{3}}}
    global sigquit myinteract_depth
    if $sigquit {
        puts "there is no unfinished automation task!"
    } else {
        if {$myinteract_depth>1} {
            myputs "interact depth $myinteract_depth, \
                return to upper level"
            incr myinteract_depth -1
            puts "\nresuming previous automations ..."
            return 1
        } else {
            puts "\nthere is no automation to continue..."
            myputs "interact depth 0, won't return"
        }
    }
}

proc interact_s {} {    ;#{{{3}}}
    global global_data; eval $global_data

    incr myinteract_depth -1
    puts "top unfinished automations!"

    if {$myinteract_depth>1} {
        set automation_non_complete_msg "\nyou have \
            unfinished automations (stack $myinteract_depth)!\n\
            press !R to continue, ^\\ or !s to stop, !Q to quit"

    } else {
        set automation_non_complete_msg ""
    }

    set options(automation_non_complete_msg) \
        $automation_non_complete_msg
    set options_inline(automation_non_complete_msg) \
        $automation_non_complete_msg

    #set sigquit 1
    #set automation_non_complete_msg ""
}

proc interact_plus {} {         ;#{{{3}}}
    global global_data; eval $global_data

    incr interval_cmds 1
    send_user "                                         \r"
    send_user "cmds interval increased to $interval_cmds\r"

    set options(interval_cmds) $interval_cmds
    set options_inline(interval_cmds) $interval_cmds
    return
}

proc interact_minus {} {        ;#{{{3}}}
    global global_data; eval $global_data

    incr interval_cmds -1
    send_user "cmds interval increased to $interval_cmds\r"
    send_user "                                         \r"

    set options(interval_cmds) $interval_cmds
    set options_inline(interval_cmds) $interval_cmds
    return
}

proc send_routers { router_cmds_array } { ;#{{{2}}}
    global debug 
    global cmd_output_array_$router_cmds_array
    upvar $router_cmds_array p_router_cmds_array
    if [array exists p_router_cmds_array] {
        if $debug {myputs "will execute the router-cmds-array:\"$router_cmds_array\" \
            for routers:[array names p_router_cmds_array]"
        }
        if $debug {send_log "will execute the router-cmds-array:\"$router_cmds_array\" \
            for routers:[array names p_router_cmds_array]...\n"
        }
        foreach router [array names p_router_cmds_array] {
            set cmd_list $p_router_cmds_array($router)

            set pa_pair 0
            foreach cmd $cmd_list { ;#if any cmd contains special CH, 
                #treat it as a pattern(prompt)
                if [regexp "#|>|%" $cmd] {set pa_pair 1} 
            }
            
            if $pa_pair { ;#use diff method to handle 
                if $debug {
                    myputs "cmds list contains prompt-looking strings, 
                        go pattern-action mode!"
                }
                #send a return to kick off
                myexpect $router ".*" "" 0
                #pattern-data pairs: ">" "show "
                do_patterns_actions $router p_router_cmds_array 
            } else {   ;#or just pure data:  "show1 " "show2 "
                if $debug {
                    myputs "executing \"$router_cmds_array\" for router:\"$router\""
                }
                send_cmds $router p_router_cmds_array cmd_output_array_\
                    $router_cmds_array
            }
        }
    } else {
        if $debug {myputs "array \"$router_cmds_array\" not configured, skipping"}
    }
}

proc switchover {router {hold_interval 300} {su_password Juniper}} { ;#{{{2}}}

    global debug session2host host2session spawn_id 
    global pattern_gres_not_ready pattern_gres_success

    set process $host2session($router)

    myputs "send an initial cr"
    exp_send -i $process "\r"
    myexpect $router "> $" "request chassis routing-engine master switch" 60 0 0

    #this doesn't work, really strange...
    #exp_internal 1
    #myexpect $router "\\\[yes,no\\\] (no)" "yes" 60 0 0

    #this works
    #with user_patterns, this won't get match, so may cause issue
    #merge this into below expect clause and exp_continue
    #expect -i $process "\\\[yes,no\\\] (no)" { send -i $process "yes\r"}

    set timeout 60
    expect {
        #Complete. The other routing engine becomes the master.
        #-re "\{backup\}\s+.*-re\[01]>" 
        #-re "\{backup\}\r\n.*-re\[01]>" 
        #-re "The other routing engine becomes the master.\r\n\r\n{backup}\r\n.*-re\[01]>"
        -i $process -re $pattern_gres_success {
            myputs "\[great! will exit current process...\]"
            #send -i $process "exit\r"
            #myexpect $router "> $" "exit" #<---this will make ssh client exit, so expect exit
            return "RETURN_GRES_SUCCESS"
        }
        
        -i $process "\\\[yes,no\\\] (no)" { 
            send -i $process "yes\r"
            exp_continue
        }
        #-re "\{master\}\s+.*-re\[12]>" 
        #-re "\{master\}\r\n.*-re\[01]>" 
        -i $process -re $pattern_gres_not_ready {
            #if $debug {myputs "$expect_out(buffer)\r"}
            set switchover_countdown 240
            regexp {.*try after (.*) secs.*} $expect_out(buffer) -> switchover_countdown
            #if $debug {myputs "\[script:ops! sorry...will redo
            #${switchover_countdown}s later then...\]"}
            puts "\[crtc:oops! sorry...will redo \
                [expr $switchover_countdown + 1]s later then...\]"
            if {$switchover_countdown <= $hold_interval} {
                #wait and graceful switchover
                switchover_countdown $switchover_countdown
                switchover $router $hold_interval $su_password

                return "RETURN_GRES_SUCCESS"

            } else {
                if $debug {
                    myputs "\[crtc:required switchover interval time          \
                    left(${hold_interval}s) is less than CLI protection         \
                    interval(${switchover_countdown}s left), will force rpd     \
                    restart after $hold_interval seconds...\]"}
                mysleep $hold_interval
                #force rpd core and switchover
                restart_rpd $router $su_password
                return "RETURN_GRES_FORCE_RPD"
            }
        }

        #this won't catch: closed -> spawned proc exit -> no way to expect
        -i $process -re "closed by foreign host" {
            myputs "no problem, will re-login again!"
            return "RETURN_GRES_SESSION_CLOSED"
        }

        -i $process -re "Failed" {
            myputs "GRES failed!"; exit 4
            return "RETURN_GRES_FAILED"
        }

        timeout {
            puts "timeout after ${timeout}s"
            myputs "something unexpected happened, exit"
            return "RETURN_GRES_TIMEOUT"
        }
    }
}

proc switchover_countdown {switchover_countdown} { ;#{{{2}}}
    global debug
    incr switchover_countdown 1
    puts "\[crtc:will count $switchover_countdown seconds and retry...\]"
    if {$switchover_countdown >= 30} {
        incr switchover_countdown -30
        mysleep $switchover_countdown
        #if $debug {myputs "\[crtc:just 30 more seconds to wait...\]"}
        myputs "\[crtc:just 30 more seconds to wait...\]"
        #mysleep $switchover_countdown
        mysleep 30
    } else {
        mysleep $switchover_countdown
    }
}

proc restart_rpd {router su_password} { ;#{{{2}}}
    global debug session2host host2session
    set process $host2session($router)

    if $debug {myputs "start restarting rpd now!"}
    exp_send -i $process "\r"
    exp_send -i $process "start shell\r"
    myexpect $router "% $"        "su"                  0
    myexpect $router "Password:$" "$su_password"        0
    myexpect $router "% $"        "uptime\r"            0
    myexpect $router "% $"        "ps aux | grep rpd\r" 0
    expect -i $router -re "root\\s+(\\d+)\\s+.*sbin/rpd.*$" {
        set rpd_pid $expect_out(1,string)
        send -i $process "pwd\r"
        exp_send -i $process "kill -11 $rpd_pid\r"
    }
    expect -i $process -re "% $"
}

proc restart_process {router process su_password {jnpr123}} { ;#{{{2}}}
    global debug session2host host2session
    global pa_pair
    set process $host2session($router)

    if $debug {myputs "start restarting $process now!"}
    #exp_send -i $process "\r"
    #exp_send -i $process "start shell\r"
    #myexpect $router "% $"        "su"                  0
    #myexpect $router "Password:$" "$su_password"        0
    #myexpect $router "% $"        "uptime\r"            0
    myexpect $router "(%|#) $" "ps aux | grep $process\r" $pa_pair
    #root    55710   0.3  0.3  119004  58440  8- S     7:44AM     0:25.94 dtrace -s /v
    expect -i $router -re "root\\s+(\\d+)\\s+.*$process.*$" {
        set pid $expect_out(1,string)
        #send -i $process "pwd\r"
        exp_send -i $process "kill -11 $pid\r"
    }
    #expect -i $process -re "(%|#) $"
}

#proc get_output {cmd_output_array router cmd}
proc get_output {cmd_output_array router cmd_id} { ;#{{{2}}}
    upvar $cmd_output_array p_cmd_output_array
    #return "[lindex [array get p_cmd_output_array $router*$cmd*] 1]"
    return "[lindex [array get p_cmd_output_array $router,$cmd_id,*] 1]"
}

#proc get_index {cmd_output_array router cmd}
proc get_index {cmd_output_array router cmd_id} { ;#{{{2}}}
    #get the index of data array
    global debug
    upvar $cmd_output_array p_cmd_output_array
    #set key [lindex [array get p_cmd_output_array *$cmd*] 0]
    myputs "get_index:$cmd_output_array looks:\n[array get p_cmd_output_array]\n" 3
    #myputs "use -$router- and -$cmd- to get a key\n" 3
    myputs "use -$router- and -$cmd_id- to get a key\n" 3
    #set key [lindex [array get p_cmd_output_array $router*$cmd*] 0]
    set key [lindex [array get p_cmd_output_array $router,$cmd_id*] 0]
    myputs "get_index:get a key as $key\n" 3
    #why delete "?
    #set key [string map [list \" "" $cmd ""] $key]
    #set key [string map [list $cmd "" \" ""] $key]
    #set pattern "$router,(\\d+),,(\\d+)"
    myputs "get_index:get a key as $key\n" 3
    #if [regexp $pattern $key -> id time]
    #example: regexp {.*try after (.*) secs.*} $expect_out(buffer) -> switchover_countdown
    set pattern "$router,$cmd_id,(.*),(\\d+)$"
    if [regexp $pattern $key -> cmd time] {
        return [list $cmd $time]
    } else {
        if $debug {
            myputs "can't find record of #$cmd_id cmd from router -$router-!"
            myputs "cmd_output_array $cmd_output_array looks"
            parray p_cmd_output_array
            myputs "key is $key"
        }
        
        return 0
    }
}

proc persist_login {login_script router args} { ;#{{{2}}}

    global debug session2host host2session 
    if {$debug>1} {myputs "$login_script $router $args"}
    if {$args!=""} {                            ;#there are extra options_cli
            set username [lindex $args 0]       ;#take them as user/pass
            set password [lindex $args 1]
            spawn -noecho $login_script $router $username $password
    } else {                                    ;#otherwise use default(lab/hernon1)
        spawn -noecho $login_script $router
    }
    if {$debug>1} {myputs "spawn_id of persist_login is $spawn_id"}
    expect {
        -i $spawn_id -re "> $" {
            #once got the "> "prompt, start to ignore whatever comes after that
            #within 3s (attn might send some pre-commands once logged in)
            if {$debug>1} {
                myputs "hold 3s before proceed (wait until output all dumped)"
            }
            set timeout 3
            expect -i "$spawn_id" -re ".+" exp_continue

            set session2host($spawn_id) $router
            set host2session($router) $spawn_id
            #if $debug {
            #    myputs "spawn id for $router is $spawn_id"
            #    myputs "host2session now looks [array get host2session]"
            #}

            return $spawn_id
        }
        #with persist feature added in login script, seems no need to duplicate
        #from here
        -i $spawn_id "Unable to connect to remote host: Connection timed out" {
            persist_login $login_script $router
        }
        -i $spawn_id "Connection closed by foreign host" {
            persist_login $login_script $router
        }
        -i $spawn_id default         {
            myputs "get eof/timeout, retry"
            mysleep 2
            persist_login $login_script $router
        }
    }
}

proc check_flag {cmds {flag_check_method 1}} { ;#{{{2}}}

    myputs "==>entering check_flag"
    #iterate each cmd in cmd_list, populate the data/time info 
    #  in cmd_output_array global array
    #iterate the array and execute the corresponding hander for each cmd
    #  to check the issue
    global cmd_output_array_$cmds cmd_output_array_${cmds}_prev
    global cmd_output_array_pre_$cmds cmd_output_array_post_$cmds
    global rule_calc rule_msg debug code_init_template
    global data dataformat datafile cmd_id all_met hostlist_full
    #global regex vars options_cli issue
    upvar $cmds p_cmds
    #global check_flag

    #run handler for each cmd on each router
    #build a result_flag(router,cmd_id) structure ,0 or 1
    #foreach router [array names p_check] {}
    foreach router $hostlist_full { ;#{{{3}}}
        set i 1
        #foreach cmd    ;#{{{4}}}
        foreach cmd $p_cmds($router) {
            #this is not portable : lassign is only supported in 8.5+
            #lassign [get_index cmd_output_array $router $cmd] cmd_id time_now

            #set cmd_id [lindex [get_index cmd_output_array_$cmds $router $cmd] 0]
            set cmd_id $i
            set cmd_1 [lindex [get_index cmd_output_array_$cmds $router $cmd_id] 0]
            #set time_now [lindex [get_index cmd_output_array_$cmds $router $cmd] 1]
            set time_now [lindex [get_index cmd_output_array_$cmds $router $cmd_id] 1]
            myputs "use cmd# $i of cmd:\n-$cmd-\n\
                from cmds array $cmds (router $router), \
                to retrieve cmd:\n-$cmd_1-\nand time info:$time_now \
                from cmd_output_array:cmd_output_array_$cmds \n" 2

            set handler ${cmds}_${router}_$cmd_id

            #if handler process defined, call it to parse issue
            #set result_flag only if proc was defined
            #if static proc exists {{{5}}}
            if {[info procs $handler]!=""} {    
                if $debug {send_log "call handler $handler to process this \
                    cmd for router $router\n"}
                myputs "handler $handler defined"
                myputs "call handler \"$handler\" to parse this cmd for router
                    \"$router\""
                set result_flag($router,$i) [$handler $router $cmd]

                #formatting and export data
                #myputs "[format "$format" $data1 $data2]" $datafile
                if [info exists dataformat] {
                    myputs "$router,$time_now,[eval format $dataformat $data]" $datafile
                }
            } else { 
                #otherwise ;#{{{5}}}
                #otherwise, look for handler_code var, and compose a handler
                #process automatically based on the code
                myputs "handler proc \"$handler\" not defined in the config file!"

                global code_${router}_$cmd_id

                #there is "dynamic" proc {{{6}}}
                #    meaning: var "code_ROUTER_CMDID" was defined, so try to
                #    compose a full functional proc based on that
                if [info exist code_${router}_$cmd_id] {
                    myputs "but,cmds code \"code_${router}_$cmd_id\" \
                        defined, so composing a handler proc \"$handler\" \
                        based on that.."

                    #substitude code_init_template {{{7}}}
                    #regsub -all {cmds1} $code_init_template "\{$cmds\}" init_$cmds
                    regsub -all {cmds1} $code_init_template "$cmds" init_$cmds


                    #compose proc based on the user's code {{{7}}}
                    set handler_proc    "proc ${cmds}_${router}_$cmd_id \{router cmd \{var1 400\}\} \{\n"
                    append handler_proc "global init_$cmds\n"
                    append handler_proc "global global_data;eval \$global_data\n"
                    append handler_proc "global data dataformat datafile\n"
                    append handler_proc "global regex vars vars_prev options_cli\n"
                    append handler_proc "global issue_info regex_info cmd_id\n"
                    append handler_proc "global regex4onecmd issue4onecmd\n"
                    append handler_proc "[set init_$cmds]\n"
                    #append handler_proc "for \{set i 0\} \{\$i<\$cout_llen\} \{incr i 1\} \{\n"
                    #append handler_proc "    set cout_line \[lindex \$cout_list \$i\]\n"
                    #append handler_proc "    set cout_line_prev \[lindex \$cout_list_prev \$i\]\n"
                    append handler_proc "####global var code_${router}_$cmd_id:start\n"
                    append handler_proc "[set code_${router}_$cmd_id]\n"
                    append handler_proc "\n####global var code_${router}_$cmd_id:end\n"
                    #append handler_proc "    \}\n"
                    append handler_proc "myputs \"issue not seen from -\$router:\$cmd-!\"\n"
                    append handler_proc "return 0\n"
                    append handler_proc "\}\n"
                    if {$debug>=3} {myputs "handler_proc now looks:\n$handler_proc"}
                    eval $handler_proc   ;#declare/define the proc, not executed yet!


                    #run handler proc {{{7}}}
                    myputs "call handler==>$handler to parse this cmd for\
                        router $router\n"
                    set result_flag($router,$i) [$handler $router $cmd]

                    #formatting/export data {{{7}}}
                    #myputs "[format "$format" $data1 $data2]" $datafile
                    if [info exists dataformat] {
                        myputs "$router,$time_now,[eval format $dataformat $data]" $datafile
                    }

                } else {
                    #otherwise  ;#{{{6}}}
                    #do nothing {{{7}}}
                    myputs "no parser \"$handler\" defined for router \"$router\"\n"
                    myputs "${cmds}_code_${router}_$cmd_id not defined in the\
                        config file, won't define the handler proc dynamically" 3
                }
            }
            #if user don't want to define a proc,it is OK and script won't exit
            incr i 1                            
        }
    }

    myputs "result_flag array looks [array get result_flag]\n" 3

    #unset/fresh cmds_prev {{{3}}}
    array unset cmd_output_array_${cmds}_prev
    array set cmd_output_array_${cmds}_prev [array get cmd_output_array_$cmds]

    if $debug {
        if [array exists result_flag] {
            puts "after fresh result_flag now looks:"
            parray result_flag
        } else {
            puts "after fresh result_flag array does not exist!"
        }
    }

    #rule_calc {{{3}}}
    #define 'rules' for issue detection: how to know we detected the issue or not?
    if {[info exists rule_calc]} {
        #rule_calc exists {{{4}}}

        #if issue was defined in config file, use it as the rule to detect the
        #  issue e.g.:if 1st cmd flags and 4th cmd is good, or vice-versa,
        #  meaning c-stream and p-stream is not in-sync, this indicate the
        #  scenario that either vrf traffic not totally put into data-mdt , or
        #  the vice versa. this can be checked by an "XOR" operation
        if {[info exists rule_calc]} {myputs "\nissue definition:$rule_msg"}

        #for each router {{{5}}}
        foreach router [array names p_cmds] {

            #eval rule_calc {{{6}}}
            if { [eval $rule_calc] } {
                #true, return 1 {{{7}}}
                myputs "  found issue on router $router:$rule_msg"
                send_log "\n  found issue on router $router:$rule_msg\n" 
                myputs "  result flags looks like:\n[array get result_flag $router*]\n"
                return 1

            } else {
                #false,no return {{{7}}}
                myputs "  no issue for router $router:$rule_msg"
            }

        }

    } else {    ;#if not defined in config file, use default rule: 
        #rule_calc not exists {{{4}}}
        #  all routers all cmds, any single flag indicate a hit
        #if {$debug==3} {send_log "result_flag array looks [array get result_flag]\n"}
        #if {$debug==3} {send_log "check array looks [array get p_cmds]\n"}
        
        #foreach router {{{5}}}
        foreach router [array names p_cmds] {
            #all flags for router1: router1,1 0 router1,2 1
            set flag_list [array get result_flag $router*]
            set cmd_num [llength $p_cmds($router)]              ;#num of cmds for a router

            #foreach cmd {{{6}}}
            for {set i 1} {$i<=$cmd_num} {incr i 1} {           ;#any flag means a hit
                myputs "check result_flag($router,$i)" 2

                #result_flag exists {{{7}}}
                if {[info exists result_flag($router,$i)]} {    ;#but only if flag exist

                    myputs "$result_flag($router,$i)\n" 2

                    if $all_met {

                        #all_met set {{{8}}}
                        #set result_andall [expr $result_andall && $result_flag($router,$i)]
                        if !$result_flag($router,$i) {
                            return 0
                        }

                    } else {

                        #all_met not set {{{8}}}
                        if {$result_flag($router,$i)} {
                            return 1
                        }

                    }

                } else {
                    #result_flag not exists {{{7}}}

                    myputs "result_flag($router,$i) not exist\n" 2
                }
            }
        }
    } 

    if $all_met { return 1 } else { return 0}
}

proc persist_login1 {login_script router args} { ;#{{{2}}}
    global debug session2host host2session  sigquit user_spawn_id
    global persistent
    if {[llength $args]} {
        set port [lindex $args 0]
        spawn $login_script $router $args
    } else {
        spawn $login_script $router
    }
    if $debug {myputs "spawn_id in att script is $spawn_id"}
    mycatch "stty raw"
    send_user "\n<<<CRTC:press \"d\" to exit while awaiting for session to be\
        connected\n"
    expect {
        #this won't get match, "default" will be matched much faster
        -i $user_spawn_id "d" {
            exit
        }
        -i $spawn_id -re "Escape character is" {
            myputs "the router is alive"
            #send "\r"
            set session2host($spawn_id) $router
            set host2session($router) $spawn_id
            return $spawn_id
        }
        -i $spawn_id -nocase "Connection timed out" {
            myputs "connection explicit timeout, try again!"
            catch {close $spawn_id;wait $spawn_id}

            if {[llength $args]} {
                set port [lindex $args 0]
                persist_login1 $login_script $router $args
            } else {
                persist_login1 $login_script $router
            }

            #persist_login $login_script $router $args
        }
        -i $spawn_id default         {
            myputs "get eof/implicit timeout, try again!"
            #puts "press d to stop retry"

            mysleep 2

            catch {close $spawn_id;wait $spawn_id}

            #persist_login $login_script $router $args

            if $sigquit {
                return 0
            } else {
                if {$persistent==1 || $persistent==3} {
                    if {[llength $args]} {
                        set port [lindex $args 0]
                        persist_login1 $login_script $router $args
                    } else {
                        persist_login1 $login_script $router
                    }
                } else {
                    return 0
                }
            }
        }
    }
}

proc do_pags {host pags {pattern_timeout 10} {pa_intv 0} {pa_pair 1}} { ;#{{{2}}}
    # do_pags $host PAGS $pattern_action_timeout $pattern_action_intv
    #
    #mycatch "do_pags $login_index cmds3 10 0 0"
    
    global debug cmds1 cmds2 cmds3
    #puts "host pags looks $host $pags"
    #puts "cmds3 looks"
    #parray cmds3
    #pass the array via upvar (ref)
    upvar $pags p_pags
    #puts "p_pags looks"
    #parray p_pags
    if $debug {myputs "get pattern action groups from :-$p_pags($host)-"}

    #start from simple: the 1st element determines if it's nested
    foreach pa_group $p_pags($host) {
        myputs "parsing $pa_group.."
	global $pa_group
        if [info exists $pa_group] {
            myputs "$pa_group is nested (defined)"
            set nested 1
        } else {
            myputs "$pa_group is not nested (not defined)"
            set nested 0
        }
        break
    }

    if {!$nested} {       ;#if it's a leaf list, execute the list
	if $debug {myputs "this pa_group $pa_group is end 'leaf' node, will execute it..."}
        do_pag $host p_pags cmd_output_array_pags \
            $pa_intv $pattern_timeout $pa_pair
    } else {            ;#if it contains sub-node, repeat this proc recursively
	if $debug {
            myputs "this pa_group $pa_group is not an end 'leaf' node"
            myputs "it was defined as an array: [subst ${pa_group}($host)]"
            myputs "and it contains: [subst $${pa_group}($host)]"
        }

	foreach pa_group $p_pags($host) {
            eval global $pa_group
            do_pags $host $pa_group $pattern_timeout $pa_intv $pa_pair
        }
    }
}

proc upgrade {rel} {    ;#{{{2}}}
    global debug expect_out spawn_id

    #prepare for the upgrade
    upgrade_pre $spawn_id

    #upgrade backup RE 
    expect -i $spawn_id -re "(\[01])> $" {
        set reA $expect_out(1,string)
        exp_send -i $spawn_id "request routing-engine login other-routing-engine\r"
    }
    #check and make sure it really logged in to the other RE before proceed
    expect -i $spawn_id -re "(\[01])> $" {
        set reB $expect_out(1,string)
        if {$reA==$reB} {
            myputs "login the other re failed, exit!";exit
        } else {
            myputs "login the other re succeed, continue!"
            exp_send -i $spawn_id "\r"
        }
        upgrade_re $spawn_id $rel
    }
    
    #upgrade master RE 
    #expect -i $spawn_id -re "going down IMME(.*\r\n){3,7}(rlogin: connection closed.*)" 
    expect {
        -i $spawn_id "going down IMMEDIATELY" {exp_continue -continue_timer}
        -i $spawn_id "rlogin: connection closed"  {exp_continue -continue_timer}
        -i $spawn_id -re "(\[01])> $" {
            set reC $expect_out(1,string)
            if {$reA==$reC} {
                myputs "seeing RE$reC , back to master, will upgrade master now"
                #sleep 5
                exp_send -i $spawn_id "\r"
                upgrade_re $spawn_id $rel
            } else {
                myputs "seeing RE$reC, still not back to master, wait"
                exp_continue -continue_timer
            }
        }
        -i $spawn_id default {
            myputs "some unexpected conditions(still not back to master), exit!"
            exit
        }
    }
    #above can also be re-written as:
    #set buf ""
    #expect -i $spawn_id -re ".+" {
    #    append buf $expect_out(buffer)
    #    exp_continue
    #}

    #if [regexp "$reA> $" $buf] {
    #    myputs "seeing RE$reC , back to master, will upgrade master now"
    #    #sleep 5
    #    exp_send -i $spawn_id "\r"
    #    upgrade_re $spawn_id $rel
    #} else {
    #    myputs "seeing RE$reC, still not back to master, wait"
    #    exp_continue -continue_timer
    #}

    #expect -i $spawn_id -re "> $"
    expect -i $spawn_id -re "going down IMMEDIATELY"
}

proc upgrade_re {rel} {         ;#{{{2}}}
    global spawn_id
    set timeout 300
    myexpect $spawn_id "> $"  "set cli screen-width 300"
    myexpect $spawn_id "> $"  "request system software add $rel validate force"
    expect {
        -i $spawn_id "Installation failed" {
            myputs "system software adding failed, exit!"; exit
        }
        -i $spawn_id "Saving state for rollback" {
            myputs "system software adding succeed, continue to reboot!"
            myexpect $spawn_id "re\[01]>"  "request system reboot"
            myexpect $spawn_id "\\\(no\\\) +$" "yes"
        }
        -i $spawn_id "ERROR: Another package installation in progress:" {
            myputs "will retry in 5s"
            mysleep 5
            myexpect $spawn_id "> $"  "request system software add $rel validate force"
            exp_continue
        }
        -i $spawn_id default {
            myputs "unexpected: neither fail nor success"
            myputs "will retry again when timeout"
            exp_continue
        }
    }
    set timeout 60
    #exp_internal 1
    #set timeout $old_timeout
    #myputs "restore old timeout $timeout"
    #exp_internal 0
}

proc arrayvalue {array1} { ;#{{{2}}}
    set list {}
    upvar $array1 array
    foreach name [array names array] {
       lappend list $array($name)
    }
    return $list
}

proc usage {} { ;#{{{2}}}
    global argv0

    #send_error is more proper than send_user?
    #why? (2016-06-18) maybe puts + \r\n is better for performance
    #when interact slows down, all "send_*" become slow
    #
    puts -nonewline "\nUsage:$argv0 \[OPTIONS\]\r\n"
    puts -nonewline "  OPTIONS:\r\n"
    puts -nonewline "     -G                 :generate a config file template\r\n"
    puts -nonewline "     -h                 :this usage/detail tutorial\r\n"
    puts -nonewline "     -e                 :edit config file\r\n"
    puts -nonewline "     -l                 :list configured hosts info\r\n"
    puts -nonewline "     -v                 :print version/license info\r\n"
    puts -nonewline "     -0/-?/?/--help     :print usage examples\r\n"
    puts -nonewline "     -H                 :print the \"full menu\""
    puts -nonewline "\r\n"

    puts -nonewline "Usage:$argv0 \[OPTIONS\] session\r\n"
    puts -nonewline "  OPTIONS:\r\n"
    puts -nonewline "     -a  :attributes\r\n"
    puts -nonewline "     -A  :set/unset auto-paging (no-more)\r\n"
    puts -nonewline "     -b/B \"show cli\"  :commands before/after loop\r\n"
    puts -nonewline "     -c \"show version | no-more\" :commands (in a loop)\r\n"
    puts -nonewline "     -C <config file|NONE> :read config file\r\n"
    puts -nonewline "     -d  :set/unset debug info\r\n"
    puts -nonewline "     -D  :max_hits: max times issue will be detected\r\n"
    puts -nonewline "     -e \">\" -s \"show version | no-more\" :expect and send\r\n"
    puts -nonewline "     -E \"$\" -S \"telnet alecto..\" :same, but for login\r\n"
    puts -nonewline "     -F showver.log     :cmd_filename\r\n"
    puts -nonewline "     -f router1.log     :router log file name\r\n"
    puts -nonewline "     -g  :gap between each cmd\r\n"
    puts -nonewline "     -h <host1> <host2> .. :login to multiple hosts\r\n"
    puts -nonewline "     -i <SECONDS>       :interval between each iteration of all cmds\r\n"
    puts -nonewline "     -j <NUMBER>        :project\r\n"
    puts -nonewline "     -J  :event script\r\n"
    #puts -nonewline "     -k  :exit session also/not exit script\r\n"
    puts -nonewline "     -k  :send_usage_stats - send usage statistics\r\n"
    puts -nonewline "     -K  :sKip env: env_proof\r\n"
    puts -nonewline "     -l \"abc@xyz.net\" :email address to send log attachment\r\n"
    puts -nonewline "     -L  :log_when      :when will logging start\r\n"
    puts -nonewline "     -m  :monitor mode(keep sending cmds)\r\n"
    puts -nonewline "     -M  :automate local tasks"
    puts -nonewline "     -n <count>         :send command <count> time(s)\r\n"
    puts -nonewline "     -o  :set/unset \"login only\" (ignore all cmds)\r\n"
    puts -nonewline "     -O  :emailbody: email contant\r\n"
    puts -nonewline "     -p  :set/unset \"persist mode\"\r\n"
    puts -nonewline "     -P  :when used with -h,run commands in parallel\r\n"
    puts -nonewline "     -q  :set/unset \"quick mode\" (quit after done)\r\n"
    puts -nonewline "     -Q  :features - amount of \"features\"\r\n"
    puts -nonewline "     -r <SECONDS>       :reconnect interval\r\n"
    puts -nonewline "     -R \"1@packets@\s+(\d+)\s+(\d+) pps@packets@pps\" :regex and vars string\r\n"
    puts -nonewline "     -I \"1@pps == pps_prev\"  :issue definition\r\n"
    puts -nonewline "     -t  :set/unset timestamping all commands\r\n"
    puts -nonewline "     -T  :timestamp all output lines\r\n"
    puts -nonewline "     -u  :redirect_inshell\r\n"
    puts -nonewline "     -U  :print \"login_succeed_signature\" when login succeeded\r\n"
    puts -nonewline "     -H  :set/unset \"hidden mode\" (hide login step details)\r\n"
    puts -nonewline "     -w <SECONDS>       :timeout_login\r\n"
    puts -nonewline "     -W <SECONDS>       :timeout_cmd\r\n"
    puts -nonewline "     -V  :print value matched by the regex from -R\r\n"
    puts -nonewline "     -v  :verbose\r\n\r"
    puts -nonewline "     -x  :all_med - define issue as all cmds met -I criterias\r\n"
    puts -nonewline "     -X  :lock_session, set key_interact to an impossible value\r\n"
    puts -nonewline "     -y  :use barewords instead of \$var for varibles in -I expression\r\n"
    puts -nonewline "     -Y  :commands when match found(Yes) in -R\r\n"
    puts -nonewline "     -N  :commands when match not(No) found in -R\r\n"
    puts -nonewline "     -z  :compress/don't compress log before attach to email\r\n"
    puts -nonewline "     -Z  :no_anti_idle: disable anti_idle_timeout\r\n"

    usage_inline

    puts -nonewline "session management\r\n"
    puts -nonewline "  \i\r\n"
    puts -nonewline "  \N  N refers a session number\r\n"

    puts -nonewline "helps\r\n"
    puts -nonewline "  !?  list all keystoke commands\r\n"
    puts -nonewline "  !h  print usage\r\n"
    puts -nonewline "  !i  print detail tutor docs\r\n"

    puts -nonewline "other commands:\r\n"
    puts -nonewline "  Ctrl-g suspend the script\r\n"
    puts -nonewline "  Ctrl-\(SIGQUIT) to stop the cmds automations\r\n"
    puts -nonewline "  automation control:\r\n"
    puts -nonewline "      q   quit the automation\r\n"
    puts -nonewline "      <SPACE> continue(escape sleeping)\r\n"
    puts -nonewline "      <ENTER> same as <SPACE>\r\n"
    puts -nonewline "      Q   exit the script\r\n"
    puts -nonewline "  SPECIAL CMDS:\r\n"
    puts -nonewline "     GRES               :Junos GRES request\r\n"
    puts -nonewline "     SLEEP <SECONDS>    :sleep some seconds before sending next command\r\n"
    puts -nonewline "     REPEAT M N         :repeat the last M commands N times\r\n"
    puts -nonewline "     UPGRADE /var/tmp/..:upgrade junos release\r\n"
}

proc usage_inline {} {  ;#{{{2}}}
    puts -nonewline "inline commands:\r\n"
    puts -nonewline "  !a  changing attributes on the fly(todo)\r\n"
    puts -nonewline "  !A  toggle auto_paging option\r\n"
    puts -nonewline "  !b  block/close sharing tempararily\r\n"
    puts -nonewline "  !B  block/close sharing permanently(TODO)\r\n"
    puts -nonewline "  !c  specify and repeat a command\r\n"
    puts -nonewline "  !C  editing current config file\r\n"
    puts -nonewline "  !d  toggle debug option\r\n"
    puts -nonewline "  !D  dump (debugging) input/output characters\r\n"
    puts -nonewline "  !e!  start expect-command pair group automation\r\n"
    puts -nonewline "  !e?  same, but asking for array's name\r\n"
    puts -nonewline "  !E  attach log in email and send to user\r\n"
    puts -nonewline "  !f  file download/upload\r\n"
    puts -nonewline "  !F  not in use\r\n"
    puts -nonewline "  !g/G  change timeout (gap) value\r\n"
    puts -nonewline "  !H  toggle hideinfo option\r\n"
    puts -nonewline "  !I  enter interpreter mode\r\n"
    puts -nonewline "  !j/J  not in use\r\n"
    puts -nonewline "  !k  kibitz (testing) \r\n"
    puts -nonewline "  !K  not in use\r\n"
    puts -nonewline "  !l log file operations\r\n"
    puts -nonewline "    !le: email current log file\r\n"
    puts -nonewline "    !ln: start a new log file \r\n"
    puts -nonewline "    !ls: stop/suspend logging to current log file\r\n"
    puts -nonewline "    !lS: stop/suspend all logging\r\n"
    puts -nonewline "    !lr: resume logging to current log file\r\n"
    puts -nonewline "    !lv: view the log file\r\n"
    puts -nonewline "    !ll: list the log file(name)\r\n"
    puts -nonewline "    !lv:view the log file\r\n"
    puts -nonewline "  !m  print host list\r\n"
    puts -nonewline "  !M  monitor event (event script)\r\n"
    puts -nonewline "  !n  spawn new shell\r\n"
    puts -nonewline "  !N  toggle no_feature\r\n"
    puts -nonewline "  !o  toggle login_only option\r\n"
    puts -nonewline "  !O  reload the config\r\n"
    puts -nonewline "  !p  toggle persistent option\r\n"
    puts -nonewline "  !P  toggle parallel option\r\n"
    puts -nonewline "  !q  toggle nointeract (quick mode) option\r\n"
    puts -nonewline "  !Q  exit the script\r\n"
    puts -nonewline "  !r  repeat the previous cmds execution\r\n"
    puts -nonewline "  !R  resume the previous cmds from where left over\r\n"
    puts -nonewline "  !s  stop the remaining of previous automations\r\n"
    puts -nonewline "  !S  not in use\r\n"
    puts -nonewline "  !t  toggle timestamp option\r\n"
    puts -nonewline "  !T  toggle timestamp_output_line option\r\n"
    puts -nonewline "  !u  toggle enable_user_patterns\r\n"
    puts -nonewline "  !V  print version/license info\r\n"
    puts -nonewline "  !v  toggle verbose\r\n"
    puts -nonewline "  !w/W  not in use\r\n"
    puts -nonewline "  !x/X  not in use\r\n"
    puts -nonewline "  !y  spawn a new shell\r\n"
    puts -nonewline "  !Y  not in use\r\n"
    puts -nonewline "  !z  toggle kibitz sharing\r\n"
    puts -nonewline "  !Z no_anti_idle\r\n"
    puts -nonewline "session management\r\n"
    puts -nonewline "  \r\i\r\n"
    puts -nonewline "  \r\N  N refers a session number\r\n"
    puts -nonewline "helps\r\n"
    puts -nonewline "  !?  list all keystoke commands\r\n"
    puts -nonewline "  !h  print usage\r\n"
    puts -nonewline "  !i  print detail tutor docs\r\n"
    puts -nonewline "other commands:\r\n"
    puts -nonewline "  Ctrl-g suspend the script\r\n"
    puts -nonewline "  Ctrl-\(SIGQUIT) to stop the cmds automations\r\n"
}

proc version {} { ;#{{{2}}}
    global version

    puts "$version"
    #license
    puts ""
    puts "This program is free software; you can redistribute it and/or     "
    puts "modify it under the terms of the GNU General Public License       "
    puts "as published by the Free Software Foundation; either version 2    "
    puts "of the License, or (at your option) any later version.            "
    puts "                                                                  "
    puts "This program is distributed in the hope that it will be useful,   "
    puts "but WITHOUT ANY WARRANTY; without even the implied warranty of    "
    puts "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     "
    puts "GNU General Public License for more details.                      "
    puts "                                                                  "
    puts "You should have received a copy of the GNU General Public License "
    puts "along with this program; if not, write to the Free Software       "
    puts "Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA."
    puts ""
}

proc argvchecker { optlist optmap options_cli {argv2 123321} } { ;#{{{2}}}

    #get paramlist argv2, using optlist and optmap to process,
    #paramlist argv2 will be changed as:
    #1. split compact options: 
    #           -abcd3 => -a -b -c -d 3
    #2. padding single options, make "opt value opt value .." pairs even
    #           -a -b -c -d 3 => -a 1 -b 1 -c 1 -d 3
    #
    #then fill array "options_cli" with the data
    #
    global argv debug
    upvar $optmap p_optmap
    upvar $options_cli p_options_cli
    upvar $argv2 p_argv2

    myputs "optlist looks $optlist" 2
    myputs "arglist looks $p_argv2" 2

    set detaildebug 3

    if {$p_argv2==123321} {
        myputs "parsing argv: $argv"
        set p_argv2 $argv
    }

    set ind -1
    foreach opt $p_argv2 {      ;#{{{3}}}
        set optlist2 ""
        incr ind

        #single slash multi-option: {{{4}}}
        if [regexp {^-\w{2,}} $opt] {                           ;#-abcd30
            myputs "detected a multi-opt: $opt, will split" 3
            set opt_split [split $opt ""]
            set onecharlist [ldelete opt_split "-"]       ;#a b c d 3 0
            set i 1;set digits ""
            #set last [llength $onecharlist]
            
            #parse multi-option:v1:
            #foreach onechar $onecharlist { ;#foreach a b c d 30
            #    if {[regexp {\d} $onechar]} {
            #        lappend optlist2 "$onechar"
            #    } else {
            #        lappend optlist2 "-$onechar"
            #    }
            #    incr i
            #}                         ;# optlist2: -a -b -c -d 3 0

            #parse multi-option:v2:
            #foreach a b c d 3 0
            foreach onechar $onecharlist {      

                myputs "get $onechar" $detaildebug

                #if it's a digit, {{{5}}}
                #group them into one word for later usage
                if {[regexp {\d} $onechar]} {   
                    append digits $onechar      
                    myputs "digit! save to digits: $digits" $detaildebug
                    continue
                #if it's a letter {{{5}}}
                } else {                        
                    myputs "letter!" $detaildebug

                    if ![string equal $digits ""] {     ;#if got some digits
                        lappend optlist2 $digits        ;#already, push them in 
                        set digits ""                   ;#new list and clear it
                        myputs "push the previous digits" $detaildebug
                    }

                    #set onechar_prev [lindex $onecharlist $i-1]
                    #if {regex {\d} $onechar_prev} {
                    #    lappend onecharlist2 [join "$onechar_prev $onechar" ""]
                    #} else {
                    #    lappend onecharlist2 "$onechar"
                    #}
                    myputs "push the letter" $detaildebug
                    lappend optlist2 "-$onechar" ;#then push letter in new list
                    myputs "new option list looks: $optlist2" $detaildebug
                    #myputs "append -$onechar"
                }
            }                              
            if ![string equal $digits ""] {
                lappend optlist2 $digits
                set digits ""
                myputs "push the previous digits" $detaildebug
                myputs "new option list looks: $optlist2" $detaildebug
            }                                                   ;#a b c d 30

            myputs "replace multi-opt $opt, with new list |$optlist2|" 3
            regsub -- $opt $p_argv2 $optlist2 p_argv2
            myputs "arglist now looks $p_argv2" 3

        #doubledash single option {{{4}}}
        #--timestamp 1
        } elseif [regexp {^--(\w{1,})} $opt -> opt_name] { 

            #set p_options_cli($opt_name) 1

        #non-multi-option {{{4}}}
        } else {

            #myputs "treat this as a value"
            #set p_options_cli($opt_name) $opt

        }
    }

    #values assignment=> options_cli {{{3}}}
    foreach opt $p_argv2 {
        myputs "get an option $opt" 2

        if [regexp -- "^$optlist" $opt] {
            myputs "$opt is in supported option list, check next field" 2
            set opt_ind [lsearch $p_argv2 $opt]
            set next_ind [expr $opt_ind + 1]
            set next_value [lindex $p_argv2 $next_ind]
            if {[regexp "^-" $next_value] || [string equal $next_value ""]} {
                myputs "no value for this option $opt,padding with 1" 2
                set p_argv2 [linsert $p_argv2 $next_ind 1]
                set p_options_cli($p_optmap($opt)) 1
                myputs "set option: $p_optmap($opt) => 1" 2
            } else {
                myputs "option $opt has a value,no need padding" 2
                set p_options_cli($p_optmap($opt)) $next_value
                myputs "set option: $p_optmap($opt) => $next_value" 2
            }
        } else {
            if [regexp "^-" $opt] {
                myputs "$opt not in supported option list!"
                #exit
            } else {
                myputs "$opt looks a value" 2
            }
        }
    }
    myputs "arglist now looks: $p_argv2"
    if [array exists p_options_cli] {
        myputs "options_cli now looks like:" 3
        if {$debug==3} {parray p_options_cli}
    } else {
        myputs "no supported options"
    }
}

proc ldelete { list value } { ;#{{{2}}}
    upvar $list list1
    set ix [lsearch -exact $list1 $value]
    if {$ix >= 0} {
        set list1 [lreplace $list1 $ix $ix]
        return $list1
    } else {
        return $list
    }
}

proc domainname {{file /etc/resolv.conf}} {    ;#{{{2}}}
    if [file exists $file] {
        set file [open $file r]
        while {[gets $file buf] != -1} {
            if {[scan $buf "search %s" domainname] == 1} {
                close $file
                return $domainname
            }
        }
        close $file
        error "no domain declaration in $file"
        return 0
    } else {
        puts "no file $file exists!"
        return 0
    }
}

proc configparser {{file ~/crtc.conf}} {    ;#{{{2}}}
    #1. find out all option vars and save into options_cfg global array
    #2. find out all arrays, and return the list of all arrays
    #
    #the configparser has one side effect that, a later assignment will always
    #overide a previous ones, regardless of where these assignment appears.
    #
    #e.g.:
    #  set abc 1
    #  if {$abc>$def} {
    #    set abc 2
    #  } else {
    #    set abc 3
    #  }
    #
    #no matter what, after configparser, option_cli(abc) will always set to 3
    #
    #currently, this is workarounded by using "SKIP_" prefix to a var - this
    #var won't be scanned and saved in option_cli
    #
    global options_cfg debug
    set list {}
    if [file exists $file] {
        set file [open $file r]
        while {[gets $file buf] != -1} {
            myputs "get a line -$buf-"
            #remove "'{} {{{3}}}
            #read each line, and look for sth like "set var value", 
            #and the var can't include ( or ) (indicating an array)
            #and strim the possible " or ' or { or } in the value
            #
            #this implementation has some potential issue...TODO/buggy
            #considering this:
            #   set login_jtac_server [list             \
            #           "$"     "$go_jtac_server"       \
            #           "sword" "$unixpass"             \
            #   ]
            #
            if {\
                [regexp {^\s*set\s{1,4}([a-zA-Z0-9_\-]+)\s+(.*)} $buf\
                -> var value] == 1\
            } {

                myputs "found a varible $var in config file $file" 3
                set firstchar [string index $value 0]
                set lastchar [string index $value end]
                if {[string equal $firstchar \"] && [string equal $lastchar \"]} {
                    set value [string replace $value 0 0]
                    set value [string replace $value end end]
                }
                if {[string equal $firstchar \'] && [string equal $lastchar \']} {
                    set value [string replace $value 0 0]
                    set value [string replace $value end end]
                }
                if {[string equal $firstchar \{] && [string equal $lastchar \}]} {
                    set value [string replace $value 0 0]
                    set value [string replace $value end end]
                }
                myputs "get a set statement -\"set $var $value\"-" 3
                
                #skip this config scan for vars with prefix "SKIP_" 
                if ![regexp "SKIP_" $var] {
                    set options_cfg($var) $value
                }

                #special process for unixpass which is transformed
                catch {
                    if {$var=="unixpass"} {
                        #puts "original value is $value"
                        set options_cfg($var) [subst $value]
                        #puts "options_cfg($var) looks $options_cfg($var) now"
                    }
                }
                #set options_cfg($var) [subst $value]
            }

            #method1: to find and return array name only {{{3}}}
            if {[regexp {^\s*set\s+([a-zA-Z0-9_\-]+)\(\S+.*\)} $buf -> arrname] == 1} {
                myputs "found an array $arrname in config file $file"
                lappend list $arrname
            }
            
            #test: method2: to find and return array name and the value strings
            #(code), seems hard.
            #
            #if {[regexp {^\s*set\s+([a-zA-Z0-9_\-]+)\(\S+.*\)\s+(\S+.*\n\n)} \
            #   $buf -> arrname arrstring] == 1} {
            #    myputs "found an array $arrname in config file $file"
            #    lappend list $arrname
            #}
        }
        #parray options_cfg

        #foreach opt [array name options_cfg] {
        #    puts "$opt"
        #    set options_cfg($opt) [subst $options_cfg($opt)]
        #}

        close $file

        #need to return list of all "arrays" in the config file, so disable
        #below code:
        #if [array exists options_cfg] {
        #    #parray configfile
        #    return 1
        #} else {
        #    error "no valid options in $file"
        #    return 0
        #}
        if ![string equal $list ""] {
            return [lsort -unique $list]
        } else {
            return 0
        }

    } else {
        puts "no file $file exists!"
        return 0
    }
}

proc configparser2 {{file ~/crtc.conf}} {    ;#{{{2}}}
    #1. find out all option vars and save into options_cfg global array
    #2. find out all arrays, and return the list of all arrays
    global options_cfg debug 
    #global env tcl_platform crtc_dir host session login_index
    #global global_data;eval $global_data
    #global crtc_dir 
    #global session group login_index host
    #global global_data;eval $global_data
    eval $config_default  ;# {{{3}}}

    set list {}
    if [file exists $file] {
        source $file
        myputs "all vars available looks:[info vars]" 3
        foreach var [info vars] {
            if [array exists $var] {
                lappend list $var
            } else {
                if [info exists $var] {
                    set options_cfg($var) [set $var]
                }
            }
        }

        #parray options_cfg

        if ![string equal $list ""] {
            return [lsort -unique $list]
        } else {
            return 0
        }

    } else {
        puts "no file $file exists!"
        return 0
    }
}

proc domainname1 {} {    ;#{{{2}}}
    #from expect example: kibitz
    # open pops stack upon failure
    set rc [catch {open /etc/resolv.conf r} file]
    if {$rc==0} {
	while {-1!=[gets $file buf]} {
	    if 1==[scan $buf "domain %s" name] {
		close $file
		return $name
	    }
	}
	close $file
    }

    # fall back to using domainname
    if {0==[catch {exec domainname} name]} {return $name}

    error "could not figure out domainname"
}

proc signal_interception {} { ;# {{{2}}}
    global sigquit
    puts "got a sigquit!"
    set sigquit 1
    set options(sigquit) 1
    set options_inline(sigquit) 1
}

proc mysleep {timeout} {       ;#{{{2}}}

    global global_data; eval $global_data
    global login_index

    #return: 0 no user interuption in N seconds, N>0
    #        1 user interupted during N seconds, N>0
    #        2 N==0, just return
    if {$timeout >=3 } {
        myputs2 "\n<<<<count {$timeout}s before proceeding...\n"
        myputs2 "<<<<  \"$pattern_break_automation\":break(quit automation)\
                     \"$pattern_exit_script\":exit the script\
                     \"$pattern_continue_automation\" (or anything else):\
                     continue(escape sleeping)\n"
    }
    if {$timeout <= 0} {
        return [CONST RETURN_SLEEP_ZERO]
    }

    global user_spawn_id
    #mycatch "stty raw"
    catch {set oldmode [stty raw]}
    #under raw mode:
    #\n just move to newline without "return"
    #\r works fine
    #puts "      $pattern_break_automation:quit automation\r"
    #puts "      $pattern_continue_automation       :escape sleeping\r"
    #puts "      $pattern_exit_script:exit the script\r"
    #puts "      +|-                     :incr/reduce sleep time\r"
    #puts "      q:quit automation;<SPACE|ENTER> escape sleepting and
    #continue;Q:exit script"

    #monitor user input {{{3}}}
    expect {

        #pattern_continue_automation {{{4}}}
        -i $user_spawn_id -re $pattern_continue_automation {
            myputs2 "you hit something ,escape sleep (${timeout}s)...\n"
            return [CONST RETURN_SLEEP_CONTINUE]
        }
        
        #pattern_break_automation {{{4}}}
        -i $user_spawn_id -re $pattern_break_automation {

            #interupt from mysleep
            #copy from do_pag
            set automation_non_complete_msg "<<<<\[session $login_index\]: \
                you have unfinished automations (stack $myinteract_depth)! \
                press !R to continue, ^\\ or !s to stop, !Q to quit script"
                set options(automation_non_complete_msg) \
                    $automation_non_complete_msg
                set options_inline(automation_non_complete_msg) \
                    $automation_non_complete_msg

            incr myinteract_depth
            myputs "increase myinteract_depth to $myinteract_depth"

            myinteract $login_index
            #interpreter
            #stty -raw

            set automation_non_complete_msg ""
                set options(automation_non_complete_msg) \
                    $automation_non_complete_msg
                set options_inline(automation_non_complete_msg) \
                    $automation_non_complete_msg

            return [CONST RETURN_SLEEP_BREAK]

        }
        #-i $user_spawn_id -re "d" {
        #    if {[fork]!=0} exit
        #    disconnect
        #}
        #pattern_exit_script {{{4}}}
        -i $user_spawn_id -re $pattern_exit_script {
            exit
        }
        #"+" {{{4}}}
        -i $user_spawn_id "+" {
            incr timeout 2;  
            myputs2 "timeout increased to $timeout\r"
            exp_continue
        }
        #"-" {{{4}}}
        -i $user_spawn_id -- "-" { 
            incr timeout -2; 
            myputs2 "timeout reduced to $timeout\r"
            exp_continue
        }
        #other input key {{{4}}}
        -i $user_spawn_id -re "\\\?|\[^qQ+-?\]" {
            #this has no effect, still in raw mode;
            #it looks stty only take effect when toggling before expect
            #mycatch "stty -raw"
            #puts "      $pattern_break_automation:quit automation\r"
            #puts "      $pattern_continue_automation       :escape sleeping\r"
            #puts "      $pattern_exit_script:exit the script\r"

            myputs2 "<<<<  \"$pattern_break_automation\":break(quit automation)\
                         \"$pattern_exit_script\":exit the script\
                         \"$pattern_continue_automation\" (or anything else):\
                         continue(escape sleeping)\n"

            #
            #this is not necessary
            #mycatch "stty raw"
            exp_continue
        }
        #timeout {{{4}}}
        timeout {
            if {$timeout >=2 } {
                myputs "timed out (${timeout}s) without interuption..."
            }
            return 0
        }
    }
    #mycatch "stty -raw"
    catch {eval stty $oldmode}
}

proc myexit {} {        ;#{{{2}}}
    global debug
    if $debug {
        interpreter
    } else {
        exit
    }
}

proc sigraise {flag} {      ;#{{{2}}}
    set file "~/.crtc-$flag"
    set h_flag [myopen $file w]
    if {$h_flag == 0} {
        puts "Cannot create file $file"
        return 0
    } else {
        if {$h_flag != 0} puts $h_flag "file $file created for signalling"
        flush $h_flag
        close $h_flag
        return 1
    } 
}

proc sigdetect {{flag ""}} {     ;#{{{2}}}
    set filename [glob -nocomplain "~/.crtc-$flag*"]
    if [info exists filename] {
        myputs "file $filename found for signalling"
        return $filename
    } else {
        myputs "Cannot find a file looks ~/.crtc-$flag"
        return 0
    } 
}

proc sigclean {flag} {     ;#{{{2}}}
    set file "~/.crtc-$flag"
    foreach file1 [glob -nocomplain "$file*"] {
        myputs "found file $file1"
        file delete $file1
    }
}



proc tracevar {v null op} {    ;#{{{2}}}
    global debug
    upvar $v var
    myputs "$v was just changed to $var!"
}

proc expect_compensation {login_index} {   ;#{{{2}}}

    ##after login, before sending any command, we still "owe" an expect to
    #display the last cmds of
    ##login_info
    ##1. no cmds1 , need add one expect
    ##2. there is cmds1 w/o -e (send-n-expect), need add one expect before
    ##   cmds1
    ##3. there is cmds1 w   -e (expect-n-send), need add one expect after
    ##   cmds1
    #if {$hideinfo == 2} {send_tty "login succeed!\n"}

    ##this might be wrong, to be tested
    #if {![info exists cmds1($login_index)] } { 
    #    #1. no cmds1 , need add one expect
    #    myputs "no cmds1 to send, expect one more to display last pat-act"
    #    #expect -re $pattern_common_prompt 
    #    #this is for condition when ending strings are not a prompt - e.g a
    #    #menu/list to select from
    #    expect -re "$"
    #} elseif {[info exists cmds1($login_index)] && 
    #         ![string equal $cmds1($login_index) ""]} {
    #    myputs "cmds1 looks -$cmds1($login_index)-"
    #    myputs "there is cmds1 to send, expect one more to display last pat-act"
    #    expect -re "$"
    #    #expect -re $pattern_common_prompt 
    #} else {
    #    myputs "cmds1 looks like: $cmds1($login_index)"
    #    #if $debug {parray cmds1}
    #    #2. there is cmds1 w/o -e (send-n-expect), need add one expect
    #    #   before cmds1
    #    if ![info exists options_cli(expect)] { 
    #        myputs "will send cmds1 , w/o option e, do one more expect"
    #        expect -re $pattern_common_prompt 
    #    } else {
    #    }
    #}

    global global_data;eval $global_data
    global timeout
    set process $host2session($login_index)

    myputs "expect compenstation after login and before execute cmds"

    set cmds "cmds$options(project)"
    #   cmds="cmds3"

    #assuming need compensation initially {{{3}}}
    set do_compensation 1

    #check if cmds are empty {{{3}}}
    set is_cmds_not_empty [expr ![string equal [set ${cmds}($login_index)] ""]]
    #                                                -------
    #                                                   |
    #                                                   v
    #                                                  cmds3
    #                                            set cmds3(alecto@jtac)
    #myputs "test ${cmds}($login_index) looks [set ${cmds}($login_index)]"
    #myputs "test cmds_cli($login_index) looks $cmds_cli($login_index)"
    if $is_cmds_not_empty {
        myputs "$cmds not empty"
    } else {
        myputs "$cmds empty"
    }

    #check special char {{{3}}}
    set special_char_triggered_pa 0
    #set treat_special_char_as_pa 1
    if $treat_special_char_as_pa {
        foreach cmd [set ${cmds}($login_index)] { 
            #if any cmd contains special CH, treat it as a pattern(prompt)
            if [regexp {#|>|%|\$} $cmd] {
                set special_char_triggered_pa 1
            } 
        }
        if $special_char_triggered_pa {
            myputs "there is pattern-like chars in the $cmds"
        } else {
            myputs "there is no pattern-like chars in the $cmds"
        }
    }

    #check dashe {{{3}}}
    set is_dashe_in_use [info exists options_cli(expect)]
    if $is_dashe_in_use {
        myputs "-e in use"
    } else {
        myputs "-e not in use" 
    }

    #calc compensation {{{3}}}
    #compensate one more expect when:
    #1. there is cmds1 to send, and
    #2. no pattern-looking strings in it (like a '>'), or
    set do_compensation [expr {
        $is_cmds_not_empty && \
        !$special_char_triggered_pa \
    }]

    #3. -e in use
    if $is_dashe_in_use {
        set do_compensation 1
    }
    
    if $do_compensation {
        myputs "compensate one more expect"

        #method 1: this works for all normal prompt: #>%$
        #but it doesn't work for login steps that ends with other charactors
        #typically e.g. if logging into a springboard that provides a menu of
        #devices
        #
        #expect -i $process -re $pattern_common_prompt 

        #method 2: the following seems a must to expect a "menu", but lead to a
        #tricky issue for normal prompt: the issue is that, it make the
        #expect compensation doesn't work , which result in the
        #"expect-lagging issue" caused by one missing expect in the
        #"expect-send" sequence, the symptom is that in a
        #"expect1-send2-send3-expect3" sequence, the expect3 won't
        #return result of send3, but instead return only result till
        #send2.  this is also why the "expect compensation" is
        #necessary here
        #
        #expect -i $process -re "$"

        #method 3: combine the above 2, just accept anything for a little while
        #this "little while" is very tricky...it needs to be long enough to
        #"suck" all output from the very last "send" from login_info, but not
        #too long to make crtc slow; testing shows "1" sometimes not enough, or
        #give unreliable result in each time. "2" looks the best compromision
        #so far.  check this when the last" command output (-c "xxx") was
        #"missing"
        set timeout_old $timeout;
        set timeout 2
        expect -i $process -re ".+" exp_continue
        set timeout $timeout_old
    } else {
        myputs "no expect compensation"
    }
}

proc reconnect_todo {} {     ;#{{{2}}}

    #if disconnected before output return, wait 30s, re-login,
    #re-send cmd and re-expect the prompt
    myputs2 "persistent mode set, reconnect in ${reconnect_interval}s"
    myputs2 "type !p to toggle persistent mode"
    close; wait
    mysleep $reconnect_interval

    #spawn -noecho $env(SHELL)
    #set host2session($login_index) $spawn_id
    #set session2host($spawn_id) $login_index
    #log_user [expr !$hideinfo]
    #do_pag $login_index login_info $timeout_login
    spawn_login $login_index

    if {$debug>1} {myputs "session set to new spawn_id $process"}
    #exp_send -i $process "$cmd\r"
    #for some reason, this doesn't work - report spawn id exp7 not open
    #it looks after exp_continue the spawn_id (process) is still old value
    #exp_continue

    if {$continue_on_reconnect} {
        myexpect $router $pattern $cmd $mytimeout $isSendFirst $isPersis
    } else {
        exec_cmds $login_index
        return
    }
}

proc reload_data {login_index} {   ;#{{{2}}}

    #global option vars{{{3}}}
    myputs "==>entering reload_data"
    global global_data;eval $global_data
    #for log file name
    global session_nogroup crtc_dir
    global session group

    #puts "options_cli exists: [info exists options_cli]"
    #if [info exists options_cli] { parray options_cli }
    
    #process "session/group/host" {{{3}}}
    if [regexp {(\S+)@(\S+)} $login_index -> session group] {
        #if it contains category(group) indicator,
        #extract the session and the indicator
        myputs "extracting session ($session) and group($group) info \
            from $login_index" 2
        set session_nogroup $session
    } else {
        if [eval [subst {regexp {$sessionname_regex} $login_index -> session}]] {
            myputs "extracting session ($session) info from $login_index"
        } else {
            #otherwise, just take the whole as session
            myputs "no group in hostname $login_index, take hostname as session"
            set session $login_index
        }
        set session_nogroup $login_index
    }

    #hostmap {{{3}}}
    #if the session is not the same as host then it need to be converted
    set session_lower [string tolower $session]
    if { [info exists hostmap($session_lower)] } {
        set host $hostmap($session_lower)
        myputs "session $session is mapped to $host"
    } else {
        set host $session
    }

    #this refreshes options(abc) array with default value
    eval $config_default  ;# {{{3}}}

    #init data before rebuild {{{3}}}
    #this is important in order to use "reload_conf_inloop" option
    #otherwise inside exec_cmds every loop will push duplicate cmds
    
    for {set i 1} {$i<=200} {incr i 1} {
        set cmds${i}($login_index) {}
        set cmds${i}($login_index.clone) {}
        set pre_cmds${i}($login_index) {}
        set post_cmds${i}($login_index) {}
    }
    set login_info($login_index) {}
    set collect($login_index) {}
    set test($login_index) {}
    set regex_info($login_index) {}
    set issue_info($login_index) {}


    #source config file {{{3}}}
    #
    #lession learned: 
    #source from within a proc is tricky, need to rely on 'global' data before
    #sourcing config file, otherwise all change will get lost when proc done
    #
    if {($config_file != "NONE") && [file exists $config_file]} {

        #scan and parse config {{{4}}}
        #1. extract var-looking string and save the value => options_cfg
        #2. return list all array look strings and "global" them
        #
        #new version, use [info var]
        set arrlist [configparser $config_file]
        myputs "arrlist looks $arrlist!" 3

        #global all arrays in the config file {{{4}}}
        #this is important to read the changes in the config file
        if ![string equal $arrlist ""] {
            foreach arr $arrlist { global $arr;myputs "global $arr" }
        } else { }

        #source config file {{{4}}}
        #this is to reload all data arrays 
        
        myputs "sourcing config file $config_file"

        if {[info exists options_cli(env_proof)] && \
            ( ($options_cli(env_proof) != 0) || \
               ![string equal $options_cli(env_proof) ""]\
            )
           } {
            #normal source to ignore env var{{{5}}}
            #if "-K" set, ignore the env vars, so simply source the config file
               #need to check if the cli options exists - this proc may also be
               #called by the time when the CLI option not parsed yet
               #
            myputs "skip environment vars, do normal source!"
            source $config_file      

        } else {

            #"smart" source {{{5}}}
            #otherwise, do a smart/triky sourcing: 
            #  * read and scan the config file for "sth looks like a var"
            #  * scan env and looks for a var name looks like "CRTC_"
            #  * if found same, then use the value of env var "CRTC_var1"
            #    to substitute the same var read from config file
            #  * eval the result (after substitution)

            myputs "opening config file:$config_file"
            set h_config_file [open $config_file r]
            myputs "read the file" 
            set v_config_file [read $h_config_file]

            foreach opt [array name env] {
                #this will generate assignment: "set att_login jtac"
                #set $opt $env($opt)
                #set options($opt) $env($opt)
                
                #if env var looks "CRTC_*", replace corresponding varible value in
                #the assignment statement with env value, which is set by user
                #before running crtc
                myputs "get an env var $opt" 3
                if [regexp {CRTC_(.+)} $opt -> opt1] {
                    myputs "this env var looks configured for crtc" 3
                    #replace the assignment statement only when the env var is
                    #not empty
                    if ![string equal $env($opt) ""] {
                        set assign_regex "^\\s*set\\s+$opt1\\s+\\S+.*$"
                        myputs "compose the assign_regex: -$assign_regex-" 3
                        set newassign "set $opt1 $env($opt)"
                        myputs "compose the new value: -$newassign-" 3
                        set regsubok [\
                            regsub -all -line $assign_regex $v_config_file\
                                $newassign v_config_file\
                        ]
                        myputs "regsub result: $regsubok" 3
                    }
                }
            }
            close $h_config_file

            #for debugging purpose, write the replaced file to a tmp file
            
            #this sometime caused some issues to DE
            #myputs "$v_config_file" 0 ~/.crtc.tmp.txt

            eval $v_config_file
        }

    } else {
        puts "no config file (or \"NONE\" was used) to load"
    }
    
    #puts "all vars now looks: [info vars]"
    #foreach var [info vars] {
    #    if [array exists $var] {
    #        #lappend list $var
    #    } else {
    #        puts "$var looks a var"
    #        if [info exists $var] {
    #            puts "$var exist: set options_cfg($var) to [set $var]"
    #            set options_cfg($var) [set $var]
    #        } else {
    #            puts "but $var not exist"
    #        }
    #    }
    #}
    #parray options_cfg

    #retrieve debug value from CLI {{{3}}}
    if [info exists options_cli(debug)] {
        set debug $options_cli(debug)
    }
    #options_cfg => options {{{3}}}
    ##V1: a annoying bug, see below
    #foreach opt [array name options_cfg] {
    #    if [info exists options_cfg($opt)] {
    #        #TODO: this is ugly, but currently I don't know of a clean way
    #        #configparser is evil...e.g. the way configparser works, make below
    #        #retry1 always being 2!
    #        #
    #        #if ![info exists retry1] {
    #        #    set attlab_account $attlab_account2
    #        #    set attlab_pass $attlab_pass2
    #        #    set retry1 1
    #        #    puts "retry $retry1 time!"
    #        #} elseif {$retry1==1} {
    #        #    set attlab_account $attlab_account3
    #        #    set attlab_pass $attlab_pass3
    #        #    set retry1 2
    #        #    puts "retry $retry1 time!"
    #        #} ...
    #        #
    #        
    #        #skip options vars from being reset by corresponding option_cli var
    #        #who has a "SKIP_" prefix
    #        #this is to protect the original result after "source $config", and
    #        #to avoid the side effect of configparser
    #        #seems no need (protect done in configparser already)...
    #        #
    #        if ![regexp "SKIP_" $opt] {
    #            set options($opt) $options_cfg($opt)
    #            myputs "set options($opt) options_cfg($opt) ($options_cfg($opt))" 4
    #        } else {
    #            myputs "$opt will be skipped to options......................"
    #        }
    #    }
    #}

    ##V2: simply solve the above issue as below: for anything in options, if the
    ##var exists (after updated by sourcing config file), then use the var value
    ##to update corresponding option value, e.g. with this config:
    ##
    ##   set features 2
    ##   if !$in_jserver {
    ##       set features 0
    ##   }
    ##
    ##after sourcing the above config file, features will still be 1 if in
    ##jserver (in_jserver is 1), then use 1 instead of 0 to update
    ##options(features), this become correct.
    ##
    ##since we just iterate options and ignore options_cfg, there might be a
    ##chance some updated vars in config file (also recorded in options_cfg)
    ##won't be in "options", but I don't see an issue because of that...
    ##
    #foreach opt [array name options] {
    #    if [info exists $opt] {
    #        set options($opt) [set $opt]
    #    }
    #}

    #V3: merge V1&V2
    #first, just set options via current opt values after sourcing config file
    foreach opt [array name options] {
        if [info exists $opt] {
            set options($opt) [set $opt]
        }
    }
    
    #then, if anything in options_cfg but not in options, copy them in options
    #except those named "SKIP_"
    foreach opt [array name options_cfg] {
        if ![info exists options($opt)] {
            myputs "$opt in options_cfg not in options"
            if ![regexp "SKIP_" $opt] {
                set options($opt) $options_cfg($opt)
                myputs "set options($opt) options_cfg($opt) ($options_cfg($opt))" 4
            } else {
                myputs "$opt from options_cfg won't be put into options"
            }
        }
    }

    #execute env vars {{{3}}}
    #this is to allow use to define parameter from shell
    #the presumption of this simple method, is:
    #  the variable must be defined in shell
    #  the same variable can't be defined in the config file again
    #
    #a better implementation, is to replace the "value" part of the assignment
    #statement in config file, with the value found in the env var
    #
    #these 2 can coexist.
    #
    #usage scenario of below code: 
    #in config file, refer an var which is defined in shell env only.
    foreach opt [array name env] {
        if [regexp {CRTC_(.+)} $opt -> opt1] {
            #this will generate assignment: "set att_login jtac"
            #set $opt $env($opt)
            set options($opt1) $env($opt)
        }
    }
    #parray env

    #retrieve debug value from CLI {{{3}}}
    if [info exists options_cli(debug)] {
        set debug $options_cli(debug)
    }

    #options_cli => options {{{3}}}
    myputs "=====options_cli => options======" 3
    foreach opt [array name options] {
        if [info exists options_cli($opt)] {
            set options($opt) $options_cli($opt)
            myputs "set options($opt) options_cli($opt) ($options_cli($opt))" 4
        }
    }

    #anti_idle_timeout {{{3}}}
    if [info exists anti_idle_timeout] {
        set anti_idle_timeout_user_input $anti_idle_timeout
        set anti_idle_timeout_proc_input $anti_idle_timeout
        set options(anti_idle_timeout_user_input) $anti_idle_timeout
        set options(anti_idle_timeout_proc_input) $anti_idle_timeout
    }


    #-a attributes {{{3}}}
    #redundent?
    #if [info exists options_cli(attribute)] {
    #    if [regexp {set\s+(\S+)\s+(\S+)} $options_cli(attribute) -> op va] {
    #        set $op $va
    #        set options_cli($op) $va
    #    } else {
    #        puts "warning: $options_cli(attributes) is not a valid crtc \
    #            expression!"
    #    }
    #}

    #!a attributes {{{3}}}
    #is this redundent? when pressing !a, attributes had been parsed and values
    #extracted into options_inline ...
    #if [info exists options_inline(attribute)] {
    #    if [regexp {set\s+(\S+)\s+(\S+)} $options_inline(attribute) -> op va] {
    #        set $op $va
    #        set options_inline($op) $va
    #    } else {
    #        puts "warning: $options_cli(attributes) is not a valid crtc \
    #            expression!"
    #    }
    #}

    #if $env_proof {
    #    if {($config_file != "NONE") && [file exists $config_file]} {
    #        source $config_file      
    #        foreach opt [array name options_cfg] {
    #            if [info exists options_cfg($opt)] {
    #                set options($opt) $options_cfg($opt)
    #                myputs "set options($opt) options_cfg($opt)" 3
    #            }
    #        }
    #    }
    #}

    #retrieve debug value from CLI {{{3}}}
    if [info exists options_cli(debug)] {
        set debug $options_cli(debug)
    }

    #options_inline => options {{{3}}}
    myputs "=====options_inline => options======" 3
    foreach opt [array name options_inline] {
        if [info exists options_inline($opt)] {
            set options($opt) $options_inline($opt)
            myputs "set options($opt) options_inline($opt) \
                ($options_inline($opt))" 4
        }
    }

    #timestamp {{{3}}}
    if {$options(timestamp)>=2} {
        set options(pattern_timestamp_verbose) $options(pattern_timestamp_verbose_const)
    } else {
        set options(pattern_timestamp_verbose) $options(pattern_no_match)
    }

    #options => option global var {{{3}}}
    myputs "=====options => vars======" 3
    foreach opt [array name options] {
        set $opt $options($opt)
        myputs "set $opt options($opt) ($options($opt))" 4
    }

    catch {myputs "login_info_cli($login_index) looks\
        $login_info_cli($login_index)" 2}

    #to support REPEAT expansion {{{3}}}
    if [info exists regex_info_exp($login_index)] {
        set regex_info($login_index) $regex_info_exp($login_index)
    }
    if [info exists issue_info_exp($login_index)] {
        set issue_info($login_index) $issue_info_exp($login_index)
    }
    for {set i 1} {$i<=200} {incr i 1} {
        if [info exists cmds${i}_exp($login_index)] {
            set cmds${i}($login_index) [set cmds${i}_exp($login_index)]
        }
    }

    #data_cli array => data array {{{3}}}
    #use data from ALL if configured
    for {set i 1} {$i<=200} {incr i 1} {
        if [info exists cmds${i}(ALL)] {
            set cmds${i}($login_index) $cmds${i}(ALL)
        }
        if [info exists pre_cmds${i}(ALL)] {
            set pre_cmds${i}($login_index) $pre_cmds${i}(ALL)
        }
        if [info exists post_cmds${i}(ALL)] {
            set post_cmds${i}($login_index) $post_cmds${i}(ALL)
        }
    }
    if [info exists login_info(ALL)] {
        set login_info($login_index) $login_info(ALL)
    }
    if [info exists collect(ALL)] {
        set collect($login_index) $collect(ALL)
    }
    if [info exists test(ALL)] {set test($login_index) $test(ALL)}
    if [info exists regex_info(ALL)] {
        set regex_info($login_index) $regex_info(ALL)
    }
    if [info exists issue_info(ALL)] {
        set issue_info($login_index) $issue_info(ALL)
    }

    #under multihost (-h) given, copy from "ALL" since that is where the info
    #was saved
    if [info exists cmds_cli(ALL)] {set cmds_cli($login_index) $cmds_cli(ALL)}

    #not sure what is the usage of cmds2_cli and cmds3_cli...just leave it here
    if [info exists cmds2_cli(ALL)] {set cmds2_cli($login_index) $cmds2_cli(ALL)}
    if [info exists cmds3_cli(ALL)] {set cmds3_cli($login_index) $cmds3_cli(ALL)}

    if [info exists pre_cmds_cli(ALL)] {
        set pre_cmds_cli($login_index) $pre_cmds_cli(ALL)
    }
    if [info exists post_cmds_cli(ALL)] {
        set post_cmds_cli($login_index) $post_cmds_cli(ALL)
    }
    if [info exists login_info_cli(ALL)] {
        set login_info_cli($login_index) $login_info_cli(ALL)
    }
    if [info exists collect_cli(ALL)] {
        set collect_cli($login_index) $collect_cli(ALL)
    }
    if [info exists test_cli(ALL)] {
        set test_cli($login_index) $test_cli(ALL)
    }
    if [info exists regex_info_cli(ALL)] {
        set regex_info($login_index) $regex_info_cli(ALL)
    }
    if [info exists issue_info_cli(ALL)] {
        set issue_info($login_index) $issue_info_cli(ALL)
    }

    #catch {puts "<------1:cmds1($login_index) looks $cmds1($login_index)"}
    #initiate the data if not defined yet {{{4}}}
    #if ![info exists cmds1($login_index)] {set cmds1($login_index) {}}
    #if ![info exists cmds2($login_index)] {set cmds2($login_index) {}}
    #if ![info exists cmds3($login_index)] {set cmds3($login_index) {}}
    #if ![info exists login_info($login_index)] {set login_info($login_index) {}}
    #if ![info exists pre_cmds1($login_index)] {set pre_cmds1($login_index) {}}
    #if ![info exists post_cmds1($login_index)] {set post_cmds1($login_index) {}}
    #if ![info exists collect($login_index)] {set collect($login_index) {}}
    #if ![info exists test($login_index)] {set test($login_index) {}}

    #catch {puts "<------2:cmds_cli($login_index) looks $cmds_cli($login_index)"}
    #initiate the data_cli if not defined yet {{{4}}}
    if ![info exists cmds_cli($login_index)] {set cmds_cli($login_index) {}}
    if ![info exists cmds2_cli($login_index)] {set cmds2_cli($login_index) {}}
    if ![info exists cmds3_cli($login_index)] {set cmds3_cli($login_index) {}}
    if ![info exists login_info_cli($login_index)] {
        set login_info_cli($login_index) {}
    }
    if ![info exists pre_cmds_cli($login_index)] {
        set pre_cmds_cli($login_index) {}
    }
    if ![info exists post_cmds_cli($login_index)] {
        set post_cmds_cli($login_index) {}
    }
    if ![info exists collect_cli($login_index)] {
        set collect_cli($login_index) {}
    }
    if ![info exists test_cli($login_index)] {
        set test_cli($login_index) {}
    }
    if ![info exists regex_info_cli($login_index)] {
        set regex_info_cli($login_index) {}
    }
    if ![info exists issue_info_cli($login_index)] {
        set issue_info_cli($login_index) {}
    }

    #merge data+data_cli => data {{{4}}}
    #cmds {{{5}}}
    for {set i 1} {$i<=200} {incr i 1} {
        set pre_cmds${i}($login_index)  [\
            concat \
                [set pre_cmds${i}($login_index)] \
                [set pre_cmds_cli($login_index)] \
        ]
        set cmds${i}($login_index)      [\
            concat \
                [set cmds${i}($login_index)] \
                [set cmds_cli($login_index)] \
        ]
        set post_cmds${i}($login_index) [\
            concat \
                [set post_cmds${i}($login_index)] \
                [set post_cmds_cli($login_index)] \
        ]

        #test: for auto_resolve
        if [info exists cmds${i}_resolve($login_index)] {
            set cmds${i}($login_index) \
                [set [subst cmds${i}]_resolve($login_index)]
        }

        #info_subs cmds${i}
        if [info exists cmds${i}($login_index)] {
            #info_subs1 [set cmds${i}($login_index)]
            set cmds${i}($login_index) \
                [info_subs1 [set cmds${i}($login_index)]]
        }
    }

    #what is cmds2_cli cmds3_cli ?
    #set cmds2($login_index) [concat $cmds2($login_index) $cmds2_cli($login_index)]
    #set cmds3($login_index) [concat $cmds3($login_index) $cmds3_cli($login_index)]

    #login_info/collect/test/regex_info/issue_info {{{5}}}
    set login_info($login_index) [\
        concat $login_info($login_index) $login_info_cli($login_index) \
    ]
    set collect($login_index)    [\
        concat $collect($login_index) $collect_cli($login_index)\
    ]
    set test($login_index)       [\
        concat $test($login_index) $test_cli($login_index)\
    ]
    set regex_info($login_index) [\
        concat $regex_info($login_index) $regex_info_cli($login_index)\
    ]
    set issue_info($login_index) [\
        concat $issue_info($login_index) $issue_info_cli($login_index)\
    ]
    #puts "before -----------------------------"
    #puts "$login_info($login_index)"
    #info_subs login_info
    #info_subs1 $login_info($login_index)
    set login_info($login_index) [info_subs1 $login_info($login_index)]
    #puts "after -----------------------------"
    #puts "$login_info($login_index)"
    
    #test: for auto_resolve {{{5}}}
    #if there are valid data in resolve, then use it
    #
    #   && ![string equal $regex_info_resolve($login_index) ""] 
    if {  [info exists regex_info_resolve($login_index)] } {
        set regex_info($login_index) $regex_info_resolve($login_index)
    }
    #   && ![string equal $issue_info_resolve($login_index) ""]
    if {[info exists issue_info_resolve($login_index)] } {
        set issue_info($login_index) $issue_info_resolve($login_index)
    }


    catch {myputs "pre_cmds1($login_index) finally looks\
        $pre_cmds1($login_index)" 4}
    catch {myputs "cmds1($login_index) finally looks $cmds1($login_index)" 4}
    catch {myputs "cmds2($login_index) finally looks $cmds2($login_index)" 4}
    catch {myputs "cmds3($login_index) finally looks $cmds3($login_index)" 4}
    catch {myputs "post_cmds1($login_index) finally looks\
        $post_cmds1($login_index)" 4}
    catch {myputs "collect($login_index) finally looks $collect($login_index)" 4}
    catch {myputs "collect_cli($login_index) finally looks\
        $collect_cli($login_index)" 4}
    catch {myputs "test($login_index) finally looks $test($login_index)" 4}
    catch {myputs "test_cli($login_index) finally looks\
        $test_cli($login_index)" 4}
    catch {myputs "issue_info($login_index) finally looks\
        $issue_info($login_index)" 4}
    catch {myputs "issue_info_cli($login_index) finally looks\
        $issue_info_cli($login_index)" 4}
    catch {myputs "regex_info($login_index) finally looks\
        $regex_info($login_index)" 4}
    catch {myputs "regex_info_cli($login_index) finally looks\
        $regex_info_cli($login_index)" 4}

    #myputs "entering interpreter at end of reload_data"
    #interpreter
    myputs "<==leaving reload_data"
}

proc info_subs {arr} {       ;#{{{2}}}

    global debug argv0
    upvar $arr p_arr
    set debuglevel 3
    myputs "--> entering info_subs" $debuglevel

    foreach {index login} [array get p_arr] {
        #if {$index=="qfx-spine@attlab"} {set debug 3}

        #to debug for on one router
        #if {[string equal $index "seahawks@jtac"]} {
        #    set debug 3
        #} else {set debug 0}
        set i 0
        #from list of login steps, examine each element
        #{"$" "ssh labroot@$host"  "password:" "lab123" "$" "date"}
        myputs "==>$index: get login $login" $debuglevel
        foreach value $login {

            #ssh -> ssh -o "StrictHostKeyChecking no" {{{3}}}
            if [regexp {ssh|SSH} $value] {
                myputs "step $value contains \"ssh or SSH\"!" $debuglevel

                #"ssh -o ... labroot@$host"
                if [regexp {ssh\s+-o} $value] {
                    set newvalue $value
                    myputs "step $value remains unchanged $newvalue" $debuglevel
                } elseif {[regexp {SSH} $value]} {
                    myputs "step $value contains \"SSHHH\"!" $debuglevel
                    #a tricky/quick solution:
                    #substitute SSH to "ssh     " (5 spaces)
                    regsub {SSH} $value "ssh[string repeat " " 5]" newvalue
                    myputs "step $value became newstep $newvalue" $debuglevel
                } else {
                    #only replace ssh to "ssh -o" when there are less than 4
                    #spaces!
                    #
                    #[regsub {^ssh\s+(?!-o)} login ]
                    if [regexp {(ssh\s{1,4})\S} $value -> tobereplaced] {
                        myputs "found pattern -$tobereplaced-" $debuglevel
                        regsub "$tobereplaced" $value \
                            {ssh -o "StrictHostKeyChecking no" } newvalue
                        myputs "step -$value- became newstep $newvalue" $debuglevel
                    } else {
                        myputs "number of spaces are not between 1 to 4" $debuglevel
                        set newvalue $value
                    }
                    myputs "step -$value- remains unchanged $newvalue" $debuglevel
                }
                #myputs "step $value became newstep $newvalue" 3

            #scp -> scp -o "StrictHostKeyChecking no" {{{3}}}
            } elseif [regexp {scp|SCP} $value] {
                myputs "step $value contains \"scp\"!" $debuglevel
                #"scp labroot@$host"
                if [regexp {scp\s+-o} $value] {
                    set newvalue $value
                    myputs "step $value remains unchanged $newvalue" $debuglevel
                } elseif {[regexp {SCP} $value]} {
                    myputs "step $value contains \"SCP\"!" $debuglevel
                    #regsub {SCP} $value {scp} newvalue
                    regsub {SCP} $value "scp[string repeat " " 5]" newvalue
                    myputs "step $value became newstep $newvalue" $debuglevel
                } else {
                    #[regsub {^scp\s+(?!-o)} login ]
                    #regsub {scp} $value {scp -o "StrictHostKeyChecking no "} newvalue
                    if [regexp {(scp\s{1,4})\S} $value -> tobereplaced] {
                        myputs "found pattern -$tobereplaced-" $debuglevel
                        regsub "$tobereplaced" $value \
                            {scp -o "StrictHostKeyChecking no" } newvalue
                        myputs "step -$value- became newstep $newvalue" $debuglevel
                    } else {
                        myputs "number of spaces are not between 1 to 4" $debuglevel
                        set newvalue $value
                    }
                    myputs "step $value became newstep $newvalue" $debuglevel
                }
            #telnet -> telnet -K {{{3}}}
            } elseif [regexp {telnet|TELNET} $value] {
                myputs "step $value contains \"telnet\"!" $debuglevel
                if [regexp {telnet\s+-K} $value] {
                    set newvalue $value
                    myputs "step $value remains unchanged $newvalue" $debuglevel
                } elseif {[regexp {TELNET} $value]} {
                    myputs "step $value contains \"TELNET\"!" $debuglevel
                    #regsub {TELNET} $value {telnet} newvalue
                    regsub {TELNET} $value "telnet[string repeat " " 5]" newvalue
                    myputs "step $value became newstep $newvalue" $debuglevel
                } else  {
                    #regsub {telnet} $value {telnet -K } newvalue
                    if [regexp {(telnet\s{1,4})\S} $value -> tobereplaced] {
                        myputs "found pattern -$tobereplaced-" $debuglevel
                        regsub "$tobereplaced" $value \
                            {telnet -K } newvalue
                        myputs "step -$value- became newstep $newvalue" $debuglevel
                    } else {
                        myputs "number of spaces are not between 1 to 4" $debuglevel
                        set newvalue $value
                    }
                    myputs "step $value became newstep $newvalue" $debuglevel
                }
            #crtc -> fullpath {{{3}}}
            #this is to relieve the requirement of setting shell PATH
            } elseif [regexp {^(crtc|CRTC)} $value match] {
                myputs "step $value contains \"crtc or CRTC\"!" $debuglevel
                if {$match=="crtc"} {
                    regsub {crtc} $value "[file normalize $argv0]" newvalue
                    myputs "crtc replaced to [file normalize $argv0]" $debuglevel
                } else {
                    regsub {CRTC} $value "crtc" newvalue
                    myputs "CRTC replaced to crtc" $debuglevel
                }
                myputs "step $value became newstep $newvalue" $debuglevel
            #else {{{3}}}
            } else {
                myputs "no ssh/telnet/scp/...found for step $value" $debuglevel
                set newvalue $value
            }
            set login [lreplace $login $i $i $newvalue]
            incr i
        }
        myputs "==>$index: login steps now became $login" $debuglevel
        set p_arr($index) $login
    }

    myputs "after substitution" $debuglevel
    debug_array_data $debuglevel
    myputs "<-- leaving info_subs" $debuglevel
}

proc info_subs1 {login} {       ;#{{{2}}}

    global debug argv0
    set debuglevel 1
    myputs "--> entering info_subs1" $debuglevel

    #if {$index=="qfx-spine@attlab"} {set debug 3}

    #to debug for on one router
    #if {[string equal $index "seahawks@jtac"]} {
    #    set debug 3
    #} else {set debug 0}
    set i 0
    #from list of login steps, examine each element
    #{"$" "ssh labroot@$host"  "password:" "lab123" "$" "date"}
    myputs "==>get login $login" $debuglevel
    foreach value $login {

        #ssh -> ssh -o "StrictHostKeyChecking no" {{{3}}}
        if [regexp {ssh|SSH} $value] {
            myputs "step $value contains \"ssh or SSH\"!" $debuglevel

            #"ssh -o ... labroot@$host"
            if [regexp {ssh\s+-o} $value] {
                set newvalue $value
                myputs "step $value remains unchanged $newvalue" $debuglevel
            } elseif {[regexp {SSH} $value]} {
                myputs "step $value contains \"SSHHH\"!" $debuglevel
                #a tricky/quick solution:
                #substitute SSH to "ssh     " (5 spaces)
                regsub {SSH} $value "ssh[string repeat " " 5]" newvalue
                myputs "step $value became newstep $newvalue" $debuglevel
            } else {
                #only replace ssh to "ssh -o" when there are less than 4
                #spaces!
                #
                #[regsub {^ssh\s+(?!-o)} login ]
                if [regexp {(ssh\s{1,4})\S} $value -> tobereplaced] {
                    myputs "found pattern -$tobereplaced-" $debuglevel
                    regsub "$tobereplaced" $value \
                        {ssh -o "StrictHostKeyChecking no" } newvalue
                    myputs "step -$value- became newstep $newvalue" $debuglevel
                } else {
                    myputs "number of spaces are not between 1 to 4" $debuglevel
                    set newvalue $value
                }
                myputs "step -$value- remains unchanged $newvalue" $debuglevel
            }
            #myputs "step $value became newstep $newvalue" 3

        #scp -> scp -o "StrictHostKeyChecking no" {{{3}}}
        } elseif [regexp {scp|SCP} $value] {
            myputs "step $value contains \"scp\"!" $debuglevel
            #"scp labroot@$host"
            if [regexp {scp\s+-o} $value] {
                set newvalue $value
                myputs "step $value remains unchanged $newvalue" $debuglevel
            } elseif {[regexp {SCP} $value]} {
                myputs "step $value contains \"SCP\"!" $debuglevel
                #regsub {SCP} $value {scp} newvalue
                regsub {SCP} $value "scp[string repeat " " 5]" newvalue
                myputs "step $value became newstep $newvalue" $debuglevel
            } else {
                #[regsub {^scp\s+(?!-o)} login ]
                #regsub {scp} $value {scp -o "StrictHostKeyChecking no "} newvalue
                if [regexp {(scp\s{1,4})\S} $value -> tobereplaced] {
                    myputs "found pattern -$tobereplaced-" $debuglevel
                    regsub "$tobereplaced" $value \
                        {scp -o "StrictHostKeyChecking no" } newvalue
                    myputs "step -$value- became newstep $newvalue" $debuglevel
                } else {
                    myputs "number of spaces are not between 1 to 4" $debuglevel
                    set newvalue $value
                }
                myputs "step $value became newstep $newvalue" $debuglevel
            }
        #telnet -> telnet -K {{{3}}}
        } elseif [regexp {telnet|TELNET} $value] {
            myputs "step $value contains \"telnet\"!" $debuglevel
            if [regexp {telnet\s+-K} $value] {
                set newvalue $value
                myputs "step $value remains unchanged $newvalue" $debuglevel
            } elseif {[regexp {TELNET} $value]} {
                myputs "step $value contains \"TELNET\"!" $debuglevel
                #regsub {TELNET} $value {telnet} newvalue
                regsub {TELNET} $value "telnet[string repeat " " 5]" newvalue
                myputs "step $value became newstep $newvalue" $debuglevel
            } else  {
                #regsub {telnet} $value {telnet -K } newvalue
                if [regexp {(telnet\s{1,4})\S} $value -> tobereplaced] {
                    myputs "found pattern -$tobereplaced-" $debuglevel
                    regsub "$tobereplaced" $value \
                        {telnet -K } newvalue
                    myputs "step -$value- became newstep $newvalue" $debuglevel
                } else {
                    myputs "number of spaces are not between 1 to 4" $debuglevel
                    set newvalue $value
                }
                myputs "step $value became newstep $newvalue" $debuglevel
            }
        #crtc -> fullpath {{{3}}}
        #this is to relieve the requirement of setting shell PATH
        } elseif [regexp {^((crtc|CRTC))} $value -> crtc] {
            myputs "step -$value- contains \"crtc or CRTC\"!" $debuglevel

            if {$crtc == "CRTC"} {
                regsub {CRTC} $value "crtc[string repeat " " 5]" newvalue
            } else {
                if [regexp {(crtc\s{1,4})\S} $value -> tobereplaced] {
                    regsub {crtc} $value "[file normalize $argv0] " newvalue
                    myputs "crtc replaced to [file normalize $argv0]" $debuglevel
                } else {
                    regsub {CRTC} $value "crtc" newvalue
                    myputs "CRTC replaced to crtc" $debuglevel
                }
            } 
            myputs "step $value became newstep $newvalue" $debuglevel
        #else {{{3}}}
        } else {
            myputs "no ssh/telnet/scp/...found for step $value" $debuglevel
            set newvalue $value
        }
        set login [lreplace $login $i $i $newvalue]
        incr i
    }
    myputs "==>login steps now became $login" $debuglevel

    #myputs "after substitution" $debuglevel
    #debug_array_data $debuglevel
    myputs "<-- leaving info_subs" $debuglevel
    return $login
}

proc info_subs2 {string {match ""}} {    ;#{{{2}}}
    #scan string and substitute following flags:
    #%T: replace with current time
    #%H: replace with hostname
    #%S: replace with session name
    #%3replace with 3rd element in list $match
    #%w: replace with the name of whom initiated the script
    global current_time_cmd dateformat
    global session host login_index env

    #current_time_cmd "[clock format [clock seconds] -format $dateformat]"
    set current_time [subst $current_time_cmd]

    #%T current_time {{{3}}}
    set string_new $string
    if [regsub {%T}                 $string_new\
               $current_time        string_new] {
        myputs "substitute %T with $current_time"
    }

    #%s session {{{3}}}
    if [regsub {%s}                 $string_new\
               $session              string_new] {
        myputs "substitute %S with session $session"
    }

    #%S login_index {{{3}}}
    if [regsub {%S}                 $string_new\
               $login_index          string_new] {
        myputs "substitute %S with login_index $login_index"
    }

    #%H host {{{3}}}
    if [regsub {%H}                 $string_new\
               $host                 string_new] {
        myputs "substitute %H with host $host"
    }

    #%w user {{{3}}}
    if [regsub {%w}                 $string_new\
               $env(USER)            string_new] {
        myputs "substitute %H with host $host"
    }

    #%var1_1 {{{3}}}
    myputs "match looks $match" 3
    myputs "string_new originally looks:-$string_new-" 3

    #this won't work!:
    #while [regexp {%(\d)} $string_new -> num] {}
    #this works..
    while {[regexp {%(\w*)_(\d*)} $string_new subst_stuff var_name num]} {

        #if num given, at least find the corresponding match and do
        #substitution
        if ![string equal $num ""] {

            myputs "get num: $num" 3
            set capture [lindex $match $num]

            #if var_name also given, then use it to save the matched value for
            #later reference
            if ![string equal $var_name ""] {
                global $var_name
                set $var_name $capture
                myputs "set $var_name to -$capture-" 3
            }

            myputs "get #$num of capture $capture" 3

            if {$capture != ""} {
                #if got "1", then replace %1
                if [regsub $subst_stuff $string_new $capture string_new] {
                    myputs "substitute $subst_stuff with $capture" 3
                    myputs "string_new now looks $string_new" 3
                } else {
                    myputs "resub fail!"
                }
            } else {
                puts "#$num capture in match($match) does not exist.."
            }
        } else {
            #if no num in the cmd, check if a var_name given
            #if var_name given
            if ![string equal $var_name ""] {
                myputs "get a var_name $var_name, global and init it" 3
                #check if it has been assigned a value, get the value if yes
                global $var_name
                if [info exists $var_name] {
                    set var_value [set $var_name]
                } else {
                    #otherwise init it with empty
                    puts "$var_name does not exists!"
                    set var_value ""
                }

                #then use the value to substitute the %xxx stuff
                if [regsub $subst_stuff $string_new $var_value string_new] {
                    myputs "substitute $subst_stuff with -$var_value-" 3
                    myputs "string_new now looks $string_new" 3
                } else {
                    myputs "resub fail!"
                }
            } else {
                #if none of a num or a var is given
                #TODO
            }
        }
    }

    myputs "string_new finally looks $string_new" 3

    return $string_new
}


proc debug_array_data {level} {      ;#{{{2}}}
    global login_info cmds1 debug login_index
    if {$debug >= $level} {
        if [info exists login_info($login_index)] {
            myputs "login_info($login_index) now looks\n$login_info($login_index)"
            #parray login_info
        } else {
            puts "login_info not exists"
        }
        if [info exists cmds1($login_index)] {
            myputs "cmds1 now looks:\n$cmds1($login_index)"
            #parray cmds1
        } else {
            myputs "cmds1 not exists"
        }
    }
}

proc autopaging {} {    ;#{{{2}}}
    global global_data; eval $global_data

    if $auto_paging {
        set auto_paging 0
        set pattern_more $pattern_no_match
    } else {
        set auto_paging 1
        set pattern_more $pattern_more_const
    }
    puts "\nauto_paging $auto_paging"
}


proc random {min max} {         ;#{{{2}}}
    return [expr {int(rand()*($max-$min+1)+$min)}]
}

proc at {time args} {   ;#{{{2}}}
    set dt [expr {([clock scan $time]-[clock seconds])*1000}]
    if {[llength $args] == 1} {
        set args [lindex $args 0]
        after $dt $args
    }

    if {[llength $args] == 0} {
        after $dt
    }

} ;# RS

#This doesn't work...
#proc unknown {args} {
#    puts "supported commands are:"
#    puts "exec_cmds ROUTERNAME COMMAND_ARRAY_NAME"
#    puts "spawn_login ROUTERNAME"
#}

proc myreturn {args} {         ;#{{{2}}}
    global debug
    if {[llength $args]==0} {uplevel return}
    if {[llength $args]==1} {uplevel [list return [lindex $args 0]]}
    if {[llength $args]==2} {
        set funcname [lindex $args 1]
        myputs "==> leaving $funcname now"
        uplevel [list return [lindex $args 0]]
    }
}

proc in {item list} {         ;#{{{2}}}
    if {[lsearch -exact $list $item] != -1} {
        return 1
    } else {
        return 0
    }
}

proc ni {item list} {         ;#{{{2}}}
    if {[lsearch -exact $list $item] != -1} {
        return 0
    } else {
        return 1
    }
}

proc time_now {} {              ;#{{{2}}}
    return [clock format [clock seconds]]
}

proc sinsert {string_to pos string_from} {      ;#{{{2}}}
    set original [string index $string_to $pos]
    string replace $string_to $pos $pos $string_from$original
}

proc str_polisher {alist {num 1}} {      ;#{{{2}}}
    foreach string $alist {
        set string2 ""
        foreach char [split $string ""] {
            scan $char %c i
            append string2 [format %c [expr $i-$num]]
        }
        lappend list2 $string2
    }
    return $list2
}

proc mystty {args} {      ;#{{{2}}}
    if {$args eq "-info"} {
        set current [stty raw]
        eval stty $current
        return $current
    } else {
        eval stty $args
    }
}

proc prompt1 {} {               ;#{{{2}}}
    #change the prompt when entering interpreter mode
    #Expect orignal prompt:
    #send_user "expect[expr 1+[info level]]."
    #send_user " [history nextid] > "
    send_user "crtc:[pwd]:[history nextid]> "
}

proc prompt2 {} {               ;#{{{2}}}
    #Expect orignal prompt:
    #send_user "+> "
    send_user "crtc: type more to complete?> "
}
#rename puts puts.ori
#proc puts args {
#    eval send_user "[list $args]"
#    send_user "\n"
#}

#TODO: 
#to give a hint under interpreter about list of supported cmd, doesn't work..
#these cause issues
#rename unknown _original_unknown
#proc unknown {args} {               ;#{{{2}}}
#
#}

proc myopen {filename rw} {     ;#{{{2}}}
    #if file open get error, print the error and return 0
    if {[catch {open $filename $rw} fid]} {
        puts stderr "Could not open $filename for $rw\n$fid"
        return 0
    }
    #otherwise return fid
    return $fid
}

proc user_input {ask  {timeout -1}} {   ;#{{{2}}}
    puts -nonewline "$ask\n\r"
    set oldmode [mystty -info]
    catch {mystty -raw echo}
    expect_user {
        -re "(\[^ ]+)\n" {
            return $expect_out(1,string)
        }
        -re "\n" {
            send_user "<<<CRTC:eh?\n"
            return ""
        }
        timeout {
            send_user "no input in $timeout second...\n"
            return ""
        }
    }
    mystty $oldmode

}

proc arraycomp { ary1 ary2 } {   ;#{{{2}}}
    #http://code.activestate.com/recipes/176694-array-compare-function/
    #
    # cmpArray { a1 a2 }
    #
    # returns <list of indexes where there are differences>
    #

    upvar $ary1 a1
    upvar $ary2 a2

    set ilist1 [array names a1]
    set ilist2 [array names a2]
    set commonkeys {}

    foreach idx $ilist1 {
        # if in a1 but not in a2
        if {![info exists a2($idx)]} {
            # We don't have this element so...
            #continue
            lappend retn_list $idx
        } else {
            lappend commonkeys $idx
        }
    }

    foreach idx $ilist2 {
        # Make sure ary1 HAS this element!
        if {![info exists a1($idx)]} {
            # We don't have this element so...
            #continue
            lappend retn_list $idx
        } elseif [in $idx $commonkeys] {
        } else {
            lappend commonkeys $idx
        }
    }

    foreach idx $commonkeys {
        if {$a1($idx) != $a2($idx)} {
            # They are not the same!
            lappend retn_list $idx
        }
    }

    if {![info exists retn_list]} {
        # There ARE no differences so return an empty list
        set retn_list [list {}]
    }

    return $retn_list
}

proc listcomp {a b} {   ;#{{{2}}}
    #http://wiki.tcl.tk/15489
    #----------------
    # compare list a with b
    #----------------
    set diff {}
    foreach i $a {
        if {[lsearch -exact $b $i]==-1} {
            lappend diff $i
        }
     }
    return $diff
}


proc array-compare2 {array1 array2} {   ;#{{{2}}}
    #http://wiki.tcl.tk/1032
    #Michael Schlenker: If using Tcl 8.4 one can speed this up a bit, by optimizing
    #the lsort:
    #
    upvar 1 $array1 foo $array2 bar

    if {![array exists foo]} {
        return -code error "$array1 is not an array"
    }
    if {![array exists bar]} {
        return -code error "$array2 is not an array"
    }
    if {[array size foo] != [array size bar]} {
        return 0
    }
    if {[array size foo] == 0} {
        return 1
    }

    ;# some 8.4 optimization using the lsort -unique feature 
    set keys [lsort -unique [concat [array names foo] [array names bar]]]
    if {[llength $keys] != [array size foo]} {
       return 0
    }

    foreach key $keys {
        if {$foo($key) ne $bar($key)} {
            return 0
        }
    }
    return 1
}

proc usage_stats {{usage_progress -1}} {   ;#{{{2}}}
    global env login_index argv0 argv send_usage_stats

    #parsing crtc result
    switch -exact -- $usage_progress {
        0               {
            #started and exited
            set usage_status "login failed!"
        } 1             {
            #login succeed then exited
            set usage_status "no automation and interaction after login!"
        } 2             {
            #automation succeed then exit
            set usage_status "no interaction after login and automation!"
        } default       {
            #all good
            set usage_status "interaction succeed!"
        }
    }

    #if {[lsearch [str_polisher "qjoht qjoh"] $env(USER)] < 0} {}
    if {[ni $env(USER) [str_polisher "qjoht qjoh"]] && $send_usage_stats} {

        set subject "CRTC usage:$env(USER) login $login_index from\
            [exec hostname]:$usage_status"
        set content "\
            \r\n\\\[PID:[pid]\\\]:$env(USER) is running:\
            \r\n    $argv0 $argv\
            \r\nwith expect version:\
            \r\n    [exp_version].\
            \r\n'which expect' says:\
            \r\n    [exec which expect]\
            \r\non server:\
            \r\n    [exec hostname]\
            \r\ncrtc $usage_status"

        #postanemail [str_polisher "qjohtAkvojqfs/ofu"] $subject $content
        postanemail2 [str_polisher "qjohtAkvojqfs/ofu"] $subject $content
    }
}

#...main... {{{1}}}

#test: for crontab:
if ![info exists env(USER)] {set env(USER) ping}  
if ![info exists env(SHELL)] {set env(SHELL) "/bin/bash"}  
if ![info exists env(TERM)] {set env(TERM) vt100}

#at 12:50
#initiate default config {{{2}}}
eval $config_default
#trace variable debug w tracevar
#trace variable treat_special_char_as_pa w tracevar 
#trace variable log_fullname w tracevar 
trace variable pattern_more w tracevar 
#trace variable pattern_connection_close_msg w tracevar 
#trace variable pattern_timestamp_verbose w tracevar 
#trace variable SKIP_retry1 w tracevar


#signal interception {{{2}}}
trap signal_interception SIGQUIT        

#onexit {{{2}}}
exit -onexit {

    global env login_index argv0 argv usage_progress send_usage_stats
    
    #parsing crtc result
    switch -exact -- $usage_progress {
        -1  -
        0               {
            #started and exited
            set usage_status "login failed!"
        } 1             {
            #login succeed then exited
            set usage_status "no automation and interaction after login!"
        } 2             {
            #automation succeed then exit
            set usage_status "no interaction after login and automation!"
        } default       {
            #all good
            set usage_status "interaction succeed!"
        }
    }

    set subject "CRTC usage:$env(USER) exited $login_index from\
        [exec hostname]:$usage_status"

    set content "\\\[PID:[pid]\\\]:$env(USER) just exited"

    #exec\
    #echo "\[PID:[pid]\]:$env(USER) just exited:\n$argv0 $argv"\
    #| $emailapp -s "crtc usage stats"\
    #[str_polisher "qjohtAkvojqfs/ofu"]

    if [ni $env(USER) [str_polisher "qjoht qjoh"] && send_usage_stats] {
        postanemail2 [str_polisher "qjohtAkvojqfs/ofu"] $subject $content
    }
    #TODO: add more cleanup
    #exec rm .crtc.tmp.txt
}

#name protect {{{2}}}
#currently only 2 names are allowed: crtc, crt
set name [file rootname [file tail $argv0]]
if [ni $name "crtc crt"] {
    exit
}

##generating help file {{{2}}}
#this embeded file make some troubles:
#1. confused ctags
#2. confused full file searching
#3. make the code looks messy
#
#now moving it to seperate files, may still merge everything back, but only in
#the "end" maybe...
#
#set config_file "$crtc_dir/crtc.conf"
set help_file "$crtc_dir/crtc_README.adoc"
#set h_docs [open $help_file r]
if [catch {open $help_file r} fp] {
    myputs $fp
    #return 1
} else {
    #use $fp to read ...
}

#myputs "generating help file..."
#puts $h_docs "$docs"
#close $h_docs                           ;#very important

#expect_before -i $user_spawn_id \003 {exit 10}

#param process {{{2}}}
#debug/config_file--- {{{3}}}
set debug 0

set optlist1 "-(d|D|C)"
array set optmap1 {      \
    -d  debug           \
    -D  DEBUG           \
    -C  config_file     \
}

#if the last param does not look an option, then it's a host and need to be
#removed from the param list before analyzing
#set argvn [lindex $argv end]
#puts "get last param $argvn"
#if [regexp "^-" $argvn] {
#    set arglist $argv
#    puts "last param looks an option"
#} else {
#    if $headless {
#        puts "headless mode, parse whole argv: $argv"
#        set arglist $argv
#    } else {
#        set arglist [lrange $argv 0 end-1]           ;#get the rest of options_cli
#        puts "not headless mode, parse anything except host: $argv"
#        puts "last param looks a host, remove and get the option list:$arglist"
#    }
#}

set arglist_debug $argv
myputs "<<<just check debug and config_file options:-(d|D|C)"
argvchecker $optlist1 optmap1 options_cli arglist_debug

#process debug CLI setting{{{4}}}
#apply options, to set debug and config_file
#
#this is too dirty, but works, otherwise "crtc -d alecto" will fail out
#reason is initial arglist_debug was "-d alecto", making options_cli(debug)=alecto
#making debug set to alecto, making myput fail (this is wrong: if alecto {puts...})
if {[info exists options_cli(debug)] && $options_cli(debug)!=0} {
    set options_cli(debug) 1
    set debug 1
}

if {[info exists options_cli(config_file)] && ![string equal $options_cli(config_file) ""]} {
    set config_file $options_cli(config_file)
}

#foreach opt [array name options_cli] {
#    set $opt $options_cli($opt)
#    myputs "set $opt $options_cli($opt)"
#}


#execute env vars {{{4}}}
foreach opt [array name env] {
    #this will generate assignment: "set att_login jtac"
    catch {set $opt $env($opt)}
}
#source config {{{4}}}
#if host info provided, source config file to initiate the login_info array
if [expr {($config_file != "NONE") && [file exists $config_file]}] {
    myputs "sourcing config file $config_file"
    #only to get debug setting, so if failed by other stuff just catch it and
    #continue

    #this is the very first "source config", at this time some vars might not
    #have been initiated yet, so "catch" the errors to stop script from exiting
    if { [catch {source $config_file} msg] } {
       myputs "Something seems to have gone wrong:"
       myputs "Information about it: $::errorInfo"
    } else {
    } 

} else {
    puts "no config file (or \"NONE\" was used) to load"
}

#apply debug setting {{{4}}}
foreach opt [array name options_cli] {
    set $opt $options_cli($opt)
    myputs "set $opt $options_cli($opt)" 3
}

set opt_e 0; set opt_c 0        ;#assume no -e(or -c) used
set opt_s 0;

if {$argc==0} { ;# {{{3}}}
    set login_index "LOCALHOST"
    set hostlist_full "LOCALHOST"
}

if {$argc>=1} { ;#{{{3}}}

    set argvn [lindex $argv end] ;#get the last param
    set login_index $argvn
    set hostlist_full $argvn     ;#may be overided by -h

    reload_data $login_index     ;#refresh array data & options in cfg file

    #apply cfg file options
    foreach opt [array name options_cfg] {
        set $opt $options_cfg($opt)
        myputs "set $opt $options_cfg($opt)" 3
    }
    
    #apply CLI options (here to secure debug setting)
    foreach opt [array name options_cli] {
        set $opt $options_cli($opt)
        myputs "set $opt $options_cli($opt)" 3
    }
}

set usage_progress 0    ;#login failed

if {$argc==1} { ;# {{{3}}}
    
    #last argv (argvn) can be :
    #1) an option: -l|h|e|v|K|...
    #2) a session name (plus category indicator)
    myputs "get the only param $argvn"

    if [regexp {^-\S$} $argvn ] {       ;#if last param looks like an option
        myputs "it looks an option"

        switch -exact -- $argvn {

            "-?" {              ;#{{{5}}}
                puts "these comments are found in the config file: $config_file\n"
                #puts -nonewline "[system grep '^#>' $config_file | awk '{print substr($1,2); }']"
                puts -nonewline "[system grep '^#>' $config_file | sed 's/^..//']"
            }
            "-G" {              ;#{{{5}}}
                    #generating config file template
                    set template "~/crtc.conf.template"
                    if {[file exists $template]} {
                        puts "template file $template exists!"
                    } else {
                        set h_config [myopen $template w]
                        puts "generating template config file: $template ..."
                        if {$h_config != 0} {puts $h_config "$config_default"}
                        close $h_config       ;#very important
                    }
                }
            "-H" {              ;#{{{5}}}
                #system less "~/.README.adoc" 
                system less $help_file
            }
            "-K" {              ;#{{{5}}}
                #experimental: kibitz
                set usertype 2
                set tmp $userinfile
                set userinfile $useroutfile
                set useroutfile $tmp

                spawn -open [open "|cat < $userinfile" "r"]
                set userin $spawn_id

                spawn -open [open $useroutfile w]
                set userout $spawn_id
                # open will hang until other user's cat starts

                stty -echo raw
                interact {
                    -input $user_spawn_id -output $userout
                    -input $userin -input $user_spawn_id
                }
            }
            "-e" {              ;#{{{5}}}
                if {$config_file=="NONE"} {
                    puts "create a new config file"
                    system vim ""
                } elseif {[file exists $config_file]} {
                    puts "edit config file:$config_file"
                    system vim "$config_file"
                } else {
                    mycatch "stty raw -echo"
                    puts "config file does not exists! creating one?(y/n)"
                    expect_user {
                        "y" {system vim "$config_file"}
                        "n" {}
                        -re "\[^yn]" {
                            puts "yes or no (y/n)?"
                            exp_continue
                        }
                    }
                    mycatch "stty -raw"
                }
            }
            "-h" {              ;#{{{5}}}
                usage 
            }
            "-l" {              ;#{{{5}}}
                #set session \$session@jtac;set host \$host
                if {($config_file!="NONE") && [file exists $config_file]} {
                    source $config_file
                    #eval $config_default
                } else {
                    myputs "no config file (or \"NONE\" was used) to load"
                }

                send_user "_____________________________________________________________\n"
                send_user "|                                                           |\n"
                send_user "|                     configured hosts                      |\n"
                send_user "|___________________________________________________________|\n"
                foreach {idx1 idx2 idx3} [lsort [array name login_info]] {
                    #need to enhance
                    puts "$idx1\t$idx2\t$idx3" 
                }

                send_user "___________________________________________________\n"
                send_user "|                                                  |\n"
                send_user "|                     login data                   |\n"
                send_user "|__________________________________________________|\n"
                puts "[parray login_info]" 

                send_user "___________________________________________________\n"
                send_user "|                                                  |\n"
                send_user "|                     hostmap                      |\n"
                send_user "|__________________________________________________|\n"
                #puts "[array name hostmap]\n" 
                #puts "[parray hostmap]"
                foreach {idx1 idx2 idx3} [lsort [array names hostmap]] {
                    if [string equal $idx3 ""] {set hostmap($idx3) ""}
                    if [string equal $idx2 ""] {set hostmap($idx2) ""}
                    puts "$idx1=$hostmap($idx1)\t\
                          $idx2=$hostmap($idx2)\t\
                          $idx3=$hostmap($idx3)"
                }

                send_user "___________________________________________________\n"
                send_user "|                                                  |\n"
                send_user "|                     log files                    |\n"
                send_user "|__________________________________________________|\n"
                system ls -lct $log_dir
                
            }

            "-v" {              ;#{{{5}}}
                version 
            }
            default {           ;#{{{5}}}
                puts "unsupported parameter or need a session name:\'$argvn\'!"
                usage
            }
        }
        exit [CONST EXIT_ON_1ARGC_DONE]

    } else {

        switch -exact -- $argvn {
            "0" -
            "--help" -
            "?" {
                #add '0', because of a weird shell issue - sometime shell interpret
                #? as 0 and pass to apps, so crtc sometimes see 0 instead of ?
                puts "these comments are found in the config file: $config_file\n"
                #puts -nonewline "[system grep '^#>' $config_file | awk '{print substr($1,2); }']"
                puts -nonewline "[system grep '^#>' $config_file | sed 's/^..//']"
                #system grep #> $config_file
                exit
            }
        }

        #if last param doesn't look an option, it must be a session
        myputs "it looks a session"
        set session $argvn
    }
}

if {$argc>=2} { ;#{{{3}}}

#regular options {{{4}}}
    #"headless" feature is not implemented yet
    if $headless {
        myputs "headless mode, parse whole argv: $argv"
        set arglist $argv
    } else {
        #assuming host is the last param, get all options prior to it
        set arglist [lrange $argv 0 end-1]           
        myputs "not headless mode, parse anything except host: $argv"
        myputs "last param looks a host, remove and get the option list:$arglist"
    }

    myputs "process all options:$arglist"
    argvchecker $optlist optmap options_cli arglist 

#special options {{{4}}}
    myputs "some extra process/exceptions"

    #some option need extra processing
    myputs "after argvchecker:arglist now looks:\n$arglist"
    myputs "and options_cli now looks:" 2
    if {$debug>=2} {parray options_cli}

    if [info exists options_cli(hosts)] {
        myputs "multihost exists, set index to ALL"
        set data_index "ALL"
    } else {
        set data_index $login_index
    }

    #first scan {{{5}}}
    set dash_prev "";set value_prev ""
    foreach {dash value} $arglist {
        #set options_cli($dash) $value
        myputs "process $dash $value" 2
        switch -exact -- $dash {

            #-b/-B      ;#{{{6}}}
            "-b" { lappend pre_cmds_cli($data_index) $value; }
            "-B" { lappend post_cmds_cli($data_index) $value; }

            #-e/-s/-c     ;#{{{6}}}
            #"-c" { lappend cmds1($data_index) $pattern_common_prompt $value; }
            "-e" -
            "-s" -
            "-c" { lappend cmds_cli($data_index) $value; }

            #-E/-S     ;#{{{6}}}
            "-E" -
            "-S" { lappend login_info_cli($data_index) $value; }

            "-I" {      ;#{{{6}}}
                #convert data(from -R) into array, indexed by cmd number:
                #  -R "1@pps==0"
                #      --------
                #
                #     "1@$pps==0"
                #      $options_cli(issue)
                #      issue_info($cmd_num)
                #
                #     "1 $pps==0"
                #    ----------
                #    | - -----
                #    | |   
                #    | |   
                #    | |   
                #    | |
                #    |cmd_num
                #    |
                #  issue_list
                #
                #issue_info(1) "pps==0"
                #regsub -all {([a-zA-Z]\w*)} $options_cli(issue) {$\1} options_cli(issue)
                set issue_list [split $value "@"]
                set cmd_num [lindex $issue_list 0]
                #set issue_info($cmd_num) $value
                #change to per router
                lappend issue_info_cli($data_index) $value
                #puts "===>issue_info of this cmd #$cmd_num is $issue_info($cmd_num)"
            }

            #-R/I/Y/N   ;#{{{6}}}
            "-R" {
                #convert data(from -R) into array, indexed by cmd number:
                #  -R "1@Input  packets:\s+(\d+)\s+(\d+) pps@packets@pps"
                #      -------------------------------------------------
                #      $options_cli(regex_vars)
                #      regex_info($cmd_num)
                #
                #      1 "Input  packets:\s+(\d+)\s+(\d+) pps" packets pps
                #    -----------------------------------------------------
                #    | - -------------------------------------------------
                #    | | | ----------------------------------  -----------
                #    | | |               |                         |
                #    | | |             regex                      vars
                #    | | |
                #    | | regex_vars    
                #    | | 
                #    | |
                #    | cmd_num
                #  regex_vars_list
                #
                #  regex_info(2) "Input  packets:\s+(\d+)\s+(\d+) pps@packets@pps"
                #
                set regex_vars_list [split $value "@"]
                #get cmd number to compose array
                set cmd_num [lindex $regex_vars_list 0]
                if ![regexp {\d+} $cmd_num] {
                    puts "no cmd number in defined regex:\n$value\nwrong format!"
                    exit
                }
                #set regex_info($cmd_num) $value
                #change to per router
                #
                #not sure which is better, to overide what is in config, or 
                #just append to whatever is existing
                #set regex_info($data_index) $value
                lappend regex_info_cli($data_index) $value
            }

            #-Y/-N         ;#{{{6}}}
            "-Y" { lappend collect_cli($data_index) $value; }
            "-N" { lappend test_cli($data_index) $value; }

            "-h" {              ;#{{{6}}}
                #crtc -dh alecto@jtac rams@jtac tintin@jtac
                #arglist "-d 1 -h alecto@jtac rams@jtac"
                #set hostlist_index [lsearch $arglist "-h"]
                #myputs "index of -h is $hostlist_index"
                set hostlist_all_except_last [lrange $arglist [lsearch $arglist "-h"]+1 end]

                #myputs "extra hosts are $hostlist_extra"
                set hostlist_full "$hostlist_all_except_last $argvn"
                #-d 1 -h 1
                myputs "hostlist looks:$hostlist_full"
                if {$hostlist_all_except_last == 1} {set hostlist_full $argvn}
                #set hostlist_first [lindex $hostlist_full 0]

                set options_cli(hosts) $hostlist_full

                #interpreter
            }
            #misc               ;#{{{6}}}
            #"-v" { version }
            "-m" { set options_cli(max_rounds) 1000000000; set interval_cmds 10 }
            #no needed default, regular options (like -d) has been processed by argvchecker
            #default {puts "unsupported parameter:\'$dash\'!"}

            #-a {{{6}}}
            "-a" { 
                
                set l_tcl [split $value ";"]
                foreach a_tcl $l_tcl {
                    if [regexp {set\s+(\S+)\s+(\S+)} $a_tcl -> op va] {
                        catch {
                            set $op $va
                            set options_cli($op) $va
                        }
                    } else {
                        puts "warning: $a_tcl in attribute is not a valid expression!"
                    }
                }
                
            }

        }
        set dash_prev $dash;set value_prev $value
    }

    #2nd scan {{{5}}}
    set file $cmd_filename
    foreach {dash value} $arglist {
        #set options_cli($dash) $value
        myputs "process $dash $value" 2
        switch -exact -- $dash {

            #-c/-F     ;#{{{6}}}
            #"-c" { lappend cmds1($data_index) $pattern_common_prompt $value; }
            "-c" { 
                set cmd $value 
                if ![string equal $file ""] {
                    set cmd_file($cmd) "$cmd_file_dir/$file"
                } 
            }

            "-F" {
                set file $value
                if ![string equal $cmd ""] {
                    set cmd_file($cmd) "$cmd_file_dir/$file"
                }
            }

        }
    }

    #parray cmd_file
    #exit

}

myputs "after param processing the data looks:" 3
debug_array_data 3

#options need special handling{{{3}}}
#make capital letters to turn off options
#this feature will be deprecated since it consumes too much options letters
#if {[info exists options_cli(AUTO_PAGING)] && $options_cli(AUTO_PAGING)} { 
#    set auto_paging 0 
#}
if {[info exists options_cli(NOINTERACT)] && $options_cli(NOINTERACT)} { 
    set nointeract 0 
}
if {[info exists options_cli(COMPRESS_LOG)] && $options_cli(COMPRESS_LOG)} {
    set compress_log 0
}


#"persistent" {{{4}}}
#need to hold the session (not return interact and exit)
set exit_sync_copy $exit_sync 
set options(exit_sync_copy) $exit_sync
if {[info exists options_cli(persistent)] && $options_cli(persistent)} {
    myputs "turn off exit_sync on persistent mode"
    set options_cli(exit_sync) 0
}

#issue monitor {{{4}}}
#wrong coding, what for? (2015-09-29) 
#if ![info exists options_cli(issue_monitor)] {
#    myputs "regex_info exists, will force -M"
#    set issue_monitor 1
#    set options(issue_monitor) 1
#    set options_inline(issue_monitor) 1
#} else {
#}

#lock_session {{{4}}}
if {[info exists options_cli(lock_session)] && $options_cli(lock_session)} {
    myputs "set key_interact to impossible value"
    set options_cli(key_interact) $pattern_no_match
}

#no_anti_idle {{{4}}}
if {[info exists options_cli(no_anti_idle)] && $options_cli(no_anti_idle)} {
    #use options_cli, so later in reload_data, will get updated/merged into
    #options
    set options_cli(anti_idle_timeout) 100000000
    set options_inline(anti_idle_timeout_user_input) 100000000
    set options_inline(anti_idle_timeout_proc_input) 100000000
    set options(anti_idle_timeout_user_input) 100000000
    set options(anti_idle_timeout_proc_input) 100000000
    set anti_idle_timeout_user_input 100000000
    set anti_idle_timeout_proc_input 100000000
    myputs "no_anti_idle set, set anti_idle_timeout to indefinite value"
}

#timeout_output_line {{{4}}}
if {[info exists options_cli(timestamp_output_line)] && \
    $options_cli(timestamp_output_line)} {
    #set pattern_timestamp_verbose "(\[^\r\]*)\r\n"
    set pattern_timestamp_verbose              $pattern_timestamp_verbose_const
    set options_cli(pattern_timestamp_verbose) $pattern_timestamp_verbose_const
    set options_cli(timestamp) 2
    myputs "timeout_output_line set"
} else {
    myputs "timeout_output_line not set!"
}


#merge hostlist from config file {{{3}}}
if [info exists hostlist] {
    set hostlist_full [concat $hostlist $hostlist_full ]
}

#myputs "hostlist_full now looks $hostlist_full"

#reload data(initiate login info/etc) {{{2}}}
foreach host $hostlist_full {
    myputs "reloading data for host $host"
    reload_data $host
}
eval $global_data

##apply config options_cli
#if {$debug >= 2} {parray options_cli}
#myputs "apply options_cli to options" 2
#
##apply cfg file options
#foreach opt [array name options_cfg] {
#    set $opt $options_cfg($opt)
#    myputs "set $opt $options_cfg($opt)"
#}
#
##apply CLI options (here to secure debug setting)
#foreach opt [array name options_cli] {
#    set $opt $options_cli($opt)
#    myputs "set $opt $options_cli($opt)"
#}

myputs "data arrays after reloading data:" 2
debug_array_data 2

#auto_paging pattern {{{2}}}
#---(more)--- ---(more 8%)---  --More--
#regexp -- {--(\(more\)|More|more \d{1,2}%)--} {---more 8%---}
#regexp -- {--(\(more\)|More|more \d{1,2}%)--} {--More---}


#you have 3 choices for auto_paging feature:
#1. turn off it completely (default)
#2. turn on it, and enable it (default)
#2. turn on it, but disable tempararily
#
#to completely turn off this feature completely, in config file:
#   set pattern_more 0
#if {$pattern_more == 0} {set pattern_more $pattern_no_match
#to turn on forcely even if turned off in config: use -a
if $auto_paging {
    set pattern_more $pattern_more_const
    set options(pattern_more) $pattern_more_const
    set options_cli(pattern_more) $pattern_more_const
    myputs "auto_paging is set, set pattern_more to -$pattern_more-"
}

set cmds "cmds$options(project)"
myputs "cmds looks $cmds:[set ${cmds}($login_index)]"
#evaluate REPEAT command {{{2}}}

if {[info exists ${cmds}($login_index)] && ![string equal ${cmds}($login_index) ""]} {

    set cmd_list [set ${cmds}($login_index)]
    myputs "get original cmd_list:"
    myputs "$cmd_list"
    set i 0
    set does_repeat 0
    
    #expand cmds {{{3}}}
    foreach onecmd $cmd_list {
        myputs "pick one cmd:$onecmd, and search for REPEAT" 3
        if {[regexp {REPEAT\s*(\d+)\s*(\d*)} $onecmd -> repeat_num repeat_times]} {
            myputs "REPEAT ($repeat_num $repeat_times)! now expanding cmd_list"

            #record position of REPEAT
            set repeat_pos $i
            set does_repeat 1

            #append the original part before REPEAT
            append cmd_list_exp [lrange $cmd_list 0 $i-1]

            #expand REPEAT and append
            for {set j 1} {$j<=$repeat_times} {incr j 1} {
                append cmd_list_exp " " \
                    [lrange $cmd_list $repeat_pos-$repeat_num $repeat_pos-1]
            }

            #append the original part after REPEAT
            append cmd_list_exp " " [lrange $cmd_list $repeat_pos+1 end]

        } else {
            myputs "found no REPEAT cmd" 3
        }
        incr i
    }
    if $does_repeat {myputs "the expanded cmds $cmds looks:\n$cmd_list_exp\n"}

    #expand regex_info {{{3}}}

    if {[info exists regex_info($login_index)] && \
       ![string equal $regex_info($login_index) ""]} {

        myputs "get original regex_info:"
        myputs "$regex_info($login_index)\n"

        set regex_info_list $regex_info($login_index)

        foreach regex4onecmd $regex_info_list {

            myputs "\nget regex \{$regex4onecmd\}" 3
            set regex_vars_list [split $regex4onecmd "@"]
            set cmd_no [lindex $regex_vars_list 0]
            set cmd_no_index [expr $cmd_no - 1]
            myputs "cmd_no :$cmd_no,index $cmd_no_index in list index" 3

            if $does_repeat {

                if {$cmd_no_index < [expr $repeat_pos-$repeat_num]} {

                    #append those regex before REPEATed part
                    myputs "cmd_no $cmd_no (index $cmd_no_index) not reach \
                        REPEAT area:\
                        [expr $repeat_pos-$repeat_num]-[expr $repeat_pos-1]\
                        ,just append" 3
                    #append regex_info_list_exp " " $regex4onecmd
                    lappend regex_info_list_exp $regex4onecmd
                    myputs "expanded list looks:$regex_info_list_exp" 3

                } elseif {$cmd_no_index >= $repeat_pos-$repeat_num && \
                          $cmd_no_index < $repeat_pos } {

                    myputs "cmd_no $cmd_no (index $cmd_no_index) fall in \
                        REPEAT area:\
                        [expr $repeat_pos-$repeat_num]-[expr $repeat_pos-1]" 3
                    myputs "will expand the number and append..."
                    for {set j 0} {$j<=$repeat_times} {incr j 1} {
                        set cmd_no_exp [expr $cmd_no + $repeat_num*$j]
                        regsub $cmd_no $regex4onecmd $cmd_no_exp regex4onecmd_exp
                        #append regex_info_list_exp " " $regex4onecmd_exp
                        lappend regex_info_list_exp $regex4onecmd_exp
                        set regex_info_list_exp [lsort -dictionary $regex_info_list_exp]
                    }
                    myputs "expanded list looks:\n$regex_info_list_exp" 3

                } elseif {$cmd_no_index > $repeat_pos} {

                    myputs "cmd_no $cmd_no (index $cmd_no_index) fall after\
                        REPEAT area $repeat_pos so will expand the number and\
                        append" 3
                    set cmd_no_exp \
                      [expr $cmd_no+$repeat_num*$repeat_times-1]
                    
                    regsub $cmd_no $regex4onecmd $cmd_no_exp regex4onecmd_exp

                    #append regex_info_list_exp $regex4onecmd_exp
                    lappend regex_info_list_exp $regex4onecmd_exp
                    set regex_info_list_exp [lsort -dictionary $regex_info_list_exp]
                    myputs "expanded list looks:\n$regex_info_list_exp" 3

                } else {
                }
            }
        }

        if $does_repeat {
            myputs "\nthe final expanded regex_info looks:\n$regex_info_list_exp"
        }
    } else {
        myputs "regex_info not exists!"
        #set regex_info_list_exp $regex_info_list
    }

    #expand issue_info {{{3}}}
    if {[info exists issue_info($login_index)] && \
       ![string equal $issue_info($login_index) ""]} {

        myputs "get original issue_info:"
        myputs "$issue_info($login_index)\n"

        set issue_info_list $issue_info($login_index)

        foreach regex4onecmd $issue_info_list {

            myputs "\nget regex \{$regex4onecmd\}" 3
            set regex_vars_list [split $regex4onecmd "@"]
            set cmd_no [lindex $regex_vars_list 0]
            set cmd_no_index [expr $cmd_no - 1]
            myputs "cmd_no :$cmd_no,index $cmd_no_index in list index" 3

            if $does_repeat {

                if {$cmd_no_index < [expr $repeat_pos-$repeat_num]} {

                    #append those regex before REPEATed part
                    myputs "cmd_no $cmd_no (index $cmd_no_index) not reach
                        REPEAT\ area:\
                        [expr $repeat_pos-$repeat_num]-[expr $repeat_pos-1]\
                        ,just append" 3
                    #append issue_info_list_exp " " $regex4onecmd
                    lappend issue_info_list_exp $regex4onecmd
                    myputs "expanded list looks:$issue_info_list_exp" 3

                } elseif {$cmd_no_index >= $repeat_pos-$repeat_num && \
                          $cmd_no_index < $repeat_pos } {

                    myputs "cmd_no $cmd_no (index $cmd_no_index) fall in \
                        REPEAT area:\
                        [expr $repeat_pos-$repeat_num]-[expr $repeat_pos-1]\
                        will expand the number and append..." 3
                    for {set j 0} {$j<=$repeat_times} {incr j 1} {
                        set cmd_no_exp [expr $cmd_no + $repeat_num*$j]
                        regsub $cmd_no $regex4onecmd $cmd_no_exp regex4onecmd_exp
                        #append issue_info_list_exp " " $regex4onecmd_exp
                        lappend issue_info_list_exp $regex4onecmd_exp
                        set issue_info_list_exp [lsort -dictionary $issue_info_list_exp]
                    }
                    myputs "expanded list looks:\n$issue_info_list_exp" 3

                } elseif {$cmd_no_index > $repeat_pos} {

                    myputs "cmd_no $cmd_no (index $cmd_no_index) fall after\
                        REPEAT area $repeat_pos so will expand the number and\
                        append" 3
                    set cmd_no_exp \
                      [expr $cmd_no+$repeat_num*$repeat_times-1]
                    
                    regsub $cmd_no $regex4onecmd $cmd_no_exp regex4onecmd_exp

                    #append issue_info_list_exp $regex4onecmd_exp
                    lappend issue_info_list_exp $regex4onecmd_exp
                    set issue_info_list_exp [lsort -dictionary $issue_info_list_exp]
                    myputs "expanded list looks:\n$issue_info_list_exp" 3
                } else {
                }
            }
        }

        if $does_repeat {
            myputs "\nthe final expanded issue_info looks:\n$issue_info_list_exp"
        }
    } else {
        myputs "issue_info not exists!"
        #set issue_info_list_exp $issue_info_list
    }
}

if [expr $repeat_expand && $does_repeat] {
    set ${cmds}($login_index) $cmd_list_exp
    set regex_info($login_index) $regex_info_list_exp
    set issue_info($login_index) $issue_info_list_exp

    #save in _exp, to use when rebuilding with reload_data
    set ${cmds}_exp($login_index) $cmd_list_exp
    set regex_info_exp($login_index) $regex_info_list_exp
    set issue_info_exp($login_index) $issue_info_list_exp
}

#pre-login preparations {{{2}}}

#generate parser {{{3}}}
#-R "1@Input  packets:\s+(\d+)\s+(\d+) pps@packets@pps"
#if [info exists options_cli(regex_vars)] {}

eval $code_update_template

#preparing logfiles {{{3}}}

#CLI flag
#if ![info exists options_cli(log_filename)] {
#    #set log_filename "$host.log"
#    set log_filename "$session_nogroup.log"
#}

#substitution
set log_filename [info_subs2 $log_filename] 
#only use lower case as log file name {{{3}}}
#otherwise will end up with diff log names: abc.log ABC.log Abc.log ..
set log_filename [string tolower $log_filename]

#if log_fullname not set, use "abc" out of "abc@group"
#otherwise, use the specified name
if [string equal $log_fullname ""] {
    set log_fullname "$log_dir/$log_filename"
    set options(log_fullname) $log_fullname
    set options_inline(log_fullname) $log_fullname
}

if {[file exists $log_dir]} {
} else {
    myputs2 "dir $log_dir doesn't exist, creating one...\n"
    if [catch {file mkdir $log_dir} failed_reason] {
	myputs2 "failed to creating dir $log_dir: $failed_reason\n"
	#exit [CONST EXIT_ON_FAIL_CREATE_LOG_DIR]
        set log_dir "/var/tmp"
    } else {
	myputs2 "...done!\n"
    }
}

if {[file exists $cmd_file_dir]} {
} elseif [array exists cmd_file] {
    myputs2 "dir $cmd_file_dir doesn't exist, creating one...\n"
    if [catch {file mkdir $cmd_file_dir} failed_reason] {
	myputs2 "failed to creating dir $cmd_file_dir: $failed_reason\n"
	exit [CONST EXIT_ON_FAIL_CREATE_LOG_DIR]
    } else {
	myputs2 "...done!\n"
    }
} else {
}

#start logging {{{3}}}
#log everything if log_when > 3
if {$log_when >= 3} {
    myputs "start logging before start logging in..."
    log_file $log_fullname
    #send_tty won't be redirected to stdout, meaning this msg won't affact grep
    # crtc -c "show .." | grep "current log"
    #myputs "current log file $log_fullname\n"
    catch {myputs2 "log file: $log_fullname\n"}
    send_log $log_seperator 
}

#info_subs login_info    ;#login_info substitutions {{{3}}}
#info_subs1 $login_info($login_index)    ;#login_info substitutions {{{3}}}
set login_info($login_index) [info_subs1 $login_info($login_index)]
#copy to *_subs (for rebuild from within reload_data), no use
#array set login_info_subs [array get login_info]

#trap {send_user "bye bye"; exit} SIGINT

#build : expect_user_patterns & timeout_clause {{{2}}}
eval $code_expect_user_patterns

#spawn_login {{{2}}}

#turn off parallel for login process
set parallel_ori $parallel
set parallel 0
set options(parallel) 0
set options_inline(parallel) 0

foreach login_index $hostlist_full {
    #(2016-11-13) to fix @attlab.vmx in local machine (not in jserver)
    reload_data $login_index

    myputs2 "<<<CRTC:$login_index:start to login, please wait ...\n"
    myputs2 "<<<CRTC:$login_index:to interupt the login automation and get the\
        control, press <ESC>!\n"
    myputs2 "<<<CRTC:$login_index:to exit script(kill): press <ESC> and !Q\n"
    set spawn_login_return [spawn_login $login_index]

    switch -exact -- $spawn_login_return {

        "RETURN_SPAWN_LOGIN_NORMAL" {

            puts "\n<<<CRTC:$login_index:login succeeded!\n"

            switch -exact -- $req_win_title_chg {

                "securecrt" {
                    #for crt
                    #request window title change, when connected the client
                    #(securecrt/cygwin/etc's title will change to the connected host
                    #name
                    #accordingly)
                    puts "\033]2;$login_index\007"
                }

                "tmux" {
                    #for tmux
                    #this will change tmux window title when starting a new
                    #process, but without doing the same in .profile or .bashrc,
                    #exiting crtc won't recover the original title, produce
                    #confusions
                    puts "\033k$login_index\033\\"
                }
            }

            #if log_when set to 1, only start logging after successful login
            if {$log_when==1} {
                myputs "start logging after successful login"
                if {[llength $hostlist_full] > 1} {log_file}
                log_file $log_fullname
                catch {myputs2 "log file: $log_fullname\n"}
                send_log $log_seperator 
            }
        }

        "CLOSE" {

            myputs "login to $login_index timeout, close the session!"
            if {[llength $hostlist_full]==1} {
                exit
            } else {
                set hostlist_full [ldelete $hostlist_full $login_index]
            }
        }

        "CONTINUE" {
            myputs "login to $login_index timeout, continue with the next host!"
        }

        "EXIT" {

            myputs "login to $login_index timeout, exit!"
            exit
        }

        "RETURN_SPAWN_LOGIN_LOCALSHELL" {

            puts "you are now in a new local bash!"
            puts "type !? for extra options..."
            if {$log_when==1} {
                myputs "start logging after successful login"
                if {[llength $hostlist_full] > 1} {log_file}
                log_file $log_fullname
                catch {myputs2 "log file: $log_fullname\n"}
                send_log $log_seperator 
            }
        } 
        
        default {

            myputs "unprocessed or unsupported spawn_login_return $spawn_login_return, exit!"
            exit

        }
        #set timeout_old $timeout;set timeout 3
        #expect -re ".+" exp_continue
        #set timeout $timeout_old
    }
}

incr usage_progress     ;#1 no automation and interaction after login

set parallel $parallel_ori
set options(parallel) $parallel_ori
set options_inline(parallel) $parallel_ori
#interpreter

#execute cmdsN (configured or commanded) in a loop {{{2}}}

#substitution also in cmdsN (telnet -> telnet -K ...)
#info_subs $cmds
#if [info exists cmds($login_index)] { info_subs1 $cmds($login_index) }
if [info exists cmds($login_index)] { 
    set cmds($login_index) [info_subs1 $cmds($login_index)]
}
#and copy to *_subs to rebuild from within reload_data, no use
#array set ${cmds}_subs [array get $cmds]

if $login_only {
    myputs "login only!"
} else {

    if {$parallel} {

        #print a prompt message to differentiate between multiple hosts and 1
        #host
        if {[llength $hostlist_full] > 1} {
            if ![string equal [set ${cmds}($login_index)] ""] {
            #if ![string equal $cmds1($login_index) ""] {}
                myputs "execute $cmds in parallel after login $login_index!"
            }
        } else {
            if ![string equal [set ${cmds}($login_index)] ""] {
            #if ![string equal $cmds1($login_index) ""] {}
                myputs "execute $cmds after login $login_index!"
            }
        }

        if {$argc>0} {
            exec_cmds2 $login_index $cmds
        }

    } else {

        myputs "execute $cmds in sequence after login each host!"
        foreach login_index $hostlist_full {

            if ![string equal [set ${cmds}($login_index)] ""] {
            #if ![string equal $cmds1($login_index) ""] {}
                myputs "execute $cmds for host $login_index!"

                if {$argc>0} {
                    exec_cmds2 $login_index $cmds
                }

            }

        }
    }
} 

incr usage_progress     ;#2 no interaction after login and automation


#why?in theory only when "-e" was used, so use expect->then->send mode, we'll need
#another expect, but test shows even for "-c", without this the last cmds won't
#display
#if [info exists options_cli(expect)] { 
#    #one more expect, without this the last cmd won't display
#    myputs "no option -e: will expect one more time"
#    expect -re $pattern_common_prompt 
#}

#send email with attached logs{{{2}}}
#if {"EMAIL_LOG_ON_LOGIN" in $email_on_event} {}
if {[lsearch $email_on_event "EMAIL_LOG_ON_LOGIN"]>=0} {
    myputs "email_on_event set, will send email with log as attachment"
    if [info exists emailto] {
        myputs "emailto exists:$emailto, will send file $log_fullname in email"
        sendanemail $log_fullname $emailto
        myputs2 "log file $log_fullname was sent to $emailto \
            as attachment $log_filename\n"
    } else {
        myputs "email destination was not provided"
    }
}

myputs2 "<<<CRTC:$login_index:automation done\n"
if {$log_when==2} {
    myputs "start logging after all automation done"
    log_file $log_fullname
    catch {myputs2 "log file: $log_fullname\n"}
    send_log $log_seperator 
}

#interact {{{2}}}

if $nointeract {
    #very weird, without this, I got unstable result:
    #crtc -c "lsb_release -a is not reliably working
    #crtc -c "lsb_release -a" -c "uptime" always work
    #this is old issue - last command get lost sometime.
    #
    #this looks got resolved - search "set timeout 2"
    #expect -re $pattern_common_prompt
    myputs "output looks: $expect_out(buffer)" 2
    myputs2 "bye!:)\n"
    usage_stats $usage_progress
} else {
    #if $features {
    #    interact -re "!N" {
    #        return
    #    }
    #}

    incr usage_progress ;#3 interaction succeed
    usage_stats $usage_progress

    myinteract $login_index
}
