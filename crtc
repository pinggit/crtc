#!/usr/bin/env expect
#!/usr/local/bin/expect
#!/usr/bin/expect
#!/volume/buildtools/bin/expect
set crtc_dir [file dirname $argv0]              ;#get folder name
set crtc [file rootname [file tail $argv0]]     ;#get basename "crtc"
set config_file "$crtc_dir/$crtc.conf"
set host "LOCALHOST"
set session "LOCALHOST"
exp_version -exit 5.0
if {[exp_version] < 5.44} {
    puts "!!!your expect version [exp_version] seems too low!!!"
    puts "!!!this script was created/tested only under expect 5.45 or 5.44!!!" 
    puts "!!!with your current expect version, something may go wrong!" 
} 
match_max -d 10000000
set myinteract_depth 1
proc CONST { key } {    ;#{{{2}}}
    set constant(EXIT_ON_1ARGC_DONE)              101010
    set constant(EXIT_ON_FAIL_CREATE_LOG_DIR)     101110
    set constant(EXIT_ON_NO_PA)                   101210
    set constant(EXIT_ON_NO_RESOLVE)              101310
    set constant(EXIT_ON_QUIT_FROM_SLEEP)         101410
    set constant(EXIT_ON_FULL_BUFF)               101510
    set constant(EXIT_ON_CONFIGURED_ACTION)       101610
    set constant(EXIT_ON_RETRY_MAX)               101710
    set constant(RETURN_SLEEP_CONTINUE)           112010
    set constant(RETURN_SLEEP_BREAK)              112020
    set constant(RETURN_SLEEP_ZERO)               112030
    set constant(RETURN_EXPECT_SENDFIRST0_NORMAL) 111010
    set constant(RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN)   111011
    set constant(RETURN_EXPECT_SENDFIRST1_NORMAL) 111012
    set constant(RETURN_EXPECT_USER_INTERUPT)     111110
    set constant(RETURN_EXPECT_CONN_UNABLE)       111210
    set constant(RETURN_EXPECT_CONN_CLOSED)       111211
    set constant(RETURN_EXPECT_CONN_CONSOLE1)     111213
    set constant(RETURN_EXPECT_NOT_RESOLVED)      111214
    set constant(RETURN_EXPECT_BROKEN_PIPE)       111215
    set constant(RETURN_EXPECT_TIMEOUT)           111310
    set constant(RETURN_EXPECT_EOF)               111311
    set constant(RETURN_EXPECT_FULL_BUFFER)       111312
    set constant(RETURN_DO_PA5_NO_PA)             121010
    set constant(RETURN_DO_PA5_NORMAL)            121110
    set constant(RETURN_DO_PA5_SIGQUIT)           121210
    set constant(RETURN_GRES_SUCCESS)             141010
    set constant(RETURN_GRES_FORCE_RPD)           141110
    set constant(RETURN_GRES_SESSION_CLOSED)      141210
    set constant(RETURN_GRES_FAILED)              141310
    set constant(RETURN_GRES_TIMEOUT)             141410
    set constant(RETURN_SPAWN_LOGIN_NORMAL)       151010
    set constant(RETURN_SPAWN_LOGIN_LOCALSHELL)   151110
    set constant(RETURN_INTERACT_NORMAL)          161010
    set constant(CTRL_A)                  "\x01"
    set constant(CTRL_B)                  "\x02"
    set constant(CTRL_C)                  "\x03"
    set constant(CTRL_D)                  "\x04"
    set constant(CTRL_E)                  "\x05"
    set constant(CTRL_F)                  "\x06"
    set constant(CTRL_G)                  "\x07"
    set constant(CTRL_H)                  "\x08"
    set constant(CTRL_I)                  "\x09"
    set constant(CTRL_J)                  "\x0a"
    set constant(CTRL_K)                  "\x0b"
    set constant(CTRL_L)                  "\x0c"
    set constant(CTRL_M)                  "\x0d"
    set constant(CTRL_N)                  "\x0e"
    set constant(CTRL_O)                  "\x0f"
    set constant(CTRL_P)                  "\x10"
    set constant(CTRL_Q)                  "\x11"
    set constant(CTRL_R)                  "\x12"
    set constant(CTRL_S)                  "\x13"
    set constant(CTRL_T)                  "\x14"
    set constant(CTRL_U)                  "\x15"
    set constant(CTRL_V)                  "\x16"
    set constant(CTRL_W)                  "\x17"
    set constant(CTRL_X)                  "\x18"
    set constant(CTRL_Y)                  "\x19"
    set constant(CTRL_Z)                  "\x1a"
    set constant(ESC)                     "\x1B"
    set constant(CR)                    "\r"
    return $constant($key)
}
set optlist "-(a|A|b|B|c|C|d|D|e|E|f|F|g        \
              |h|H|i|I|j|J|k|K|l|L|m|M|n|N      \
              |o|O|p|P|q|Q|r|R|s|S|t|T|u|U      \
              |V|v|w|W|x|X|y|Y|z|Z)"
array set optmap {                   \
    "-a" attribute                   \
    "-A" auto_paging                 \
    "-B" post_commands               \
    "-b" pre_commands                \
    "-c" commands                    \
    "-C" config_file                 \
    "-d" debug                       \
    "-D" max_hits                    \
    "-e" expect                      \
    "-E" EXPECT                      \
    "-f" log_filename                \
    "-F" cmd_filename                \
    "-g" interval_cmd                \
    "-H" hideinfo                    \
    "-h" hosts                       \
    "-i" interval_cmds               \
    "-I" issue                       \
    "-j" project                     \
    "-J" eventmonitor                \
    "-k" send_usage_stats            \
    "-K" env_proof                   \
    "-l" emailto                     \
    "-L" log_when                    \
    "-m" max_rounds                  \
    "-M" local_task                  \
    "-n" max_rounds                  \
    "-N" reproduced_no               \
    "-o" login_only                  \
    "-O" emailbody                   \
    "-p" persistent                  \
    "-P" parallel                    \
    "-q" nointeract                  \
    "-Q" features                   \
    "-r" reconnect_interval          \
    "-R" regex_vars                  \
    "-s" send                        \
    "-S" SEND                        \
    "-t" timestamp                   \
    "-T" timestamp_output_line       \
    "-u" redirect_inshell          \
    "-U" login_succeed_signature     \
    "-V" print_matched_value         \
    "-v" verbose                     \
    "-w" timeout_login              \
    "-W" timeout_cmd                \
    "-x" all_met                     \
    "-X" lock_session                \
    "-y" easyvar                     \
    "-Y" reproduced_yes              \
    "-z" compress_log                \
    "-Z" no_anti_idle                \
}
set config_default { ;#{{{2}}}
    set options(datasent_noreturn)               0
    set options(send_usage_stats)            0
    set options(sessionname_regex)         ""
    set options(kibitz_kill_onfail)     1
    set options(req_win_title_chg)      "securecrt"
    set options(double_echo)            0
    set options(prefix_mark)            "HOST"
    set options(features)              2       ;#-Q
    set options(enable_user_patterns)   3       
    set options(expect_matchany)        1
    set options(retry_max)              "3"
    set options(no_reconnect_on_interact) 0
    set options(cmd_filename)           "default.txt"
    set options(cmd_file_dir)           "~/cmd_files"
    set options(retry_interval)         30
    set options(local_task)             0
    set options(env_proof)              0
    set options(auto_resolve)           1
    set options(eventmonitor)           0
    set options(redirect_inshell)       1
    set options(repeat_expand)          1
    set options(verbose)                1
    set options(run_at)                 ""
    set options(key_interact)           "\\r"   ;#press enter to interupt
    set options(key_interact)           ESC
    set options(key_background)         CTRL_F    ;#ctrl-f
    set options(key_background)         CTRL_G    ;#ctrl-g
    set options(key_background)         CTRL_Z    ;#ctrl-g
    set options(pattern_no_match)       "ThisIsAlmostImpossibleToBeMatched"
    set options(pattern_more_const)     {(--\(more \d+%\)--|--\(more\)--|--More--)}
    set options(pattern_more_key)       {\r}
    set options(pattern_more_key)       { }
    set options(pattern_timestamp)      "\r"
    set options(pattern_timestamp_verbose_const) "(\[^\r\]*)\r\n"
    set options(pattern_cmd_input)      ".+"
    set options(pattern_common_prompt) "((%|>|#|\\\$) ?)$"
    set options(pattern_continue_automation)       " |\\r"
    set options(pattern_break_automation) "q"
    set options(pattern_exit_script) "Q"
    set options(pattern_not_resolve_msg) "ould not resolve"
    set options(pattern_connection_unable) \
        "telnet: Unable to connect to remote host"
    set options(pattern_console_msg)    \
        "Type the hot key to suspend the connection: <CTRL>Z"
    set options(pattern_connection_close_msg) \
            "Connection closed.*\\n|Connection to (\\d{1,3}\\.){3}\\d{1,3}\
            closed|Connection to \\S\+ closed|Connection reset by peer"
    set options(pattern_connection_not_responding) "Timeout,\
            server (\\d{1,3}\\.){3}\\d{1,3} not responding"
    set options(pattern_broken_pipe)    "Write failed: Broken pipe"
    set options(pattern_gres_not_ready) \
        "Not ready for mastership switch, try after \\d+ secs.*"
    set options(pattern_gres_success)   "routing engine becomes the master"
    set options(pattern_more)           $options(pattern_no_match)
    set options(pattern_timestamp_verbose) $options(pattern_timestamp_verbose_const)
    set options(download_folder)        "~/"
    set options(log_dir)                "~/logs"
    set options(log_fullname)           ""
    set options(log_filename)           "%S.log"
    set options(log_seperator)          "
    <<<<<<<<<<<<<<<<<<< new logs since: <<<<<<<<<<<<<<<<<<<<<<<
    < [time_now] $env(USER) [string repeat \{ 3]1[string repeat \} 3] <
    <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    "
    set options(log_when)               1     ;#0: no logging
                                              ;#1: after successful login
                                              ;#2: after automations
                                              ;#others: log everything
    set options(debug)                  0                     ;#-d/D
    set options(project)                9
    set options(lock_session)           0     ;#-X: set key_interact 
                                              ;# 1: lock dead: to an impossible value
                                              ;# 0: no lock, use default key to interupt
                                              ;# a CHAR: use specified char to interupt
    set options(nointeract)             0     ;#-q/Q:quickmode
    set options(hideinfo)               0     ;#-H
    set options(interval_cmd)           0     ;#-I, intv between cmd in cmds
    set options(interval_cmds)          0     ;#-i, intv between cmds
    set options(interval_cmds_min)      0     ;#-i, min intv between cmds
    set options(interval_cmds_max)      0     ;#-i, max intv between cmds
    set options(interval_gres)          300   ;#
    set options(timeout_login)         20    ;#-w
    set options(timeout_cmd)           20    ;#-W
    set options(max_rounds)             1     ;#-n
    set options(max_hits)               1     ;#
    set options(alternate_on_hit)       0     ;#
    set options(exit_sync)              1     ;#-k
    set options(persistent)             0     ;#-p
    set options(login_only)             0     ;#-o
    set options(send_initial_cr)        0
    set options(auto_paging)            0     ;#-A
    set options(timestamp)              0     ;#-t
    set options(continue_on_reconnect)  1 ;#cont from where leftoff after reconnect
    set options(reconnect_interval)     10    ;#-r
    set options(reload_conf_inloop)     0     ;# refresh conf file in iterations
    set options(actions_on_hit)         "EMAIL EXEC_collect EXIT_MAX"
    set options(actions_on_nohit)       "EXEC_test"
    set options(anti_idle_timeout_user_input)      50
    set options(anti_idle_timeout_proc_input)      60
    set options(anti_idle_string)       " \177"	;#type space then delete
    set options(anti_idle_string) 	" \07"	;#type ctrl-g, good for editor 
    set options(no_anti_idle)           0
    set options(compress_log)           1     ;#-z
    set options(print_matched_value)    0
    set options(match_means_issue)      0     ;#only used when no issue defined
    set options(nomatch_means_issue)    0
    set options(easyvar)                1
    set options(all_met)                0
    set options(default_domain)         "juniper.net"
    set options(email_on_event)         "EMAIL_ON_HIT \
                                        "
    set options(emailto)                "$env(USER)@$options(default_domain)" ;#-L
    set options(emailsub)  "notification from crtc!"
    set options(emailbody) "check your crtc logs for what happened" 
    set options(headless)               0
    set options(sigquit)                0
    set options(automation_non_complete_msg) ""
    set options(parallel)               0
    set options(treat_special_char_as_pa) 1
    set options(dateformat)             "%Y_%m%d_%H%M_%S"
    set options(current_time_cmd)       {[clock format [clock seconds] -format $dateformat]}
    set options(clockcmd)               "show system clock"        ;#no use yet
    set options(flag_check_method)      1         ;#any flag indicate a hit
    set options(automation_timeout)     5      ;#start automation if no input
    set options(usertype)               1
    set options(userinfile)             "userinfile"
    set options(useroutfile)            "useroutfile"
    set options(version) "crtc version 0.7 by pings@juniper.net 1/24/2014" 
    set options(version) "crtc version 0.82 by pings@juniper.net 3/19/2015" 
    set options(version) "crtc version 0.8 by pings@juniper.net 3/15/2015" 
    set options(version) "crtc version 0.83 by pings@juniper.net 6/2015"
    set options(version) "crtc version 0.84 by pings@juniper.net 7/2015"
    set options(version) "crtc version 0.85 by pings@juniper.net 7/2015"
    set options(version) "crtc version 0.86 by pings@juniper.net 7/2015"
    set options(version) "crtc version 0.87 by pings@juniper.net 10/2015"
    set options(version) "crtc version 0.9 by pings@juniper.net 2/2016"
    set options(version) "crtc version 0.92 by pings@juniper.net 3/2016"
    set options(version) "crtc version 0.94 by pings@juniper.net 5/2016"
    set options(version) "crtc version 0.95 by pings@juniper.net 6/2016"
    set options(version) "crtc version 0.96 by pings@juniper.net 7/2016"
    set options(version) "crtc version 0.97 by pings@juniper.net 8/2016"
    set options(version) "crtc version 0.98 by pings@juniper.net 11/2016"
    set options(version) "crtc version 0.99 by pings@juniper.net 11/2016"
    set options(login_succeed_signature) "login succeeded, it's all yours!\n\
                                         --\[$options(version)\]"
    set options(tips_on_login) 1
    if [regexp -nocase {cygwin} $tcl_platform(os)] {
        set options(os) "cygwin"
        set options(emailapp) "email"
    } elseif [regexp -nocase {linux} $tcl_platform(os)] {
        set options(os) "linux"
        set options(emailapp) "mail"
    } else {
        set options(os) "mac"
        set options(emailapp) "mail"
    }
    foreach opt [array name options] {
        set $opt $options($opt)
    }
    set user_patterns(timeout)          [list "timeout" EXIT expect_only]
}
set global_data {    ;#{{{2}}}
    global options options_cli options_cfg options_inline
    global pre_cmds1 pre_cmds_cli post_cmds1 post_cmds_cli
    global cmds1 cmds2 cmds3 collect test
    global cmds_cli collect_cli test_cli cmds_exp
    global cmd_output_array_pre_cmds1 cmd_output_array_post_cmds1
    global cmd_output_array_cmds1 cmd_output_array_cmds1_prev
    global login_info login_info_cli 
    global eventscript scheduled_event
    global cmd_file
    global user_patterns action_handler
    global code_return_expect_user_interupt
    global code_return_expect_sendfirst
    global code_return_reconnect
    global code_return_retry
    global code_return_ctrlc
    global code_return_exit
    global code_return_close
    global code_return_continue
    global code_return_timeout
    global session2host host2session 
    global config_default config_file hostmap
    global user_spawn_id expect_out debug spawn_id
    global env tcl_platform host help_file 
    global regex_info issue_info
    global regex_info_exp issue_info_exp
    global regex_info_resolve issue_info_resolve
    global myinteract_depth hostlist_full
    global log_filename_new log_filename_cur
    global log_dir_new log_dir_cur
    global log_fullname_new log_fullname_cur
    global during_login during_cmd
    foreach opt [array name options] {
        global $opt
        set $opt $options($opt)
    }
    myputs "global all vars in user_pattern array" 2
    foreach opt [array name user_pattern] {
        global $opt
        set $opt $user_pattern($opt)
    }
    for {set i 1} {$i<10} {incr i 1} {
        global test$i
    }
    for {set i 1} {$i<=200} {incr i 1} {
        global cmds$i pre_cmds$i pre_cmds${i}_cli post_cmds$i post_cmds${i}_cli
        global cmd_output_array_pre_cmds${i} output_array_post_cmds${i}
        global cmd_output_array_cmds${i}_prev cmd_output_array_cmds${i}
        global cmds${i}_exp
        global cmds${i}_resolve
    }
}
set code_init_template { ;#{{{3}}}
    global cmd_output_array_cmds1_prev cmd_output_array_cmds1
    global debug 
    puts ""
    if $debug {myputs "--------parsing cmd output with defined parser--------"}
    myputs "$router:\[$cmd\]"
    if $debug {
        set procname [lindex [info level 0] 0]
        send_log "$procname:cmd_output_array_cmds1_prev looks \
            [array get cmd_output_array_cmds1_prev]\n"
        send_log "$procname:cmd_output_array looks [array get cmd_output_array_cmds1]\n"
    }
    set cmd_output_prev [get_output cmd_output_array_cmds1_prev $router $cmd_id]
    set time_prev [lindex [get_index cmd_output_array_cmds1_prev $router $cmd_id] 1]
    set cout_list_prev [split $cmd_output_prev "\n"]
    set cmd_output [get_output cmd_output_array_cmds1 $router $cmd_id]
    set time_now [lindex [get_index cmd_output_array_cmds1 $router $cmd_id] 1]
    set cout_list [split $cmd_output "\n"]
    set cout_llen [llength $cout_list]
    send_log "proc1:for router $router cmd --$cmd-- got curr:prev time as $time_now:$time_prev\n"
    if {($time_prev==0) || ($time_now==0) } {
        myputs "time extraction error, exit!"
        if $debug {
            send_log "time extraction error, exit!\n"
            send_log "proc1:router -$router- cmd -$cmd- cmd_output_prev looks -$cmd_output_prev-\n"
            send_log "proc1:router -$router- cmd -$cmd- cmd_output looks -$cmd_output-\n"
            send_log "proc1:convert cmd_output_prev to list as --$cout_list_prev--\n"
            send_log "proc1:convert cmd_output to list as --$cout_list--\n"
        }
        exit
    } else {
        if $debug {
            send_log "time extraction correct, continue\n"
        }
    }
    for {set i 0} {$i<$cout_llen} {incr i 1} {          ;#for each line from cmd output
        set cout_line [lindex $cout_list $i]            ;#take a line from the output list
        set cout_aline($i) $cout_line
        set cout_line_prev [lindex $cout_list_prev $i]  ;#take same line,from the prev capture
        set cout_aline_prev($i) $cout_line_prev
    }
    if $debug {
        puts "cmd_output array cout_aline_prev and cout_aline looks:"
        parray cout_aline_prev
        parray cout_aline
    }
}
set code_template {       ;#{{{3}}}
    set issue4onecmd $issue4onecmd_holder
    set regex_vars_list [split $regex4onecmd "@"]
    myputs "split -$regex4onecmd- into list: -$regex_vars_list-"
    set cmd_num [lindex $regex_vars_list 0]
    set line_num [lindex $regex_vars_list 1]
    if {$line_num!=""} {
        myputs "get line_num as : -$line_num-"
        if {$line_num > $cout_llen} {
            myputs2 "line number($line_num) exceeded the max($cout_llen)!"
            myputs2 "check your -R regex"
            exit 11
        }
    } else {
        myputs "no line_num"
    }
    set regex [lindex $regex_vars_list 2]
    myputs "get regex : -$regex-"
    set vars [lrange $regex_vars_list 3 end]
    myputs "get vars list: -$vars-"
    foreach avar $vars {global $avar}   ;#to use in other places
    myputs "get vars as a list: -$vars-"
    set vars_prev {}
    foreach avar $vars { append vars_prev "${avar}_prev " }
    set vars_prev [string trim $vars_prev]
    myputs "get vars_prev as a list: -$vars_prev-"
    myputs "will scan for braces and regsub to add backslash to escape them..."
    if {[regsub -all {([{}])} $cmd_output {\\\1} cmd_output] > 0} {
        myputs "substituted cmd_output now looks $cmd_output" 3
    }
    if {[regsub -all {([{}])} $cmd_output_prev {\\\1} cmd_output_prev] > 0} {
        myputs "substituted cmd_output now looks $cmd_output_prev" 3
    }
    if {$line_num==""} {
        myputs "empty line_num"
        myputs "looking for a match to regex:\n$regex"
        myputs "from following output:\n$cmd_output"
        myputs "and the previous version:\n$cmd_output_prev"
        puts "to be evaled:\n[subst {regexp {$regex} {$cmd_output} -> $vars}]"
        set does_match1 [eval \
            [subst {regexp {$regex} {$cmd_output} -> $vars}]]
        set does_match2 [eval \
            [subst {regexp {$regex} {$cmd_output_prev} -> $vars_prev}]]
    } else {
        set does_match1 [eval [subst {\
            regexp {$regex} {$cout_aline($line_num)} -> $vars}]]
        set does_match2 [eval [subst {\
            regexp {$regex} {$cout_aline_prev($line_num)} -> $vars_prev}]]
        myputs "from following output:\n$cout_aline($line_num)"
        myputs "and the previous version:\n$cout_aline_prev($line_num)"
        myputs "to find a match to regex:\n$regex"
    }
    if {($does_match1==1) && ($does_match2==1)} {
        myputs "wanted value captured and saved in user defined vars:"
        myputs2 "<<<CRTC:got match to regex |$regex4onecmd|,"
        if { [info exists issue4onecmd] && \
            ![string equal $issue4onecmd ""]} {
            myputs "criteria defined to detect the issue: -$issue4onecmd-,"
            if ![regexp {\d+@(.*)} $issue4onecmd -> issue] {
                puts "wrong format in -I!";interpreter
            }
            if {[expr $issue]} {
                if {$::hideinfo<3} {
                    myputs2 "\ncriteria \"$issue\" was met -> \"[subst $issue]\""
                }
                if {$::print_matched_value==1} {
                    myputs "print all matched value"
                    foreach avar [subst $vars] {send_user "[set $avar] "}
                } elseif {$::print_matched_value==0} {
                } else {
                    send_user "[subst $::print_matched_value]"
                }
                return 1
            } else {
                myputs2 "\ncriteria \"$issue\" was not met -> \"[subst $issue]\""
                if {$::print_matched_value==1} {
                    myputs "print all matched value"
                    foreach avar [subst $vars] {send_user "[set $avar] "}
                } elseif {$::print_matched_value==0} {
                } else {
                    send_user "[subst $::print_matched_value]"
                }
            }
        } else {
            if {$::print_matched_value==1} {
                myputs "print all matched value"
                foreach avar [subst $vars] {send_user "[set $avar] "}
            } elseif {$::print_matched_value==0} {
            } else {
                send_user "[subst $::print_matched_value]"
            }
            myputs2 "issue not defined,"
            if $::match_means_issue {
                myputs2 "but match_means_issue set to $::match_means_issue, \
                    indicating issue appearing!"
                return 1
            } else {
                myputs2 "and match_means_issue not set , \
                    indicating issue NOT appearing!\n"
                return 0
            }
        }
    } else {
        myputs "no match, defined vars:\n[set vars]\nwas not captured"
        myputs "consider to:"
        myputs "   double check your regex, make sure it's what you wanted"
        myputs "   or maybe issue does not appear yet"
        myputs "<<<CRTC:|    got no match to regex |$regex4onecmd|,"
        if $auto_resolve {
            puts "some variable won't be resolved due to no match in regex_info
                provided, check the CLI output and regex!"
            myinteract $login_index
        }
        if $::nomatch_means_issue {
            myputs "issue not provided, no match simply means found issue"
            myputs2 "but nomatch_means_issue set $::nomatch_means_issue,\
                indicating issue appearing!"
            return 1
        } else {
            myputs2 "and nomatch_means_issue not set, \
                indicating issue NOT appearing!"
        }
    }
}
set code_update_template {    ;#{{{3}}}
    myputs "\n"
    myputs "==>enter code_update_template now"
    if {[info exists regex_info($login_index)] && \
        ![string equal $regex_info($login_index) ""]} {
        myputs "regex_info looks $regex_info($login_index)"
        if $debug {
            if {[info exists issue_info($login_index)] && \
               ![string equal $issue_info($login_index) ""]} {
                puts "issue_info looks: -$issue_info($login_index)-";
            } else {
                puts "issue_info not configured for $login_index"
            }
        }
        myputs "regex_info looks $regex_info($login_index)"
        foreach regex4onecmd $regex_info($login_index) {
            myputs "get a regex $regex4onecmd" 1
            set regex_vars_list [split $regex4onecmd "@"]
            myputs "get list:|$regex_vars_list| from string |$regex4onecmd|"
            set cmd_num [lindex $regex_vars_list 0]
            set line_num [lindex $regex_vars_list 1]
            set regex [lindex $regex_vars_list 2]
            myputs "get regex as a string: |$regex|"
            set vars [lrange $regex_vars_list 3 end]
            myputs "get vars as a list: |$vars|"
            regsub -all \
                {\$regex4onecmd} $code_template \
                "\{$regex4onecmd\}" temp
            myputs "looking for issue for the regex with the same cmd"
            set isthere_issue4regex 0
            set issue4onecmd ""
            if { [info exists issue_info($login_index)] && \
                ![string equal $issue_info($login_index) ""]} {
                foreach aaa $issue_info($login_index) {
                    myputs "get an issue definition:$aaa" 3
                    set issue_as_list [split $aaa "@"]
                    myputs "split to list: -$issue_as_list-" 3
                    set cmd_num_issue [lindex $issue_as_list 0]
                    if [string equal $cmd_num_issue $cmd_num] {
                        myputs "got same cmd number $cmd_num_issue" 3
                        set isthere_issue4regex 1
                        set issue4onecmd $aaa
                        break
                    }
                }
            }
            if !$isthere_issue4regex {
                myputs "can't find an issue for regex4onecmd:$regex4onecmd"
            } else {
                if $easyvar {
                    myputs "easyvar set, will check issue expression (-I or\
                        issue_info) and compose vars from bare-words"
                    myputs "will do vars substitutions now.."
                    if [string equal $cmd_num_issue $cmd_num] {
                        myputs "issue defined for {$regex4onecmd} ==> {$issue4onecmd}"
                        set issue_words [regexp -all -inline {(\w+)} $issue4onecmd]
                        myputs "extracted words from |$issue4onecmd| are |$issue_words|"
                        foreach {word word_rep} $issue_words {
                            if {[lsearch -exact $vars $word]!=-1} {
                                myputs "get a word $word, looks in vars $vars, \
                                    will prefix a \"\$\"" 3
                                regsub -all $word $issue4onecmd "\$$word" issue4onecmd
                            } else {
                                myputs "get a word $word, looks not a variable" 3
                            }
                        }
                        myputs "code_update_template:issue4onecmd now looks\
                            $issue4onecmd after substitutions"
                    } else {
                        myputs "no issue defined for regex:$regex4onecmd"
                        set issue4onecmd ""
                    }
                } else {
                    myputs "easy var not set, won't do any varible substitutions for -I"
                }
            }
            regsub -all {\$issue4onecmd_holder} $temp "\{$issue4onecmd\}" temp
            myputs "defining code |code_${login_index}_$cmd_num| now"
            set code_${login_index}_$cmd_num $temp
            myputs "generated code for code_${login_index}_$cmd_num looks" 4
            myputs "[set [subst {code_${login_index}_$cmd_num}]]" 4
        }
    } else {
        myputs "regex_info not provided"
    }
    myputs "<==leaving code_update_template now"
    myputs "\n"
}
set code_return_expect_user_interupt {  ;#{{{3}}}
    while {$myexpect_return=="RETURN_EXPECT_USER_INTERUPT"} {
        set automation_non_complete_msg "<<<<\
            \[session $router\]:you have unfinished \
            automations (stack $myinteract_depth)!\n\ 
            press !R to  continue, ^\\ or !s to stop, \
            !Q to quit script"
            set options(automation_non_complete_msg) \
                $automation_non_complete_msg
            set options_inline(automation_non_complete_msg) \
                $automation_non_complete_msg
        incr myinteract_depth
        myputs "increase myinteract_depth to $myinteract_depth"
        myinteract $router
        set automation_non_complete_msg ""
            set options(automation_non_complete_msg) \
                $automation_non_complete_msg
            set options_inline(automation_non_complete_msg) \
                $automation_non_complete_msg
        set myexpect_return [myexpect $router $pattern     \
            $datasent $pattern_timeout [expr !$pa_pair] 0   \
        ]
        if {$hideinfo==2} {
            myputs2 "$cmd "
            if {$myexpect_return!=0} {
                myputs2 "!"
            } else {
                myputs2 "."
            }
            myputs2 "\n"
        }
    } 
    break
}
set code_return_expect_sendfirst {      ;#{{{3}}}
    set do_pag_return "RETURN_DO_PA5_NORMAL"
    break
}
set code_return_reconnect {     ;#{{{3}}}
    global session
    if {$persistent==1 || $persistent==3} {
        if !$reconnect_interval {
        } else {
            puts "persistent $persistent, will reconnect after\
                ${reconnect_interval}s!"
            mysleep $reconnect_interval
        }
        close ;wait 
        myputs "==> calling recursive spawn_login"
        spawn_login $router
        puts "\n<<<CRTC:$login_index:login succeeded!\n"
        myputs "<== leaving recursive spawn_login"
        break
    } else {
        puts "persistent set $persistent, not to reconnect !"
    }
}
set code_return_retry {       ;#{{{3}}}
    set do_pag_return $myexpect_return
    global timeout
    myputs "timeout from eval code looks $timeout seconds!"
    if ![regexp "$pattern_common_prompt" "$pattern_prev"] {
        set pattern_prev $pattern
        set datasent_prev $datasent
    }
    if $during_login {      ;#{{{4}}}
        set timeout_old $timeout
        set timeout 1
        expect -i $process -re ".+" {exp_continue -continue_timer}
        set timeout $timeout_old
        myputs "pa_pair set to $pa_pair"
        if !$pa_pair {          ;#{{{5}}}
            set escape_count 0
            expect {
                -i $process -re $pattern {
                    myputs "expected pattern -$pattern- matched!"
                    puts "will sleep for $reconnect_interval and retry"
                    mysleep $reconnect_interval
                    puts "retry current cmd -$datasent- now..."
                    continue
                }
                timeout {
                    if {$escape_count < 3} {
                        incr escape_count
                        puts "timeout (${timeout}s) without match to -$pattern-\
                            press ctrl-c again to escape ..."
                        exp_send -i $process "[CONST CTRL_C]\r"
                        exp_continue
                    } else {
                        puts "not able to escape(not seeing expected prompt\
                            -$pattern-, will exit"
                        exit
                    }
                }
            }
        } else {                ;#{{{5}}}
            set retry_count 0
            puts "press ctrl-c to get the previous prompt -$pattern_prev-..."
            exp_send -i $process "[CONST CTRL_C]\r"
            puts "awaiting for a -$pattern_prev-..."
            expect {
                -i $process -re $pattern_prev {
                    myputs "expected pattern_prev -$pattern_prev- matched!"
                    mysleep $reconnect_interval
                    myputs "retry previous cmd -$datasent_prev- now..."
                    exp_send -i $process "$datasent_prev\r"
                    continue
                }
                timeout {
                    if {$retry_count < $retry_max } {
                        incr retry_count
                        puts "timeout (${timeout}s) without match to\
                            -$pattern_prev- press ctrl-c again to escape ..."
                        exp_send -i $process "[CONST CTRL_C]\r"
                        exp_continue
                    } else {
                        puts "reach retry_max $retry_max without matching to\
                            -$pattern_prev-! will exit"
                        exit
                    }
                }
            }
        }
    } elseif $during_cmd {  ;#{{{4}}}
        set timeout_old $timeout
        set timeout 1
        expect -i $process -re ".+" {exp_continue -continue_timer}
        set timeout $timeout_old
        exp_send -i $process "[CONST CTRL_C]\r"
        puts "<<<pressed a ctrl-c to escape just in case..."
        puts "<<<then expecting a prompt -$pattern-"
        myputs "pa_pair set to $pa_pair"
        if !$pa_pair {          ;#{{{5}}}
            set escape_count 0
            expect {
                -i $process -re $pattern {
                    myputs "expected pattern -$pattern- matched!"
                    puts "will sleep for $reconnect_interval and retry"
                    mysleep $reconnect_interval
                    puts "retry current cmd -$datasent- now..."
                    continue
                }
                timeout {
                    if {$escape_count < 3} {
                        incr escape_count
                        puts "timeout (${timeout}s) without match to\
                            -$pattern-, press ctrl-c again to escape ..."
                        exp_send -i $process "[CONST CTRL_C]\r"
                        exp_continue
                    } else {
                        puts "not able to escape(not seeing expected prompt\
                            -$pattern-, will exit"
                        exit
                    }
                }
            }
        } else {                ;#{{{5}}}
            set retry_count 0
            expect {
                -i $process -re $pattern_prev {
                    myputs "<<<expected pattern_prev -$pattern_prev- matched!"
                    mysleep $reconnect_interval
                    puts "<<<retry previous cmd -$datasent_prev- now..."
                    exp_send -i $process "$datasent_prev\r"
                    continue
                }
                timeout {
                    if {$retry_count < $retry_max } {
                        incr retry_count
                        puts "timeout (${timeout}s) without match to\
                            -$pattern_prev-, press ctrl-c again to escape ..."
                        exp_send -i $process "[CONST CTRL_C]\r"
                        exp_continue
                    } else {
                        puts "reach retry_max $retry_max! will exit"
                        exit
                    }
                }
            }
        }
    }
}
set code_return_ctrlc {       ;#{{{3}}}
    set do_pag_return $myexpect_return
    if $during_login {      ;#{{{4}}}
        break
    } elseif $during_cmd {  ;#{{{4}}}
        exp_send -i $process "[CONST CTRL_C]"
        break
    } else {
    }
}
set code_return_exit {       ;#{{{3}}}
    set do_pag_return $myexpect_return
    if $during_login {      ;#{{{4}}}
        break
    } elseif $during_cmd {  ;#{{{4}}}
        exit
    } else {
    }
}
set code_return_close {       ;#{{{3}}}
    set do_pag_return $myexpect_return
    if $during_login {      ;#{{{4}}}
        break
    } elseif $during_cmd {  ;#{{{4}}}
        myputs "will close this session"
        close $process;wait $process;
        return "CLOSE"
    } else {
    }
}
set code_return_continue {       ;#{{{3}}}
    set do_pag_return $myexpect_return
    if $during_login {      ;#{{{4}}}
        break
    } elseif $during_cmd {  ;#{{{4}}}
        break
    } else {
    }
}
set code_return_timeout {       ;#{{{3}}}
    if $during_login {      ;#{{{4}}}
        puts "exit..."
        exit
    } elseif $during_cmd {  ;#{{{4}}}
    } else {
    }
}
set action_handler(RETURN_EXPECT_USER_INTERUPT) \
    "code_return_expect_user_interupt"
set action_handler(RETURN_EXPECT_SENDFIRST0_NORMAL) \
    "code_return_expect_sendfirst"
set action_handler(RETURN_EXPECT_SENDFIRST1_NORMAL) \
    "code_return_expect_sendfirst"
set action_handler(RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN) \
    "code_return_expect_sendfirst"
set action_handler(RECONNECT) "code_return_reconnect"
set action_handler(RETRY) "code_return_retry" 
set action_handler(RETURN_EXPECT_TIMEOUT) "code_return_timeout"
set send_user_expect_out {
    if {$prefix_mark != 0} {
        myputs "original buf looks \n$buf"
        if {$prefix_mark=="HOST"} {set prefix_mark $host}
        set output_list [split $buf "\n"]
        set output_new ""
        foreach line $output_list {
            set line_new [sinsert $line 0 "$prefix_mark:"]
            set line_new [append line_new "\n"]
            append output_new $line_new
        }
        myputs "with prefix_mark set the output_new looks \n$output_new"
    } else {
        set output_new $buf
    }
    catch {
        send_user "$output_new\n"
    }
}
set write_cmd_output {
    if {$prefix_mark !=0} {
        myputs "original buf looks \n$buf"
        if {$prefix_mark=="HOST"} {set prefix_mark $host}
        set output_list [split $buf "\n"]
        set output_new ""
        foreach line $output_list {
            set line_new [sinsert $line 0 "$prefix_mark: "]
            set line_new [append line_new "\n"]
            append output_new $line_new
        }
        myputs "with prefix_mark set the output_new looks \n$output_new"
    } else {
        set output_new $buf
    }
    if [info exists cmd_file($cmd)] {
        set file_ori $cmd_file($cmd)
        set h_cmd_file [open [info_subs2 $file_ori] a]
        catch {
            puts -nonewline $h_cmd_file $output_new
        }
        close $h_cmd_file
    }
}
set code_expect_user_patterns {
    if [expr {$enable_user_patterns && [array exists user_patterns]}] {
        set expect_user_patterns ""
        myputs "enable_user_patterns set and user_patterns array is not empty!"
        if {$debug==3} {
            puts "user_patterns looks:"
            parray user_patterns
        }
        foreach user_pname [array name user_patterns] {
            set user_pattern [lindex $user_patterns($user_pname) 0]
            if [string equal $user_pattern ""] {
                myputs "user_patterns($user_pname) looks empty!"
                continue
            }
            if [in "interact_only" $user_patterns($user_pname)] {
                myputs "user_patterns($user_pname) looks empty!"
                continue
            }
            if {($user_pattern=="timeout") || $expect_matchany} {
                set pat_flag ""
            } else {
                set pat_flag "-nocase -re"
            }
            if {[llength $user_patterns($user_pname)] == 1} {
                myputs "user_pattern $user_pname contains no cmd" 3
                myputs "will return pattern name $user_pname"
                append expect_user_patterns [subst -nocommands {
                    $pat_flag {$user_pattern} {
                        myputs "detected -$user_pattern-"
                        myputs "will return pattern name"
                        set buf_match_loc [string first [lindex [set match] 0] [set buf]]
                        set buf_rm_bef_matched [string replace [set buf] 0 [set buf_match_loc]-1 ]
                        set buf [string trimleft [set buf_rm_bef_matched] [set match]]
                        return $user_pname
                    }
                }]
                set action_handler($user_pname) "code_return_continue" 
            } else {
                set user_action_list [lindex $user_patterns($user_pname) 1]
                set user_action [lindex $user_action_list 0]
                set user_action_eval [string trimleft $user_action_list $user_action]
                myputs "user_patterns $user_pname contains an action $user_action" 3
                if {$user_action_eval != ""} {
                    myputs "and a user_action_eval\n-$user_action_eval-" 3
                }
                set timeout_old $timeout
                set timeout_clause {
                    timeout {
                        myputs "timeout in ${timeout}s without any data!"
                        return "RETURN_EXPECT_TIMEOUT"
                    }
                }
                if {$expect_matchany && $user_pattern=="timeout"} {
                    myputs "expect_matchany set $expect_matchany" 3
                    myputs "user_pattern looks $user_pattern" 3
                    myputs "will need to build a timeout clause ..." 3
                    switch -regexp -- $user_action {
                        "RETRY" -
                        "RECONNECT" {   ;#{{{7}}}
                            myputs "will compose timeout clause to return\
                                user_action $user_action"
                            set timeout_clause [subst {
                                $pat_flag {timeout} {
                                    puts "detected timeout after $timeout"
                                    puts "user_action configured as $user_action"
                                    myputs "will return this user_action"
                                    return $user_action
                                }
                            }]
                        }
                        "EXIT" {        ;#{{{7}}}
                            myputs "will compose timeout clause to exit on timeout"
                            set timeout_clause [subst {
                                $pat_flag {$user_pattern} {
                                    puts "detected -$user_pattern-"
                                    puts "user_action configured as EXIT"
                                    puts "will just exit the script!"
                                    exit [CONST EXIT_ON_CONFIGURED_ACTION]
                                }
                            }]
                        }
                        default {       ;#{{{7}}}
                            myputs "this is not a \"special command\", will\
                                send it as a normal command"
                            set timeout_clause [subst \
                                -nobackslashes -nocommands {
                                $pat_flag {$user_pattern} {
                                    myputs "detected -$user_pattern-"
                                    myputs "will send cmd -$user_action_list-, and\
                                        continue expect"
                                    exp_send -i [set process] "[info_subs2 $user_action_list]\r"
                                    mysleep $retry_interval
                                    exp_continue
                                }
                            }]
                        }   ;#done default
                    }   ;#done switch
                } else {
                    myputs "expect_matchany set 0" 3
                    switch -exact -- $user_action {
                        "RECONNECT" {   ;#{{{7}}}
                            myputs "will compose expect clause to return\
                                user_action the value $user_action"
                            if ![string equal "$user_action_eval" ""] {
                                set do_eval 1
                            } else {
                                set do_eval 0
                            }
                            append expect_user_patterns [subst -nocommands {
                                $pat_flag {$user_pattern} {
                                    puts "detected -$user_pattern-"
                                    if $do_eval {
                                        puts "now execute user_action_eval..."
                                        eval {$user_action_eval}
                                    }
                                    puts "user_action configured as $user_action"
                                    puts "will reconnect..."
                                    set buf_match_loc [string first \
                                        [lindex [set match] 0] [set buf]]
                                    set buf_rm_bef_matched [string replace \
                                        [set buf] 0 [set buf_match_loc]-1 ]
                                    set buf [string trimleft \
                                        [set buf_rm_bef_matched] [set match]]
                                    myputs "will return user_action $user_action"
                                    return $user_action
                                }
                            }]
                        }
                        "RETRY" {       ;#{{{7}}}
                            myputs "will compose expect clause to return\
                                user_action the value $user_action"
                            append expect_user_patterns [subst -nocommands {
                                $pat_flag {$user_pattern} {
                                    myputs "timeout in $timeout"
                                    expect -i [set process] *
                                    myputs "expect_out(buffer) now looks\r
                                        -[set expect_out(buffer)]-"
                                    puts "<<<detected -$user_pattern-"
                                    puts "<<<user_action configured as RETRY"
                                    puts "<<<will repeat same command and continue..."
                                    set buf_match_loc [string first \
                                        [lindex [set match] 0] [set buf]]
                                    set buf_rm_bef_matched [string replace \
                                        [set buf] 0 [set buf_match_loc]-1 ]
                                    set buf [string trimleft \
                                        [set buf_rm_bef_matched] [set match]]
                                    return $user_action
                                }
                            }]
                        }
                        "EXIT" {        ;#{{{7}}}
                            myputs "will compose expect clause to exit\
                                on match to the pattern"
                            append expect_user_patterns [subst {
                                $pat_flag {$user_pattern} {
                                    puts "detected -$user_pattern-"
                                    puts "user_action configured as EXIT"
                                    puts "will just exit script!"
                                    exit [CONST EXIT_ON_CONFIGURED_ACTION]
                                }
                            }]
                        }
                        default {       ;#{{{7}}}
                            myputs "this is not a \"special command\""
                            set temp {
                                if [array exists expect_out] {
                                    foreach index [array name expect_out] {
                                        lappend match $expect_out($index)
                                    }
                                }
                            }
                            append expect_user_patterns [subst \
                                -nobackslashes -nocommands {
                                    $pat_flag {$user_pattern} {
                                        myputs "detected -$user_pattern-"
                                        myputs "will send cmd -$user_action_list-,\
                                            and continue expect"
                                        eval {$temp}
                                        set user_action_list_subs \
                                            [info_subs2 "$user_action_list" [set match]]
                                        exec_cmds $login_index {$user_action}
                                        set buf_match_loc [string first \
                                            [lindex [set match] 0] [set buf]]
                                        set buf_rm_bef_matched [string replace \
                                            [set buf] 0 [set buf_match_loc]-1 ]
                                        set buf [string trimleft \
                                            [set buf_rm_bef_matched] [set match]]
                                        exp_continue
                                    }
                                }]
                        }
                    }   ;#done switch
                }   ;#done expect_matchany && "timeout" pattern check
            }   ;#done special commands
        }   ;#done iterating user_patterns
        myputs "expect_user_patterns looks $expect_user_patterns" 3
    } else {
        myputs "either enable_user_patterns not set or user_patterns not defined!"
    }
}
set myexpectcmd {
    expect {            
    -i "$user_spawn_id" ;#{{{4}}}
        -re [CONST $key_interact] {   ;#{{{5}}}               
            myputs2 "session:\\\[$router\\\]:you typed $key_interact key\
                here..."
            myputs2 "\nyou have the control now...\n"
            mycatch "stty -raw"
            myputs "myexpect return RETURN_EXPECT_USER_INTERUPT"
            return "RETURN_EXPECT_USER_INTERUPT"
        }
        -re ".+" { ;#{{{5}}}
            puts "you typed something here when the automation is still\
                progressing...type $key_interact if you want to interupt the\
                script and to interact manually..."
            exp_continue
        }
    -i $process ;#{{{4}}}
        -re {$pattern} {        ;#{{{5}}}
            myputs "expected pattern -$pattern- captured"
            if $isSendFirst {   ;#{{{6}}}
                incr i;if {$i <= $host_num} {
                    if $parallel {
                        send_user "==output for \
                            $session2host($spawn_id):==\n"
                    }
                    if ![log_user -info] {
                        $send_user_expect_out
                    }
                    $write_cmd_output
                }
                return "RETURN_EXPECT_SENDFIRST1_NORMAL"
            } else {    ;#{{{6}}}
                if {[string equal {$cmd} "MATCH_AGAIN"]} {
                    return "RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN"
                } else {
                    if $timestamp {
                        myputs "timestamp is enabled"
                        send_user "\n[subst $current_time_cmd](local)\n"
                    } else {
                    }
                    myputs "sending data -[info_subs2 {$cmd}]- now after pattern match"
                    if $datasent_noreturn {
                        myputs "send without return"
                        exp_send -i $process "[info_subs2 {$cmd}]"
                    } else {
                        exp_send -i $process "[info_subs2 {$cmd}]\r"
                    }
                    return "RETURN_EXPECT_SENDFIRST0_NORMAL"
                }
            }
        }
        $expect_user_patterns
        -re {$pattern_more} {   ;#{{{5}}}
            exp_send -i $process "$pattern_more_key"
            exp_continue
        }
        timeout {       ;#{{{5}}}
            puts "timeout after ${timeout}s without a match for -$pattern-!"
            return "RETURN_EXPECT_TIMEOUT"
        }
        eof {           ;#{{{5}}}
            myputs "spawned process terminated!"
            return "RETURN_EXPECT_EOF"
        }
        full_buffer {   ;#{{{5}}}
            myputs2 "got full buffer!"
            exit [CONST EXIT_ON_FULL_BUFF]
        }
    }
}
set myexpectcmd_matchany {
    set buf ""
    expect {
        -i "$user_spawn_id" ;#{{{4}}}
            -re [CONST $key_interact] {   ;#{{{5}}}               
                myputs2 "session:\\\[$router\\\]:you typed $key_interact key\
                    here..."
                myputs2 "\nyou have the control now...\n"
                mycatch "stty -raw"
                myputs "myexpect return RETURN_EXPECT_USER_INTERUPT"
                return "RETURN_EXPECT_USER_INTERUPT"
            }
            -re ".+" { ;#{{{5}}}
                puts "you typed something here...type $key_interact if you\
                    want to interupt crtc..."
                exp_continue
            }
        -i $process ;#{{{4}}}
            -re "..+" {  ;#{{{5}}}
                set str_len [string length [set expect_out(buffer)]]
                myputs "get new strings:>>>"
                myputs "[set expect_out(buffer)], [set str_len]<<<" 2
                append buf [set expect_out(buffer)]
                myputs "this make the buf looks:\n>>>[set buf]<<<" 2
                switch -regexp -matchvar match -- [set buf] {
                    {$pattern} {
                        myputs "expected pattern -$pattern- captured"
                        if $isSendFirst {   ;#{{{7}}}
                            incr i;if {$i <= $host_num} {
                                if $parallel {
                                    send_user "==output for \
                                        $session2host($spawn_id):==\n"
                                }
                                if ![log_user -info] {
                                    $send_user_expect_out
                                }
                                $write_cmd_output
                            }
                            set buf_match_loc [string first \
                                [lindex [set match] 0] [set buf]]
                            set buf_rm_bef_matched [string replace \
                                [set buf] 0 [set buf_match_loc]-1 ]
                            set buf [string trimleft \
                                [set buf_rm_bef_matched] [set match]]
                            myputs "buf now looks:\n-[set buf]-" 3
                            return "RETURN_EXPECT_SENDFIRST1_NORMAL"
                        } else {    ;#{{{7}}}
                            if {[string equal {$cmd} "MATCH_AGAIN"]} {
                                return "RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN"
                            } else {
                                if $timestamp {
                                    myputs "timestamp is enabled"
                                    send_user "\n[subst $current_time_cmd](local)\n"
                                } else {
                                }
                                myputs "sending data -[info_subs2 {$cmd} [set match]]- now after\
                                    pattern match"
                                myputs "datasent_noreturn looks $datasent_noreturn" 3
                                if $datasent_noreturn {
                                    myputs "send without a return"
                                    exp_send -i $process "[info_subs2 {$cmd} [set match]]"
                                } else {
                                    myputs "send with a return"
                                    exp_send -i $process "[info_subs2 {$cmd} [set match]]\r"
                                }
                                set buf_match_loc [string first \
                                    [lindex [set match] 0] [set buf]]
                                set buf_rm_bef_matched [string replace \
                                    [set buf] 0 [set buf_match_loc]-1 ]
                                set buf [string trimleft \
                                    [set buf_rm_bef_matched] [set match]]
                                return "RETURN_EXPECT_SENDFIRST0_NORMAL"
                            }
                        }
                    }
                    {$pattern_more} {
                        myputs "send pattern_more_key -$pattern_more_key- now" 
                        exp_send -i $process "$pattern_more_key"
                        set buf_match_loc [string first \
                            [lindex [set match] 0] [set buf]]
                        set buf_rm_bef_matched [string replace \
                            [set buf] 0 [set buf_match_loc]-1 ]
                        set buf [string trimleft \
                            [set buf_rm_bef_matched] [set match]]
                        exp_continue
                    }
                    $expect_user_patterns
                    default {           ;#{{{6}}}
                        myputs "buf:no pattern match" 1
                        myputs "exp_continue on no match" 1
                        exp_continue
                    }
                }       ;#end switch
            }           ;#end -re .+
            $timeout_clause
            eof {           ;#{{{5}}}
                myputs "spawned process terminated!"
                return "RETURN_EXPECT_EOF"
            }
            full_buffer {   ;#{{{5}}}
                myputs2 "got full buffer!"
                exit [CONST EXIT_ON_FULL_BUFF]
            }
    }
}
set myinteract_user_input_patterns {       
    -echo "!?" usage_inline             ;#{{{4}}}
    "!!" {send -i $process "!"}         ;#{{{4}}}
    {\\} {send -i $process "\\"}        ;#{{{4}}}
    -echo -reset -re "!a" {             ;#{{{4}}}
        eval $interact_a 
        if $auto_paging {
            set pattern_more $pattern_more_const
        } else {
            set pattern_more $pattern_no_match
        }
        set options(pattern_more) $pattern_more
        myputs "pattern_more looks $options(pattern_more) now"
        set options_inline(pattern_more) $pattern_more
        return
    }  
    -echo -re "!A" { interact_A;return }        ;#{{{4}}}
    -echo -reset "!b" { eval $interact_b } ;#close sharing tempararily {{{4}}}
    -echo -reset "!B" {      ;#to close sharing permanently {{{4}}}
    }
    -echo -re "!d" { interact_d; return}       ;#{{{4}}}
    -echo -re "!f" { interact_f; return}       ;#{{{4}}}
    -echo -re "!H" { interact_H }       ;#{{{4}}}
    -echo -re "!n" { eval $interact_n }       ;#{{{4}}}
    -echo -re "!o" { interact_o }       ;#{{{4}}}
    -echo -re "!p" { interact_p }       ;#{{{4}}}
    -echo -re "!P" { interact_P }       ;#{{{4}}}
    -echo -re "!q" { interact_q }       ;#{{{4}}}
    -echo -re "!t" { interact_t; return }       ;#{{{4}}}
    -echo -re "!T" { interact_T; return }       ;#{{{4}}}
    -echo -re "!u" { interact_u; return }       ;#{{{4}}}
    -echo -re "!y" { interact_y }       ;#{{{4}}}
    -echo -re "!z" { interact_z; return }       ;#{{{4}}}
    -echo -reset "!c" { interact_c router }      ;#{{{4}}}
    -echo -reset -re "!r" { interact_r $router }       ;#{{{4}}}
    -echo -re "!h" { usage }    ;#{{{4}}}
    -echo -re "!v" { eval $interact_v }  ;#{{{4}}}
    -echo -re "!V" { version }  ;#{{{4}}}
    -echo -reset -re "!A" { interact_A }        ;#{{{4}}}
    -echo -reset -re "!k" { interact_k;return }        ;#{{{4}}}
    -echo -re "!m" { puts "host list: \n[parray login_info]" }  ;#{{{4}}}
    -echo -re "!D" { interact_D }       ;#{{{4}}}
    -echo -re "!E" { interact_E }       ;#{{{4}}}
    -echo -re "!C" { puts "edit config file";system vim $config_file }  ;#{{{4}}}
    -echo -re "!i" { if [file exists $help_file] {system less $help_file}} ;#{{{4}}}
    -echo -re "!O" { interact_O;return }        ;#{{{4}}}
    -echo -reset -re "!R" { if {[interact_R]==1} inter_return }         ;#{{{4}}}
    -echo "!s" { interact_s }    ;#{{{4}}}
    -echo "!+" { interact_plus; return }        ;#{{{4}}}
    -echo "!-" { interact_minus; return }       ;#{{{4}}}
    -echo -re "!I" {    ;#{{{4}}}
        puts "enter interpreter mode, type (literal) 'return' to go\
            back to crtc session"
        interpreter
        puts "returning back to crtc..."
    }
    -reset "![CONST $key_background]" {      ;#{{{4}}}
        puts "\[session $router\]: you pressed a keystroke\
            \"!$key_background\" that moves this session background,\
            type `fg` to move it foreground when needed!"
        exec kill -STOP [pid]
    }
    -nobuffer -re "\[^!\\\\]+|$pattern_timestamp" {            ;#{{{4}}}
        eval $interact_any
    }
    -reset -re "\\\\(\[iksqlc\]|(\\d+))" {       ;#{{{4}}}
        eval $interact_multi_session
    }
    -reset -re "!N" { interact_N; return }  ;#{{{4}}}
    -echo -reset -re "!M" {                 ;#{{{4}}}
        set eventmonitor 1
        puts "eventmonitor is 1"
        return 
    }
    -echo -reset "!Q" {  ;#{{{4}}}
        puts "uit the script!"
        exit            
    }
    -echo -re "!Z" { interact_Z; return } ;#{{{4}}}
    -echo -reset "!l" {         ;#{{{4}}}
        eval $interact_l
    }           ;#!l
    -echo -reset "!g" {         ;#{{{4}}}
        incr anti_idle_timeout_user_input 2; 
        send_tty "timeout increased to $anti_idle_timeout_user_input    \r"
        return
    }
    -echo -reset "!G" {         ;#{{{4}}}
        incr anti_idle_timeout_user_input -2; 
        send_tty "timeout reduced to $anti_idle_timeout_user_input    \r"
        return
    }
    timeout $anti_idle_timeout_user_input {       ;#{{{4}}}
        eval $interact_timeout 
    }
}
set code_myinteract_user_patterns {
    set event_action_list ""
    set myinteract_process_input_user_patterns ""
    if {$enable_user_patterns >= 2} {
        foreach user_pname [array name user_patterns] {
            global $user_pname
            if [ni "expect_only" $user_patterns($user_pname)] {
                if {(![info exists $user_pname]) || \
                    ([set $user_pname] != 0) \
                   } {
                    set user_pattern [lindex $user_patterns($user_pname) 0]
                    set user_action [lindex $user_patterns($user_pname) 1]
                    lappend event_action_list "$user_pattern" "$user_action"
                    myputs "$user_pname not exists or is not 0, use this pattern" 3
                } {
                    myputs "$user_pname exists and is 0, turn off this user\
                    pattern" 3
                }
            }
        }
        if [info exists eventscript($router)] {
            foreach a $eventscript($router) {
                lappend event_action_list $a
            }
        }
        myputs "event_action_list looks $event_action_list" 3
        set i 0;set j 1
        for {set i 0} {$i<=[expr [llength $event_action_list]-1]} {incr i} {
            set event [lindex $event_action_list $i]
            incr i
            set user_action [lindex $event_action_list $i]
            if [regexp {^\s+$} $user_action] {
                set action_name $user_action
            } else {
                set action_name [lindex "$user_action" 0]
            }
            myputs "event: -$event-" 3
            myputs "user_action: -$user_action-" 3
            myputs "action_name: -$action_name-" 3
            append myinteract_process_input_user_patterns [subst -nocommands {
                -reset -nobuffer -re {$event} {
                    myputs2 "\n\n"
                    myputs2 "<<<interact: detected event:\n"
                    myputs2 "<<<-[set interact_out(0,string)]-\n"
                    myputs2 "<<<which matches defined pattern(event):\n-"
                    myputs2 {<<<$event-\n}
                    switch -regexp -- "$action_name" {
                        "RECONNECT.*" {   ;#{{{5}}}
                            myputs2 "\r\nconfigured action is RECONNECT"
                            if {[set persistent]>1} {
                                myputs2 "persistent mode set [set persistent]"
                                puts -nonewline "\r\n<<<[clock format [clock\
                                    seconds]]:CRTC will reconnect in \
                                    ${reconnect_interval}s\n"
                                myputs2 "type !p to toggle persistent mode"
                                mysleep $reconnect_interval
                                puts "\r\nreconnecting..."
                                close; wait
                                set is_respawn 1
                                return 1
                            } else {
                                puts "persistent mode set [set persistent],\
                                    won't reconnect\n"
                            }
                        }
                        "EXIT.*" {   ;#{{{5}}}
                            exit
                        }
                        "RETRY.*" {   ;#{{{5}}}
                        }
                        "CTRLC.*" {   ;#{{{5}}}
                        }
                        "CONTINUE.*" {   ;#{{{5}}}
                        }
                        "EMAIL.*" {       ;#{{{5}}}
                            postanemail $emailto "crtc:event captured!" \
                                "monitored event:\n$event\n is captured!"
                            if [regexp "attach" $action_name] {
                                sendanemail $log_fullname_cur $emailto
                            }
                        }
                        default {       ;#{{{5}}}
                            if [string equal {$user_action} ""] {
                                send_user -- "no action name configured!"
                            } else {
                                if [regexp {^\s+$} {$user_action}] {
                                    send -i $process {$user_action\r}
                                } else {
                                    send_user -- {\r\n<<<CRTC:will execute\
                                        configured action group -$user_action-!!\r\n}
                                    myputs2 {<<<CRTC: \n\\\"$user_action\\\" \
                                        looks a normal cmdgroup, will execute}
                                    exec_cmds $router {$user_action}
                                }
                            }
                        }
                    }
                }
            }]
        }
        append myinteract_process_input_patterns_misc [subst -nocommands {
            -nobuffer -re {$pattern_more} {         ;#{{{5}}}
                myputs "there is a match!!"
                puts "[set interact_out(0,string)]"
                if $auto_paging {
                    myputs "auto_paging set, send intial cr"
                    send -i $process "$pattern_more_key"
                }
            }
            -nobuffer [CONST CR] {                ;#{{{5}}}
                if [set totimestamp] {
                    myputs "totimestamp set to 1, timestamp!" 3
                    if [set timestamp] {
                        send_user "\n[subst $current_time_cmd](local)\n"
                    } else {
                    }
                } else {
                    myputs "totimestamp set to 0, no timestamp!" 3
                }
                set totimestamp 0
            }
            -re {$pattern_timestamp_verbose} {    ;#{{{5}}}
                myputs "get a return from cmd output"
                puts "[set interact_out(1,string)] [clock format [clock seconds]]"
            }
            timeout $anti_idle_timeout_proc_input {        ;#{{{5}}}
                eval {$interact_timeout}
            }
        }]
        myputs "myinteract_process_input_user_patterns looks\
            $myinteract_process_input_user_patterns" 3
        myputs "myinteract_process_input_patterns_misc looks\
            $myinteract_process_input_patterns_misc" 3
    }
}
set myinteract_process_input_patterns_static {
    -nobuffer -re $pattern_more {         ;#{{{4}}}
        myputs "there is a match!!"
        puts "$interact_out(0,string)"
        if $auto_paging {
            myputs "auto_paging set, send intial cr"
            send -i $process "$pattern_more_key"
        }
    }
    -nobuffer "\r" {                ;#{{{4}}}
        if $totimestamp {
            myputs "totimestamp set to 1, timestamp!" 3
            if $timestamp {
                send_user "\n[subst $current_time_cmd](local)\n"
            } else {
            }
        } else {
            myputs "totimestamp set to 0, no timestamp!" 3
        }
        set totimestamp 0
    }
    -re $pattern_timestamp_verbose {    ;#{{{4}}}
        myputs "get a return from cmd output"
        puts "$interact_out(1,string) \[[clock format [clock seconds]]\]"
    }
    -nobuffer null {
        send_user "detected a null during automation!"
    }
    eof {       ;#{{{4}}}
        myputs "detected eof during interaction..."
        exit
    }
}
set myinteract_kibitz_input_patterns {
    -iwrite eof {       ;#{{{4}}}
        myputs "detected eof from [set interact_out(spawn_id)]"
        ldelete kibitz_list [set interact_out(spawn_id)]
        ldelete kibitz_user_list\
            [set sid2user([set interact_out(spawn_id)])]
        set kibitz_list_ori [set kibitz_list]
        send -i "[set user_spawn_id] [set kibitz_list]"\
            "local user [\
                set sid2user([set interact_out(spawn_id)])\
            ] get disconnected!"
    }
    -iwrite -nobuffer -exact "$kibitz_shell_prompt" {   ;#{{{4}}}
        puts "detected -$kibitz_shell_prompt-"
        lappend shell_list  $interact_out(spawn_id)
        ldelete kibitz_list $interact_out(spawn_id)
        ldelete kibitz_user_list $sid2user($interact_out(spawn_id))
        set kibitz_list_ori $kibitz_list
        send -i "$user_spawn_id $kibitz_list"\
            "remote user $sid2user($interact_out(spawn_id)) disconnected!"
    }
    -iwrite -nobuffer -re "\r" {        ;#{{{4}}}
        set kibitz_list_backup $kibitz_list
        set curr_sid $interact_out(spawn_id)
        set curr_user $sid2user($curr_sid)
        if $sid2typing($curr_sid) {
        } else {
            send -i "$user_spawn_id [ldelete kibitz_list_backup $curr_sid]"\
                "\r\n<---$curr_user is typing ...\r\n"
            set ownertyping 0
            foreach asid [array name sid2typing] {
                set sid2typing($asid) 0
            }
            set sid2typing($curr_sid) 1
        }
    }
}
proc myputs {msg {level 1} args} { ;#{{{2}}}
    global debug login_index
    if ![info exists login_index] {
        set sessionname ""
    } else {
        set sessionname $login_index
    }
    set procname [lindex [info level 1] 0]
    set msg1 "\[[clock format [clock seconds]]\]:\[$sessionname\]:$procname:..$msg.."
    if {$level==-1} {
        send_tty $msg
    } elseif {$debug>=$level} { 
        if {[llength $args]} {
            set debugfile [lindex $args 0]
            set h_debugfile [myopen $debugfile w]
            if {$h_debugfile != 0} {puts $h_debugfile "$msg1"}
            if {$debug>=3} {exp_internal -f $debugfile 0}
            close $h_debugfile         ;#very important
        } else {
            if {$debug>=3} {
            }
            puts -nonewline "$msg1\r\n"
        }
    } else {
    }
}
proc myputs2 {msg} {    ;#{{{2}}}
    global redirect_inshell verbose
    if $verbose {
        if $redirect_inshell {
            puts -nonewline "$msg\r"
        } else {
            send_tty $msg
        }
    }
}
proc myputs3 {msg} {    ;#{{{2}}}
    puts -nonewline "$msg\r"
}
proc catchevalexec {cmd} { ;#{{{2}}}
    global debug
    if { 					\
            [catch  				\
                {eval exec 			\
                    $cmd 			\
                }  				\
                msg 				\
            ] 					\
        } {
       myputs "Something seems to have gone wrong:"
       myputs "Information about it: $::errorInfo"
       return 1
    } else {
	return 0
    } 
}
proc mycatch {cmd} {    ;#{{{2}}}
    if { [catch {eval $cmd} msg] } {
       puts "Something seems to have gone wrong:"
       puts "Information about it: $::errorInfo"
       return 1
    } else {
	return 0
    } 
}
proc sendanemail {file emailto} { ;#{{{2}}}
    set files [glob -nocomplain $file]
    myputs "get file lists: $files"
    if $::compress_log {
        myputs "zip set, will send zipped file"
        set attachname "$file.zip"
        set execcmd \
            "zip -jq - {expand} [glob -nocomplain $file] |\
            uuencode $attachname |\
            mail -s \"log file:$file\" $emailto"
    } else {
        set attachname [exec basename $files]
        if $debug {myputs "zip not set, will send plain text file"}
        set execcmd "uuencode [glob -nocomplain $file] $attachname |  \
            mail -s \"log of case:$file\" $emailto"
    }
    if {[catchevalexec $execcmd]} {
    } else {
        myputs "send email to $emailto with \
            logfile:$files as attachment:$attachname"
    }
}
proc postanemail {emailto {emailsub "No subject"} {emailbody}} {  ;#{{{2}}}
    global emailapp
    set emailcmd \
        "echo \"$emailbody\" | [set emailapp] \
        -s \"$emailsub\" $emailto"
    myputs "emailcmd looks -$emailcmd-"
    catchevalexec $emailcmd
    myputs "email sent..."
}
proc postanemail2 {emailto {emailsub "No subject"} {emailbody}} {  ;#{{{2}}}
    myputs "sending email..."
    global env
    set from "$env(USER)@juniper.net"
    set replyto "no-reply-$env(USER)@juniper.net"
    exec /usr/sbin/sendmail -t << "To: $emailto\r\nFrom:\ 
    $replyto\r\nSubject: $emailsub\r\nIn-reply-to: $replyto\r\n\r\n\
    $emailbody"
    myputs "email sent..."
}
proc myexpect {router pattern cmd {mytimeout 60} {isSendFirst 1} {isPersis 1}} { 
    myputs "==>entering myexpect"
    global global_data;eval $global_data
    global expect_user_patterns send_user_expect_out timeout_clause
    global write_cmd_output myexpectcmd myexpectcmd_matchany
    if $parallel {
        set process [arrayvalue host2session]
        myputs "parallel set $parallel, log_user set 0!"
        log_user 0
    } else {
        set process $host2session($router)
    }
    set host_num [llength $process]
    set timeout $mytimeout
    if $isSendFirst {
        if $during_login {
        } elseif $during_cmd {
            if {$prefix_mark != 0} {
                myputs "during_cmd and prefix_mark not 0, log_user set 0!"
                log_user 0
            } else {
            }
        } else {
        }
        if $timestamp {
            myputs "timestamp is enabled"
            send_user "\n[subst $current_time_cmd](local)\n"
        } else {
            myputs "timestamp is not enabled"
        }
        myputs "sending data \"$cmd\" to $process even before pattern\
            ($pattern) match"
        exp_send -i $process "[info_subs2 $cmd]\r"
        myputs "expecting pattern ($pattern) after already sent string \"$cmd\""
    } else {
        myputs "awaiting for pattern ($pattern) before sending string \"$cmd\""
    }
    set i 0
    if ![array exists expect_out] {
        set expect_out(buffer) ""
        set expect_out(spawn_id) ""
        set expect_out(0,string) ""
    }
    if [expr {$enable_user_patterns && [array exists user_patterns]}] {
        myputs "enable_user_patterns set ($enable_user_patterns) and\
            user_patterns array not empty"
        myputs "will eval the dynamically pre-composed expect!"
        if ![regsub -all "\"" $cmd "\\\"" cmd_no_quote] {
            set cmd_no_quote $cmd
        }
        set myexpectcmd [expr {$expect_matchany ? $myexpectcmd_matchany : $myexpectcmd}]
        myputs "original myexpectcmd looks:\n$myexpectcmd" 3
        set myexpectcmd_subs [subst -nocommands $myexpectcmd]
        myputs "substituted myexpectcmd looks:\n$myexpectcmd_subs" 3
        eval $myexpectcmd_subs
    } else {
        myputs "enable_user_patterns not set ($enable_user_patterns) or\
            user_patterns array empty"
        myputs "will use static expect!"
        expect {            
            -i $user_spawn_id                                       ;#{{{5}}}
            -re [CONST $key_interact] {                                 ;#{{{6}}}
                myputs2 "process:\[$router\]:you typed $key_interact key here..."
                myputs2 "\nyou have the control now...\n"
                mycatch "stty -raw"
                myputs "myexpect return RETURN_EXPECT_USER_INTERUPT"
                return "RETURN_EXPECT_USER_INTERUPT"
            }
            -re ".+" {
                puts "you typed something here...type $key_interact if you want \
                      to interupt crtc..."
            }
            -i $process                                              ;#{{{5}}}
            -nocase -re $pattern_broken_pipe {                      ;#{{{7}}}
                myputs "detected -$pattern_broken_pipe-\r"
                return "RETURN_EXPECT_BROKEN_PIPE"
            }
            -nocase -re $pattern_connection_close_msg {             ;#{{{7}}}
                myputs "detected -$pattern_connection_close_msg- ... msg\r"
                return "RETURN_EXPECT_CONN_CLOSED"
            }
            -re $pattern_not_resolve_msg {                          ;#{{{7}}}
                myputs2 "detected -$pattern_not_resolve_msg-\r"
                return "RETURN_EXPECT_NOT_RESOLVED"
            }
            -re $pattern_console_msg {                              ;#{{{7}}}
                myputs2 "looks a console msg\r"
                exp_send -i $process "\r"; exp_continue
                return "RETURN_EXPECT_CONN_CONSOLE1"
            }
            -nocase -re $pattern_connection_unable {                ;#{{{7}}}
                myputs "detected -$pattern_connection_unable-\r"
                return "RETURN_EXPECT_CONN_UNABLE"
            }
            -re "$pattern" {                                        ;#{{{6}}}
                myputs "expected pattern -$pattern- captured"
                myputs "output looks: $expect_out(buffer)" 2
                if $isSendFirst {
                    incr i;if {$i <= $host_num} {
                        if $parallel {
                            send_user "==output for\
                                $session2host($expect_out(spawn_id)):==\n"
                        }
                        send_user "$expect_out(buffer)\n"
                        set buf $expect_out(buffer)
                        eval $write_cmd_output
                        if $i<$host_num {exp_continue}
                    }
                    myputs "log_user set 1!"
                    log_user 1
                    return "RETURN_EXPECT_SENDFIRST1_NORMAL"
                } else {
                    if {$cmd == "MATCH_AGAIN"} {
                        return "RETURN_EXPECT_SENDFIRST0_MATCH_AGAIN"
                    } else {
                        if $timestamp {
                            myputs "timestamp is enabled"
                            send_user "\n[subst $current_time_cmd](local)\n"
                        } else {
                        }
                        myputs "sending data -$cmd- to $process now after pattern match"
                        if $datasent_noreturn {
                            myputs "send without a return"
                            exp_send -i $process "$cmd"
                        } else {
                            exp_send -i $process "$cmd\r"
                        }
                        return "RETURN_EXPECT_SENDFIRST0_NORMAL"
                    }
                }
            }
            -re $pattern_more {                                      ;#{{{6}}}
                exp_send -i $process "$pattern_more_key"
                exp_continue
            }
            timeout {                                       ;#{{{6}}}
                puts "timeout after ${timeout}s without a match for -$pattern-!"
                return "RETURN_EXPECT_TIMEOUT"
            }
            eof {                                           ;#{{{6}}}
                puts "spawned process terminated!"
                return "RETURN_EXPECT_EOF"
            }
            full_buffer {                                   ;#{{{6}}}
                puts2 "got full buffer!"
                exit 3
            }
        }
        exp_internal 0
    }
}
proc do_pag {\
    router cmds_array cmd_output_array  \
    {pa_intv 0} {pattern_timeout 120} {pa_pair 1}  \
    } { 
    myputs "==>entering do_pags"
    global global_data;eval $global_data
    global login_index
    global action_handler
    global code_return_expect_user_interupt
    global code_return_expect_user_interupt 
    global code_return_expect_sendfirst
    global code_return_reconnect
    global code_return_retry
    global code_return_ctrlc
    global code_return_exit
    global code_return_close
    global code_return_continue
    global code_return_timeout
    global during_login during_cmd action_handler_evaled 
    set action_handler_evaled 0
    upvar $cmds_array p_cmds_array
    upvar $cmd_output_array p_cmd_output_array
    set process host2session($router)
    myputs "start pattern-action sequence:"
    set send_initial_cr_ori $send_initial_cr
    if {[info exists p_cmds_array($router)] && \
       ![string equal $p_cmds_array($router) ""]} {
	myputs "pattern-action data for $router now looks:"
	myputs "  -$p_cmds_array($router)-"
        set cmd_list $p_cmds_array($router) 
        set does_cmds_array_exist 1
    } else {
        if {$cmds_array == "login_info"} {
            myputs "pattern-action data for $router doesn't exist, check config!"
            return "RETURN_DO_PA5_NO_PA"
        } elseif [info exists $cmds_array] {
            myputs "pattern-action data $cmds_array for $router\
                ${cmds_array}($router) doesn't exist as an array, but exists \
                    as a list, use [set $cmds_array] as cmd list!"
            set does_cmds_array_exist 1
            set cmd_list [set $cmds_array]
        } else {
            myputs "pattern-action data $cmds_array for $router\
                ${cmds_array}($router) doesn't exist, use $cmds_array as cmd list!"
            set does_cmds_array_exist 0
            set cmd_list $cmds_array
            set send_initial_cr 0 
        }
    }
    if $send_initial_cr {
        myputs "send_initial_cr set, send an initial cr"
        send -i $process "\r"
    }
    set send_initial_cr $send_initial_cr_ori
    set filename [sigdetect "SLEEP_ALL"]
    if  [regexp "SLEEP_ALL_(\d+)" $filename -> sleep_all_time] {
        myputs "forced to sleep for $sleep_all_time seconds by other instances"
        mysleep $sleep_all_time
        sigclean "SLEEP_ALL"
    } elseif [regexp "PEND_ALL" $filename] {
    } elseif [regexp "CONT_ALL" $filename] {
    }
    set do_pag_return "RETURN_DO_PA5_NORMAL"
    set i 0;set j 1         
    for {set i 0} {$i<=[expr [llength $cmd_list]-1]} {incr i} {
        if {$sigquit==1} {
            puts "SIGQUIT received,will stop the pattern-action executions!"
            return "RETURN_DO_PA5_SIGQUIT"
        }
        set time_now [clock click -milliseconds]
        array unset p_cmd_output_array $router,$j,*
        if {[info exists addclock] && $addclock} {
            if $debug { myputs "send a clock" }
            if [info exists clockcmd] { 
                myexpect $router ".*" "$clockcmd" $pattern_timeout 0 0
            }
        }
        if $pa_pair {
            set pattern_last    [lindex $cmd_list $i-2]	
            set pattern         [lindex $cmd_list $i]	
            set pattern_next    [lindex $cmd_list $i+2]	
            incr i
        } else {
            set pattern $pattern_common_prompt
        }
        if !$i {set pattern_prev $pattern}
        set datasent  [lindex $cmd_list $i]
        if !$i {set datasent_prev $datasent}
        global $datasent
        if { [array exists $datasent] && !$pa_pair || \
             [info exists $datasent]} {
            myputs "this pa_group \"$datasent\" is not an end 'leaf' node"
            myputs "it was defined as an array: [subst ${datasent}($router)]"
            myputs "and it contains: [subst $${datasent}($router)]"
            set do_pag_return [do_pag $router $datasent cmd_output_array_pags \
                                 $pa_intv $pattern_timeout $pa_pair]
        } else {       ;#if it's a leaf list, execute the list
            myputs "this pa_group \"$datasent\" is end 'leaf' node, will execute it..."
            if {[regexp {GRES\s*(\d*)} $datasent -> interval_gres]} {
                myputs "GRES command detected!"
                if {[string equal $interval_gres ""]} {set interval_gres 300}
                set return_gres [switchover $router $interval_gres]
                set p_cmd_output_array($router,$j,$datasent,$time_now) $datasent
                if {$return_gres=="RETURN_GRES_SUCCESS" ||  \
                    $return_gres=="RETURN_GRES_FORCE_RPD" || \
                    $return_gres=="RETURN_GRES_SESSION_CLOSED" \
                } {
                    myputs "GRES succeeded"
                    catch {close $process;wait $process}
                    puts "will reconnect in ${reconnect_interval}s"
                    mysleep $reconnect_interval
                    puts "reconnecting ..."
                    spawn_login $router
                } else {
                    puts "GRES not succeeded"
                    return return_gres
                }
            } elseif [regexp {SLEEP\s*(\d+)\s*;?(.*)} $datasent -> sleeptime cmd] {
                if {[string equal $sleeptime ""]} {set sleeptime 3}
                if $debug {myputs "sleep for ${sleeptime}s"}
                if $pa_pair {
                    expect -i $process -re "$pattern" {
                        mysleep $sleeptime
                        send -i $process "[info_subs2 $cmd]\r"
                    }
                } else {
                    mysleep $sleeptime
                    send -i $process "[info_subs2 $cmd]\r"
                }
                set p_cmd_output_array($router,$j,$datasent,$time_now) $datasent
            } elseif [regexp {UPGRADE (\S+)} $datasent -> rel] {
                upgrade $rel
                set p_cmd_output_array($router,$j,$cmd,$time_now) $datasent
                send -i $process "exit\r"
                expect -i $process -nocase -re $pattern_connection_close_msg {
                    puts "will reconnect in ${reconnect_interval}s"
                    mysleep $reconnect_interval
                    close;wait
                    spawn_login $router
                }
            } elseif {[regexp {SLEEP_ALL\s*(\d+)} $datasent -> sleeptime]} {
                sigraise "SLEEP_ALL_$sleeptime"
            } elseif [regexp {LOCALPRINT (.*)} $datasent -> msg] {
                puts $msg; send -i $process "\r"
            } elseif {[string equal $datasent "GOBACKGROUND"]} {
                myputs "will send control chars of GOBACKGROUND if expected pattern seen"
                if $pa_pair {
                    expect -i $process -re "$pattern" {
                        myputs "pa_pair set and expected -$pattern- seen, will \
                        send interupt pattern $key_interact and then \
                        key_background $key_background"
                        send -i $process [CONST $key_interact]
                        sleep 1
                        send -i $process [CONST $key_background]
                    }
                } else {
                    myputs "pa_pair not set, will just send key_background \
                        $key_background without expecting anything"
                    send -i $process [CONST $key_background]
                }
                set p_cmd_output_array($router,$j,$datasent,$time_now) $datasent
            } elseif {[string equal $datasent "PEND_ALL"]} {
                sigraise "PEND_ALL"
            } elseif {[string equal $datasent "CONT_ALL"]} {
                sigraise "CONT_ALL"
            } elseif {[string equal $datasent "USER_INPUT"]} {
                set initoldmode [stty -raw]
                myputs "initoldmode looks $initoldmode"
                myputs "pattern/_next/last looks $pattern/$pattern_next/$pattern_last"
                if [regexp -nocase "sword" $pattern] {
                    myputs "current pattern looks a prompt for password, will hide input"
                    set oldmode [stty -echo]
                    myputs "oldmode $oldmode saved"
                    set ispass 1
                } else {
                    set ispass 0
                }
                if [string equal $pattern_last "$"] {
                    set pattern_last "\\\$"
                }
                set timeout $pattern_timeout
                if ![string equal $pattern_next ""] {
                    expect {
                        -i $user_spawn_id 
                            -re "(\[^\n\]*)\n" {
                                myputs "you answered $expect_out(1,string)\n"
                                myputs "will send your input and exp_continue\
                                    to check the next pattern match"
                                send -i $process "$expect_out(1,string)\r"
                                if $ispass {
                                    myputs "recover old terminal mode:$oldmode"
                                    eval stty $oldmode
                                }
                                exp_continue
                            }
                        -i $process 
                            -re "$pattern" {
                                myputs "\nmatching current pattern\
                                    -[list $pattern]- \n"
                                myputs "will exp_continue and wait for input\n"
                                if [info exists oldmode] {eval stty $oldmode}
                                if [regexp -nocase "sword" $pattern] {
                                    myputs "this looks a prompt for password,\
                                        will hide info"
                                    set oldmode [stty -echo]
                                    myputs "oldmode $oldmode saved"
                                    set ispass 1
                                } else {
                                    set ispass 0
                                }
                                exp_continue
                            }
                            -notransfer -re "$pattern_next" {
                                myputs "\nmatching next pattern\
                                    -[list $pattern_next]- \n"
                                myputs "good, will go next pa-pair!\n"
                            }
                            -re "$pattern_last" {
                                myputs "\nmatching last pattern\
                                    -[list $pattern_last]- \n"
                                myputs "will exp_continue and wait for input\n"
                                if [info exists oldmode] {eval stty $oldmode}
                                if [regexp -nocase "sword" $pattern_last] {
                                    myputs "this looks a prompt for password,\
                                        will hide info"
                                    set oldmode [stty -echo]
                                    myputs "oldmode $oldmode saved"
                                    set ispass 1
                                } else {
                                    set ispass 0
                                }
                                exp_continue
                            }
                    }
                } else {
                    expect {
                        -i $user_spawn_id 
                            -re "(\[^\n\]*)\n" {
                                if $debug {
                                    myputs "you answered $expect_out(1,string)\n"
                                }
                                send -i $process "$expect_out(1,string)\r"
                            }
                    }
                }
                exp_internal 0
                eval stty $initoldmode
            } elseif [regexp {SET\s*(\S+):(.*)} "$datasent" -> settype setvalue] {
                myputs "settype:setvalue looks -$settype:$setvalue-"
                if {$settype == "OPTION"} {
                    array set options_bak [array get options]
                    if [catch {eval $setvalue} msg] {
                        puts $msg
                    }
                    myputs "executed -$setvalue-"
                    foreach idx [array name options] {
                        set options($idx) [set $idx]
                    }
                    set diff [arraycomp options_bak options]
                    myputs "these options have been changed: -$diff-"
                    foreach idx $diff {
                        set options_inline($idx) $options($idx)
                    }
                } elseif {$settype == "SHELL"} {
                    if [catch {exec $setvalue} msg] {
                        puts $msg
                    }
                } else {
                }
            } else {
                if [regexp {(.*)NOCR} $datasent -> datasent] {
                    set options_inline(datasent_noreturn) 1
                    set options(datasent_noreturn) 1
                    set datasent_noreturn 1
                } else {
                    set options_inline(datasent_noreturn) 0
                    set options(datasent_noreturn) 0
                    set datasent_noreturn 0
                }
                if [regexp {DECRY(.*)} $datasent -> datasent] {
                    set datasent [lindex "[str_polisher "$datasent" 2]" 0]
                }
                if {$hideinfo>=2} { 
                    log_user 0
                }
                set retry_count 1
                while {$retry_count <= $retry_max} {
                    incr retry_count
                    myputs "\[do_pags\]timeout:-$pattern_timeout-,\
                            pattern:-$pattern-, datasent:-$datasent-,\
                            pa_pair:-$pa_pair-"
                    if $does_cmds_array_exist {
                        set myexpect_return [myexpect $router $pattern     \
                            $datasent $pattern_timeout [expr !$pa_pair] 0   \
                        ]
                    } else {
                        send -i $process "$datasent\r"
                        set myexpect_return "RETURN_EXPECT_SENDFIRST1_NORMAL"
                    }
                    if {$hideinfo==1} { 
                        send_user "."
                    }
                    myputs "myexpect_return looks -$myexpect_return-"
                    set do_pag_return $myexpect_return
                    if [info exists action_handler($myexpect_return)] {
                        myputs "action defined as\
                            $action_handler($myexpect_return), eval it"
                        myputs "code to be eval.ed looks like" 3
                        myputs "[set $action_handler($myexpect_return)]" 3
                        eval [set $action_handler($myexpect_return)]
                        set action_handler_evaled 1
                        myputs "action_handler_evaled looks $action_handler_evaled"
                    } else {
                        myputs "action not defined"
                        set action_handler_evaled 0
                        break
                    }
                }       ;#while
                set p_cmd_output_array($router,$j,$datasent,$time_now) \
                    $expect_out(buffer)
            }   ;#end normal cmds
        }       ;#end non-nested cmd
        set datasent_prev $datasent
        set pattern_prev $pattern
        incr j;mysleep $pa_intv
        myputs "during_login looks $during_login, $action_handler_evaled"
        if $during_login {
            if $action_handler_evaled {
                puts "break the original p-a =================>"
                break
            }
        }
    }           ;#end walk-through
    myputs "<==leaving do_pags"
    return $do_pag_return
}
proc spawn_login {login_index} {   ;#{{{2}}}
    global global_data; eval $global_data
    global argc
    myputs "==> enter spawn_login now"
    set during_cmd 0
    set during_login 1
    set shell_to_spawn $env(SHELL)
    set shell_dir [file dirname $env(SHELL)]
    set shell_bash_full_path "$shell_dir/bash"
    if [file exists $shell_bash_full_path] {
        set shell_to_spawn $shell_bash_full_path
    }
    if [catch "spawn -noecho $shell_to_spawn" reason] {
        send_user "failed to spawn program: $reason\n"
        exit 1
    }
    set host2session($login_index) $spawn_id
    set session2host($spawn_id) $login_index
    myputs "process spawned is $spawn_id"
    if {$hideinfo>0} {
        log_user 0
    } else {
        log_user 1
    }
    log_user [expr !$hideinfo]
    if [regexp {(.+)\.clone} $login_index -> login_index_ori] {
        puts "this looks a clone"
        set login_index $login_index_ori
    }
    if {$argc>=1} {
        set login_info($login_index) [info_subs1 $login_info($login_index)]
        set do_pag_return [do_pag $login_index \
                        login_info cmd_output_array_login_info \
                        $interval_cmd $timeout_login]
        expect_compensation $login_index ;#{{{4}}}
        if {$do_pag_return=="RETURN_DO_PA5_NO_PA"} {
            if {$login_index=="LOCALHOST" || $local_task} {
                return "RETURN_SPAWN_LOGIN_LOCALSHELL"
            } else {
                puts "\nprocess \"$login_index\" not defined in config file:"
                puts "current config file in use is: \"$config_file\"!"
                puts "FYI a \"grep\" in above config file return this:"
                puts -nonewline "\n\"\n  "
                catch {system grep $login_index $config_file}
                puts "\n\"\n"
                puts "This is most probably caused by one of below reasons:"
                puts "1.the session was not configured in the above config file"
                puts "2.a suffix name (ex.\"$login_index@jtac\") is missing"
                puts "3.typo of session name: \"$login_index\"\n"
                puts "to confirm, exit and check config file"
                puts "or, select from below options:"
                puts "  C)heck: check config files"
                puts "  f)tp: connect with ftp"
                puts "  r)sh: connect with rsh"
                puts "  t)elnet: connect with telnet"
                puts "  s)sh: connect with ssh"
                puts "  q)uit: quit (exit) this script"
                mycatch "stty raw"
                set timeout 10000
                expect_user {
                    -re "C" {
                        puts "edit config file";system vim $config_file
                    }
                    -re "t" {
                        send_user "elnet ..."
                        set spawn_id [persist_login1 telnet $login_index]
                        puts "spawn_id looks $spawn_id"
                    }
                    -re "s" {
                        send_user "sh ..."
                        set spawn_id [persist_login1 ssh $login_index]
                    }
                    -re "r" {
                        send_user "sh ..."
                        set spawn_id [persist_login1 rsh $login_index]
                    }
                    -re "f" {
                        send_user "ftp ..."
                        set spawn_id [persist_login1 ftp $login_index]
                    }
                    -re "q" {
                        send_user "uit!";exit
                    }
                }
                if {$spawn_id == 0} {
                    spawn_login $login_index
                    mysleep 5
                }
                myputs "start to calculate reconnect"
            }
        } elseif {$do_pag_return=="RETURN_DO_PA5_NORMAL"} {
        } else {
            return $do_pag_return 
        }
    } else {    ;#{{{3}}}
        return "RETURN_SPAWN_LOGIN_LOCALSHELL"
    }
    return "RETURN_SPAWN_LOGIN_NORMAL"
}
proc exec_cmds {login_index {cmds "cmds1"}} {  ;#{{{2}}}
    myputs "\n"
    myputs "==> enter exec_cmds now"
    global global_data; eval $global_data 
    global $cmds cmd_output_array_$cmds cmd_output_array_${cmds}_prev
    global cmd_output_array_post_$cmds cmd_output_array_pre_$cmds
    global active_monitor pa_pair
    set process $host2session($login_index)
    set during_cmd 1
    set during_login 0
    proc list_cmds {cmds_group_name login_index} {      ;#{{{3}}}
        global global_data; eval $global_data
        upvar $cmds_group_name p_cmds_gn
        set ii 0
        foreach cmd $p_cmds_gn($login_index) {
            myputs2 "<<<<  $cmd\n"
            incr ii
            if {$ii > 5} {myputs2 "<<<<   ...";break}
        }
        puts ""
    }
    set is_special_char_in_cmd 0
    set is_expect [info exists options_cli(expect)]
    if [info exists ${cmds}($login_index)] {
        set cmds_list ${cmds}($login_index)
        foreach cmd [set ${cmds}($login_index)] { 
            if [regexp "(#|>|%|\\\$)$" $cmd] {set is_special_char_in_cmd 1} 
        }
    } elseif [info exists $cmds] {
        set cmds_list [set $cmds]
        foreach cmd $cmds_list { 
            if [regexp "(#|>|%|\\\$)$" $cmd] {set is_special_char_in_cmd 1} 
        }
    } else {
        set cmds_list $cmds
        myputs "<<<CRTC: $cmds_list does not exist!"
    }
    if {$is_expect ==1 ||\
        $is_special_char_in_cmd && $treat_special_char_as_pa\
    } {
        set pa_pair 1
    } else {
        set pa_pair 0
    }
    myputs "pa_pair set $pa_pair!"
    if [expr [info exists options_cli(expect)] ^ $pa_pair] {
        puts "<<<warning: -e not in use but pa_pair set, check cmds array in\
        case sth goes wrong!"
    }
    if {$hideinfo<2} {
        log_user 1
    } else {
        log_user 0
    }
    set interval_cmds_min $options(interval_cmds)
    set interval_cmds_max $options(interval_cmds)
    set options_inline(interval_cmds_min) $interval_cmds_min
    set options_inline(interval_cmds_max) $interval_cmds_max
    if {[info exists options_cli(interval_cmds)]} {
        set interval_cmds_min [lindex $options_cli(interval_cmds) 0]
        set options(interval_cmds_min) $interval_cmds_min
        set options_cli(interval_cmds_min) $interval_cmds_min
        if {[llength $options_cli(interval_cmds)] > 1} {
            set interval_cmds_max [lindex $options_cli(interval_cmds) 1]
            set options_cli(interval_cmds_max) $interval_cmds_max
            set options(interval_cmds_max) $interval_cmds_max
        } else {
            set interval_cmds_max [lindex $options_cli(interval_cmds) 0]
            set options_cli(interval_cmds_max) $interval_cmds_max
            set options(interval_cmds_max) $interval_cmds_max
        }
    } else {
    }
    proc do_pag_return_processing_code {do_pag_return} {
        global host2session login_index
        set process $host2session($login_index)
        if {$do_pag_return=="RETURN_DO_PA5_NO_PA"} {
        } elseif {$do_pag_return=="RETURN_EXPECT_TIMEOUT"} {
        } elseif {$do_pag_return=="RETURN_DO_PA5_NORMAL"} {
        } else {
        }
    }
    if {![string equal $regex_info($login_index) ""] ||       \
        ![string equal $issue_info($login_index) ""]} {
        set active_monitor 1
        myputs2 "<<<CRTC:either regex_info or issue_info not empty, \
            active_monitor set"
    } else {
        if $verbose {
            myputs2 "both regex_info or issue_info are empty, \
            not active_monitor"
        }
        set active_monitor 0
    }
    set actions_code {             
        if $active_monitor {
            myputs2 "<<<< actions_on_event is:$actions_on_event"
        }
        if [string equal $actions_on_event ""] {
            myputs2 "\n<<<< no action configured.\n\n"
        }
        foreach action $actions_on_event {
            if ![string equal $action ""] {
                if $active_monitor {
                    myputs2 "\n<<<< next action configured as :$action\n"
                }
            } 
            if [regexp {EXEC_(\w+)} $action -> cmds_group] {
                if ![string equal $cmds_group ""] {
                    set cmds_array_num 0
                    for {set ij 1} {$ij<=10} {incr ij 1} {
                        global $cmds_group$ij
                        if [info exists $cmds_group${ij}($login_index)] {
                            incr cmds_array_num
                        }
                    }
                    if $cmds_array_num {
                        myputs2 "<<<< and $cmds_array_num $cmds_group\"N\" \
                            defined, will alternate among them..\n\n"
                        if $alternate_on_hit {
                            set k [expr $hit % $cmds_array_num]
                        } else {
                            set k [expr $i % $cmds_array_num]
                        }
                        if !$k {set k $cmds_array_num}
                        set do_pag_return [do_pag $login_index \
                            $cmds_group$k cmd_output_array_$cmds_group \
                            $interval_cmd $timeout_cmd $pa_pair]
                    } else {
                        if $active_monitor {
                            myputs2 "\n<<<< and $cmds_group\"N\" not\
                            defined, will just execute $cmds_group (if defined)\n"
                        }
                        set do_pag_return [do_pag $login_index \
                            $cmds_group cmd_output_array_$cmds_group \
                            $interval_cmd $timeout_cmd $pa_pair]
                    }
                    do_pag_return_processing_code $do_pag_return
                } else {
                    puts "cmds group not provided in \"EXEC_\" action"
                }
            } elseif [string equal $action "EMAIL"] {
                myputs2 "\n<<<<issue hit the ${hit}th time!"
                myputs2 "\n<<<<post an email..."
                if [info exists emailto] {
                    postanemail $emailto $emailsub $emailbody
                } else {
                    myputs2 "\n<<<<email destination was not provided"
                }
            } elseif [string equal $action "EMAIL_MAX"] {
                if {$hit==$max_hits} {
                    myputs2 "\n<<<<issue hit max number ($max_hits) times!"
                    myputs2 "\n<<<<post an email..."
                    if [info exists emailto] {
                        postanemail $emailto $emailsub $emailbody
                    } else {
                        myputs2 "\n<<<<email destination was not provided"
                    }
                } else {
                    myputs2 "<<<<issue hit just $hit times (<$max_hits), \
                        won't send email yet!"
                }
            } elseif [string equal $action "EXIT_MAX"] {
                if {$hit==$max_hits} {
                    puts "<<<<issue hit max number ($max_hits) times! exit"
                    exit 8
                } else {
                    puts "<<<<issue hit $hit times (<$max_hits), continue!"
                }
            } elseif [string equal $action "EXIT"] {
                puts "exit!"
                exit
            } elseif [string equal $action "EXIT_ALL"] {
                puts "raise a STOP signal!"
                sigraise STOP
            }
        }
    }
    if {[info exists pre_${cmds}($login_index)] && \
       ![string equal [set pre_${cmds}($login_index)] ""]} {
        set do_pag_return [do_pag $login_index \
                        pre_$cmds cmd_output_array_pre_$cmds \
                        $interval_cmd $timeout_cmd $pa_pair]
        do_pag_return_processing_code $do_pag_return
        myputs "done pre_$cmds"
    } else {
        myputs "no pre_$cmds"
    }
    if [string equal $cmds_list  ""] {
            myputs "no $cmds!"
    } else {
        set exist_prev 0
        if [info exists issue_info($login_index)] {
            foreach issue_each $issue_info($login_index) {
                if [regexp "_prev" $issue_each] {
                    set exist_prev 1
                }
            }
            if $exist_prev {
                send_user "<<<< issue definition involves comparision\n"
                send_user "<<<< get a baseline of cmd outputs\n"
                set do_pag_return [do_pag $login_index \
                    $cmds cmd_output_array_${cmds}_prev \
                    $interval_cmd $timeout_cmd $pa_pair]
                do_pag_return_processing_code $do_pag_return
            } else {
                myputs "no comparision in issue definition, no need baseline"
                array set cmd_output_array_${cmds}_prev \
                    [array get cmd_output_array_$cmds]
            }
        }
        myputs2 "\n<<<< start the iterations ($max_rounds rounds)\n"
        set hit 0
        for {set i 1} {$i<=$max_rounds} {incr i 1} {
            if {[sigdetect "STOP"] != 0} {
            } else {
                puts "STOP signal found, will exit!"
                sigclean "STOP"
                exit
            }
            if $sigquit {puts "will stop cmds iterations!";break}
            if ![info exists options_cli(expect)] {
                if {$max_rounds > 1} {
                    if {$hideinfo<3} {
                        if $active_monitor {
                            myputs2 "\n\n[string repeat "- " 10]\
                                        iteration:${i} (hit $hit)\
                                        [string repeat "- " 10]\n"
                            myputs2 "\n\n<<<<\[iteration:${i}(hit $hit)\]=>\
                                $login_index:\n"
                        } else {
                            myputs2 "\n\n[string repeat "- " 10]\
                                        iteration:${i} \
                                        [string repeat "- " 10]\n"
                            myputs2 "\n\n<<<<\[iteration:${i}\]=>\
                                $login_index:\n"
                        }
                        list_cmds $cmds $login_index
                    }
                }
            }
            set do_pag_return [do_pag $login_index \
                            $cmds cmd_output_array_$cmds \
                            $interval_cmd $timeout_cmd $pa_pair]
            if !$exist_prev {
                array set cmd_output_array_${cmds}_prev \
                    [array get cmd_output_array_$cmds]
            }
            myputs "start to calculate reconnect"
            myputs "do_pag_return looks $do_pag_return"
            do_pag_return_processing_code $do_pag_return
            if {$debug>=3} {
                if [array exists $cmds] {
                    puts "cmd_output_array_cmds data structure \
                        (and the _prev version) now looks:"
                    parray cmd_output_array_$cmds
                    parray cmd_output_array_${cmds}_prev
                }
            }
            if $verbose {
                if [info exists options_cli(expect)] {
                    if {$max_rounds > 1} {
                        if {$hideinfo<3} {
                            myputs2 "\n[string repeat "- " 20]\n"
                            if $active_monitor {
                                myputs2 "\n\n<<<<\[iteration:${i}(hit $hit)\]=>\
                                    $login_index:\n"
                            } else {
                                myputs2 "\n\n<<<<\[iteration:${i}\]=>\
                                    $login_index:\n"
                            }
                            list_cmds $cmds $login_index
                        }
                    }
                }
            }
            if $active_monitor {
                myputs2 "\n<<<CRTC:parsing data to detect issue now...\n"
                if $all_met {
                    myputs2 "<<<CRTC:all_met set:indicate a problem\
                        only if all commands got hit"
                } else {
                    myputs2 "<<<CRTC:all_met not set: hit on any single command\
                        will indicate a problem"
                }
                if {[check_flag $cmds $flag_check_method]} {
                    incr hit
                    if {$hideinfo<3} {
                        if $active_monitor {
                            myputs2 "\n<<<< overall:monitored condition detected \
                                ($hit time(s))\007!"
                        }
                    }
                    set actions_on_event $actions_on_hit
                    if $active_monitor {
                        myputs2 "\n<<<< parsing actions_on_hit:\n"
                    }
                } else {
                    if {$hideinfo<3} {
                        if $active_monitor {
                            myputs2 "\n<<<< overall:monitored condition NOT detected!"
                        }
                    }
                    set actions_on_event $actions_on_nohit
                    if $active_monitor {
                    myputs2 "\n<<<< parsing actions_on_nohit:\n"
                    }
                }
                eval $actions_code 
            } else {
                myputs "not in issue-monitoring mode!"
            }
            if $reload_conf_inloop {
                myputs "reload_conf_inloop set $reload_conf_inloop, now reload_data"
                reload_data $login_index
            }
            set mysleep_return [mysleep \
                [random $interval_cmds_min $interval_cmds_max]\
            ]
            if {$mysleep_return==[CONST RETURN_SLEEP_CONTINUE]} {
                continue
            } elseif {$mysleep_return==[CONST RETURN_SLEEP_BREAK]} {
                if $pa_pair {
                    exp_send -i $process "\r"
                }
            }
        }
        myputs "done $cmds"
    } 
    if {[info exists post_${cmds}($login_index)] && \
       ![string equal [set post_${cmds}($login_index)] ""]} {
        set do_pag_return [do_pag $login_index \
                        post_${cmds} cmd_output_array_post_$cmds \
                        $interval_cmd $timeout_cmd $pa_pair]
        do_pag_return_processing_code $do_pag_return
        myputs "done post_$cmds"
    } else {
        myputs "no post_$cmds"
    }
    set timeout 2
    expect -i $process -re ".+" exp_continue
    myputs "<== leaving exec_cmds now"
    myputs "\n"
}
proc exec_cmds2 {login_index {cmds "cmds1"}} {  ;#{{{2}}}
    global global_data; eval $global_data 
    global code_update_template
    myputs "\n"
    myputs "==>enter exec_cmds2 now"
    set during_cmd 1
    set during_login 0
    if !$auto_resolve {
        exec_cmds $login_index $cmds
    } else {
        myputs "auto_resolve set"
        array set regex_info_backup [array get regex_info]
        array set issue_info_backup [array get issue_info]
        set i 101
        set j 1
        set cmd_group [set ${cmds}($login_index)]
        foreach a_cmd $cmd_group {
            myputs "get a cmd \"$a_cmd\"" 1
            regsub -all {%} $a_cmd "$" a_cmd
            myputs "scan and substitute to \"$a_cmd\"" 1
            set a_cmd_resolved [subst $a_cmd]
            set cmds${i}_resolve($login_index) [list $a_cmd_resolved]
            myputs "built an array cmds${i}_resolve: \
                [set [subst cmds${i}_resolve]($login_index)]" 1
            puts ""
            set has_regex 0
            foreach regex4onecmd $regex_info_backup($login_index) {
                myputs "get a regex \"$regex4onecmd\"" 1
                set regex_vars_list [split $regex4onecmd "@"]
                set cmd_num [lindex $regex_vars_list 0]
                set line_num [lindex $regex_vars_list 1]
                set regex [lindex $regex_vars_list 2]
                set the_vars [lrange $regex_vars_list 3 end]
                if {$cmd_num==$j} {
                    set regex_info_resolve($login_index) \
                        [list [join [list "1" $line_num $regex $the_vars] "@"]]
                    myputs "it's for current cmd $j"
                    myputs "generated a new regex_info_resolve:\
                        -$regex_info_resolve($login_index)-" 1
                    reload_data $login_index
                    uplevel {eval $code_update_template}
                    set has_regex 1
                    break
                }
                myputs "but it's for cmd $cmd_num, not for current cmd $j"
            }
            if !$has_regex {
                myputs "clear regex_info data" 0
                set regex_info_resolve($login_index) ""
                reload_data $login_index
                uplevel {eval $code_update_template}
            }
            set has_issue 0
            foreach issue4onecmd $issue_info_backup($login_index) {
                myputs "get an issue \"$issue4onecmd\"" 0
                set issue_vars_list [split $issue4onecmd "@"]
                set cmd_num [lindex $issue_vars_list 0]
                if {$cmd_num==$j} {
                    set issue_info_resolve($login_index) \
                        [string replace $issue4onecmd 0 0 1]
                    myputs "it's for current cmd $j"
                    myputs "generated a new issue_info_resolve:\
                        -$issue_info_resolve($login_index)-" 1
                    reload_data $login_index
                    uplevel {eval $code_update_template}
                    set has_issue 1
                    break
                }
                myputs "but it's for cmd $cmd_num, not for current cmd $j"
            }
            if !$has_issue {
                myputs "no issue defined for this cmd"
                myputs "clear issue_info_resolve data" 0
                set issue_info_resolve($login_index) ""
                reload_data $login_index
                uplevel {eval $code_update_template}
            }
            reload_data $login_index
            exec_cmds $login_index cmds$i
            global vars
            foreach avar $vars {global $avar}
            incr i
            incr j
        }
    }
    myputs "<==leaving exec_cmds2 now"
    myputs "\n"
}
proc myinteract {router} {    ;#{{{2}}}
    global global_data; eval $global_data
    global anti_idle_timeout_user_input_ori
    global anti_idle_timeout_proc_input_ori
    global myinteract_user_output_patterns
    global myinteract_process_input_patterns_static
    global myinteract_kibitz_input_patterns
    global code_myinteract_user_patterns env
    global myinteract_user_input_patterns
    global interact_a interact_b interact_l interact_any 
    global interact_v interact_multi_session
    global interact_timeout interact_n
    global process_output process_input 
    global kibitz_list kibitz_list_ori
    global kibitz_shell_prompt kibitz_user shell_list
    global inkibitz kibitz_user_list 
    global sid2user sid2typing ownertyping
    global argc select_host
    set kibitz_shell_prompt $pattern_no_match
    set kibitz_list ""
    set kibitz_list_ori ""
    set kibitz_user_list "$env(USER)"
    set inkibitz 0
    set ownertyping 1
    set timedout 0
    foreach asid [array name sid2typing] {
        set sid2typing($asid]) 0
    }
    set myinteract_process_input_patterns_static_ori \
        $myinteract_process_input_patterns_static
    if ![info exists log_fullname_cur] {
        set log_fullname_cur $log_fullname
    }
    set is_respawn 0
    set totimestamp 0;set is_usertyping 0;
    set cmd_input "";set buf_in ""
    set cmd_output "";set buf_out ""
    set didsave 0; set does_holdsession 0; set currenthost ""
    set command ""
    set kibitz_list ""
    set select_host 1
    if ![file exists $download_folder] {
    } else {
        set download_folder "/var/tmp"
    }
    if [info exists cmds_cli($router)] {
        set commandgroup "cmds_cli"
    } elseif [info exists cmds3($router)] {
        set commandgroup "cmds3"
    } else {
    }
    set anti_idle_timeout_user_input_ori $anti_idle_timeout_user_input
    set anti_idle_timeout_proc_input_ori $anti_idle_timeout_proc_input
    set kibitz 0
    set features_ori                    $features
    set enable_user_patterns_ori        $enable_user_patterns
    set process $host2session($router)
    if $send_initial_cr {
        myputs "send_initial_cr set, sent an intial cr"
        send -i $process "\r"
    }
    switch -exact -- $features {
        0       {
            set simple_interact 1
        } 
        default {
            set simple_interact 0
        }
    }
    if !$simple_interact {
        if {$log_when == 0} {
            set log_fullname "no logging     "
        }
        if $tips_on_login {
            myputs3 "full feature interact:\n"
            myputs3 "\n<<<_____________________________________________________________\n"
            myputs3 "<<<|log file: $log_fullname, !$key_background to move crtc bg   |\n"
            myputs3 "<<<|!t toggle local timestamp,       !l log related cmd        |\n"
            myputs3 "<<<|!c to iterate cmd(s)             !f to start file transfer |\n"
            myputs3 "<<<|!p to enable persistent mode     !A to enable autopaging   |\n"
            myputs3 "<<<|!h print all cli options,        !Q to exit crtc,          |\n"
            myputs3 "<<<|!i for a tutor doc (todo),       !? to list inline options |\n"
            myputs3 "<<<|___________________________________________________________|\n"
        }
        myputs3 "<<<$login_succeed_signature\n"
    } else {
        if $tips_on_login {
            myputs3 "simple interact:\n"
            myputs3 "press !N to equip crtc with more features\n"
            myputs3 "!q to exit; !? for list of cmds supported\n"
        }
        myputs3 "<<<$login_succeed_signature\n"
    }
    set process_input $host2session($router)
    set process_output $host2session($router)
    if {$parallel==0} {
    } elseif {$parallel==1} {
        set process_input $host2session($router)
        set process_output [arrayvalue host2session]
    } else {
        set process_input [arrayvalue host2session]
        set process_output [arrayvalue host2session]
        if $is_usertyping {
            set process_input $host2session($router)
        } else {
            if $does_holdsession {
                set process_input $interact_out(spawn_id)
            } else {
                set process_input [arrayvalue host2session]
            }
        }
    } 
    while 1 {           ;#{{{3}}}
        eval $code_myinteract_user_patterns
        if {$enable_user_patterns >= 2} {
            myputs "enable_user_patterns > 1, ignore static myinteract" 
            set myinteract_process_input_patterns_static ""
        } else {
            myputs "enable_user_patterns < 2, ignore dynamic myinteract"
            set myinteract_process_input_user_patterns ""
            set myinteract_process_input_patterns_misc ""
            set myinteract_process_input_patterns_static \
                $myinteract_process_input_patterns_static_ori
        }
        set myinteract_user_output_patterns ""
        if $double_echo {
            append myinteract_user_output_patterns [subst -nocommands {
                -nobuffer -re ".+" {
                    send_tty -- "[set interact_out(0,string)]"
                }
            }]
        } else {
            set myinteract_user_output_patterns ""
        }
        if ![info exists shell_list] {
            set shell_list ""
        }
        if [ni $process_input $shell_list] { 
            set shell_list [linsert $shell_list 0 $process_input]
            myputs "insert:$process_input into shell_list:$shell_list"
        }
        myputs "process - ${process_input}(in) :${process_output}(out)\
            :kibitz($kibitz_list)"
        myputs "shell_list - $shell_list; kibitz_list - $kibitz_list"
        set myinteractcmd [subst -nocommands {\n\
            interact {\n\
                -input $user_spawn_id\n\ 
                    $myinteract_user_input_patterns\n
                -output process_output\n\
                -input kibitz_list\n\
                    $myinteract_kibitz_input_patterns\n\
                -output process_output\n\
                -input process_input\n\
                    $myinteract_process_input_user_patterns\n\
                    $myinteract_process_input_patterns_misc\n\
                    $myinteract_process_input_patterns_static\n\
                -output $user_spawn_id\n\
                    $myinteract_user_output_patterns\n\
                -output kibitz_list\n\
            }\n\
        }]
        myputs "myinteractcmd looks $myinteractcmd" 3
        set myinteractcmd_simplified [subst -nocommands {\n\
            interact {\n\
                -input $user_spawn_id\n\ 
                    $myinteract_user_input_patterns\n
                -output process_output\n\
                -input process_input\n\
                -output $user_spawn_id\n\ 
            }\n\
        }]
        set interact_simplest {
            interact {
                -echo "!N" {                                    ;#{{{5}}}
                    interact_N;return
                }
                -echo "!q" {                                    ;#{{{5}}}
                    exit
                }
                -echo "!?" {                                    ;#{{{5}}}
                    send_error "inline commands:\n"
                    send_error "  !N  load more features"
                    send_error "  !q  exit"
                    send_error "  !?  this help\n"
                }
                -reset "![CONST $key_background]" {             ;#{{{5}}}
                    puts "\[session $router\]: you pressed a keystroke\
                        \"!$key_background\" that moves this session background,\
                        type `fg` to move it foreground when needed!"
                    exec kill -STOP [pid]
                }
                timeout $anti_idle_timeout_user_input {       ;#{{{5}}}
                    log_user 0
                    if [string equal $anti_idle_string "null"] {
                        send -i $process -null
                    } else {
                        send -i $process "$anti_idle_string"
                    }
                    log_user 1
                    if {($features_ori == 2) && ($features != $features_ori)} {
                        myputs "original feature was $features_ori and was \
                            changed to $features, "
                        myputs "set to 2 on timed out..."
                        myputs2 "\r\nuser timeout after ${anti_idle_timeout}s,"
                        myputs2 "\r\nswitched back to original (monitoring) mode\n"
                        set features 3
                        set enable_user_patterns $enable_user_patterns_ori
                        return
                    }
                }
            }
        }
        myputs "features now looks $features"
        switch -exact -- $features {
            0       {
                set simple_interact 1
            } 
            default {
                set simple_interact 0
            }
        }
        myputs "features looks $features"
            if $simple_interact {
                eval $interact_simplest
            } else {
                eval $myinteractcmd
            }
        foreach opt [array name options] {
            if [info exists $opt] {
                set options($opt) [set $opt]
            }
        }
        if $is_respawn {
            set is_respawn 0
            set sigquit 0
            spawn_login $router
        }
    }   ;#end while
}
set interact_a {        ;#{{{3}}}
    set timeout 60
    send_user "input your tcl command:\n"
    catch {set oldmode [stty -raw echo]}
    expect_user {
        -re "(\[^\n]+)\n" {
            set user_tcl $expect_out(1,string)
            set options_inline(attribute) $user_tcl
            set l_tcl [split $user_tcl ";"]
            foreach a_tcl $l_tcl {
                if [regexp {set\s+(\S+)\s*(\S*)} $a_tcl -> op va] {
                    myputs "you input command: :$a_tcl:$op:$va:"
                    if ![string equal $va ""] {
                        catch {
                            eval $a_tcl
                            set options($op) $op
                            set options_inline($op) $op
                        }
                        puts "set $op to $va\n"
                        return          ;#return to make change taking effect
                    } else {
                        if [info exists $op] {
                            catch {
                                send_user -- "$op is [set $op]\n"
                            }
                        } else {
                            send_user "$op is not a valid CRTC option!\n"
                        }
                    }
                } else {
                    puts "warning: $a_tcl is not a valid tcl expression!"
                    exp_continue
                }
            }
        }
        -re "\n" {
            send_user "<<<CRTC:eh?\n"
        }
        timeout {
            send_user "you didn't input anything in $timeout second...\n"
        }
    }
}
set interact_b {        ;#{{{3}}}
    send_user "toggle screen sharing..."
    if ![string equal [set kibitz_list] ""] {
        set kibitz_list_ori [set kibitz_list]
        send -i kibitz_list "sharing is turned off tempararily...\r\n"
        set kibitz_list ""
        puts "sharing is blocked among users: $kibitz_user_list"
    } else {
        set kibitz_list [set kibitz_list_ori]
        send -i kibitz_list "sharing is turned on now...\r\n"
        puts "sharing is recovered among users: $kibitz_user_list"
    }
}
set interact_any {      ;#{{{3}}}
    set timedout 0
    if [string equal $interact_out(0,string) "\r"] {
        myputs "you typed a return" 2
        set is_usertyping 0
        send_user $automation_non_complete_msg
        if $timestamp {
            set totimestamp 1
            myputs "will timestamp"
            if !$features {
                send_user "\n[subst $current_time_cmd](local)\n"
            }
        }
    } else {
        set is_usertyping 1
        myputs "you typed -$interact_out(0,string)-"
    } 
    if $ownertyping {           ;#{{{4}}}
        myputs "user is typing" 2
        myputs "not inkibitz" 2
        if {$features_ori == 2} {   ;#{{{5}}}
            myputs "flexible features ($features) is configured"
            if {$enable_user_patterns >= 2} {   ;#{{{6}}}
                myputs2 "\r\nswitch to fast mode (user is typing)!\n"
                myputs "change current enable_user_patterns \
                    ($enable_user_patterns) to 1"
                set enable_user_patterns 1
            }
            myputs "set features 1"
            set features 1
        }
    } else {                    ;#{{{4}}}
        set ownertyping 1
        if $inkibitz {          ;#{{{5}}}
            send -i $kibitz_list "\r\n<---$env(USER) is typing ...\r\n"
            foreach asid [array name sid2typing] {
                set sid2typing($asid) 0
            }
        } 
    }
    set pattern_cmd_input ".+"
    if [string equal $interact_out(0,string) '\r'] {
        puts "\nmatch enter from .+"
    }
    return
}
set interact_l {        ;#{{{3}}}
    puts "\nselect from below options:"
    puts "n)ew   : start a new log"
    puts "s)top  : stop logging on current file(will start logging"
    puts "         in original file if a new file is in use)"
    puts "S)top  : stop all logging"
    puts "r)esume: resume logging in last file"
    puts "t)oggle: toggle between new file and original log file"
    puts "v)iew  : view log file"
    puts "l)ist  : list current log file"
    puts "e)mail : email current log"
    puts "q)uit  : quit the menu without doing anything"
    expect_user {
        -re "e" {
            puts "mail current log $log_fullname_cur to $emailto"
            sendanemail $log_fullname_cur $emailto
        }
        -re "n" {
            puts "ew log file name:"
            set log_filename_new [gets stdin]
            set log_fullname_new "$log_dir_new/$log_filename_new"
            log_file
            log_file $log_fullname_new
            set log_fullname_cur $log_fullname_new
            puts "logging in new file $log_fullname_new ..."
        }
        -re "s" {
            log_file
            log_file $log_fullname
            puts "top logging in current file and continue on\
                $log_fullname"
            set log_fullname_cur $log_fullname
        }
        -re "S" {
            log_file
            puts "top logging in any log file"
            set log_fullname_cur "NULL"
        }
        -re "r" {
            if ![string equal $log_fullname_cur "NULL"] {
                puts "esume logging to $log_fullname_cur"
                log_file $log_fullname_cur
            } else {
                puts "esume logging to $log_fullname"
                log_file $log_fullname
            }
        }
        -re "v" {
            if ![string equal $log_fullname_cur "NULL"] {
                puts "iew the log file:$log_fullname_cur"
                system less $log_fullname_cur
            } else {
                puts "currently no logging!"
            }
        }
        -re "l" {
            if ![string equal $log_fullname_cur "NULL"] {
                puts "ist current log file: $log_fullname_cur"
            } else {
                puts "currently no logging!"
            }
        }
        -re "q" {
            puts "log file not changed!"
        }
        -re "t" {
        }
        -re "." {
            send_user "eh?\n"
        }
    }       ;#expect_user inside !l
}
proc interact_A {} {    ;#{{{3}}}
    global global_data; eval $global_data 
    if $auto_paging {
        set auto_paging 0
        set pattern_more $pattern_no_match
    } else {
        set auto_paging 1
        set pattern_more $pattern_more_const
    }
    puts "\nauto_paging $auto_paging"
    set options(auto_paging) $auto_paging
    set options_inline(auto_paging) 0
    set options(pattern_more) $pattern_more_const
    puts "options(pattern_more) looks $options(pattern_more) now"
    set options_inline(pattern_more) $pattern_more_const
}
proc interact_c {router} {    ;#{{{3}}}
    upvar command command1
    upvar router router1
    upvar commandgroup commandgroup1
    global global_data; eval $global_data
    global cmds_c cmds_c_backup
    array unset cmds_c
    foreach host1 $hostlist_full { reload_data $host1 }
    set oldmode [mystty -info]
    mycatch "mystty raw"
    send_user "\n"
    send_user "select your choice below:\n"
    send_user "1: enter command, or command array($commandgroup1)\n"
    send_user "   configured in config file to be executed\n"
    send_user "\n2: repeat the last commands/command array"
    send_user "\nq: quit\n"
    set timeout -1
    expect_user {
        -re {\d} {
            set selection $expect_out(buffer)
            if {$selection <=0 || $selection >=3} {
                puts "$selection: not a valid option, select (1,2,q) again:"
                exp_continue
            }
        }
        "q" {
            puts "uit"
            return
        }
        -re "\r" {
            set selection 1
        }
        -re ".+" {
            set selection $expect_out(buffer)
            puts "$selection: not a valid option, select (1,2,q) again:"
            exp_continue
        }
    }
    mycatch "mystty -raw"
    if {$selection==1} {
        set command_ori $command1
        puts "Enter the command/command array you want to iterate:"
        puts "   \[$command_ori\]"
        flush stdout;
        while 1 {
            set get_nothing 1
            set read_stdin [gets stdin]
            if [string equal $read_stdin ""] {
                if $get_nothing {
                    lappend cmds_c($router1) $command_ori
                }
                myputs "seeing empty input, will break loop"
                myputs "so far got:\n$cmds_c($router1)"
                break
            } else {
                set get_nothing 0
                set command1 $read_stdin
                myputs "get command $command1"
                lappend cmds_c($router1) $command1
                myputs "so far got:\n$cmds_c($router1)"
            }
        }
        myputs "eventually got:\n$cmds_c($router1)"
        set command_ori $command1
        set cmds_c_backup($router1) $cmds_c($router1)
        set max_rounds_ori $max_rounds
            puts "Enter how many iterations you want to run:\
                \[$max_rounds\]";flush stdout;
            set read_stdin [gets stdin]
            if ![regexp {(\d+)} $read_stdin -> max_rounds] {
                myputs "no max round inputted"
                set max_rounds $max_rounds_ori
                set options(max_rounds) $max_rounds_ori
                set options_inline(max_rounds) $max_rounds_ori
            } else {
                set options(max_rounds) $max_rounds
                set options_inline(max_rounds) $max_rounds
            }
            set max_rounds_ori $max_rounds
        set interval_cmds_ori $interval_cmds
            puts "Enter intervals between each iteration: \
                \[$interval_cmds\]";flush stdout;
            set read_stdin [gets stdin]
            if ![regexp {(\d+)} $read_stdin -> interval_cmds] {
                myputs "no intervals inputted"
                set interval_cmds $interval_cmds_ori
                set options(interval_cmds) $interval_cmds_ori
                set options_inline(interval_cmds) $interval_cmds_ori
            } else {
                set options(interval_cmds) $interval_cmds
                set options_inline(interval_cmds) $interval_cmds
            }
            set interval_cmds_ori $interval_cmds
        mycatch "stty raw"
        puts "will iterate command/command group \[$command1\] \
            $max_rounds rounds with interval $interval_cmds \
            between each iteration,(y)es/(n)o/(q)uit?\[y\]"
    } elseif {$selection==2} {
        mycatch "stty raw"
        puts "will iterate command/command group \[$command1\] \
            $max_rounds rounds with interval $interval_cmds \
            between each iteration,(y)es/(n)o/(q)uit?\[y\]"
        set cmds_c($router1) $cmds_c_backup($router1)
    } else {
        puts "to do"
    }
    mycatch "mystty raw"
    expect_user {
        -re "y|\r" {
            parray cmds_c
            exec_cmds $router1 cmds_c
            send_user "all done!\n"
            set command_ori $command1
            set max_rounds_ori $max_rounds
            set interval_cmds_ori $interval_cmds
        }
        "q" {
            puts ""
        }
        "n" {
            myputs "input your data again"
        }
        -re "." {
            puts "invalid input! press one of these:\[ynq<ENTER>\]"
            exp_continue
        }
    }
    mycatch "mystty $oldmode"
}
proc interact_r {router} {      ;#{{{3}}}
    global pa_pair host2session
    set process host2session($router)
    set yn "q"
    while 1 {
        puts "to repeat the previous cmds1 executions,\
            right((y)es/(q)uit?\[y\])"
        mycatch "stty raw"
        expect_user {
            -re "y|\r" {
                set sigquit 0
                if $pa_pair {
                    send -i $process "\r"
                }
                exec_cmds $router
                break
            }
            "q" {
                puts "\n"
                break
            }
            "?" {
                puts "\n"
            }
        }
        mycatch "stty -raw"
    }
}
set interact_multi_session {    ;#{{{3}}}
    myputs "you pressed $interact_out(0,string)"
    for {set i 1} {$i<10} {incr i 1} {
        if [info exists interact_out($i,string)] {
            myputs "interact_out($i,string) is $interact_out($i,string)"
        }
    }
    interact_multi_session $interact_out(1,string)
}
proc interact_multi_session {user_key} {        ;#{{{3}}}
    global global_data; eval $global_data
    global shell_list kibitz_list kibitz_list_ori
    global process_input process_output
    global select_host inkibitz
    global sid2user sid2typing inkibitz 
    global kibitz_user_list kibitz_user login_index
    upvar process process
    upvar router router
    switch -exact -- $user_key {
        "c" {   ;#{{{4}}}
            interact_y
        }
        "k" {   ;#{{{4}}}
            if [in $process_input [lrange $shell_list 1 end]] {
                set spawn_id $process_input
            } else {
                puts "you are still in the session to be shared, to share this\
                    session, you need to switch to a shell.\n\
                    type \\l to list available shells; \\NUMBER to select one"
                return
            }
            puts "-----------------------------------"
            set kibitz_user [user_input "which user is this?"]
            set process_input [arrayvalue host2session]
            set process_output [arrayvalue host2session]
            lappend kibitz_list_ori $spawn_id
            set kibitz_list $kibitz_list_ori
            set sid2user($spawn_id) $kibitz_user
            set sid2typing($spawn_id) 0
            ldelete shell_list $spawn_id
            myputs "shell_list: $shell_list: kibitz_list: $kibitz_list" 0
            myputs "kibitz_list_ori: $kibitz_list_ori:current sid:$process_input" 0
            set inkibitz 1
            send -i $kibitz_list "session $login_index is being shared between\
                \[$kibitz_user_list\] now...\n"
            send -i $kibitz_list "to exit, type ctrl+\], and then \"exit\""
        }
        "i" {   ;#{{{4}}}
            set hostnum [lsearch [array names session2host] $process]
            send_user "you are in $session2host($process)\
                ([expr $hostnum+1]), press '\\\[NUMBER\]\' to \
                switch to other host!\n"
            send_user "host lists: \n";set i 1
            foreach host $hostlist_full {
                send_user "$host ($i) ";incr i
                if {$i >=20} {
                    send_user "too much hosts..won't print all in here\n"
                    break
                }
            }
            send_user "\n"
            set select_host 1   
        }
        "l" {   ;#{{{4}}}
            send_user "host lists: \n";set i 0
            foreach id $shell_list {
                send_user "$i:$id/[exp_pid -i $id] ";incr i
                if {$i >= 20} {
                    send_user "too much shells..won't print all in here\n"
                    break
                }
            }
            send_user "\n"
            myputs "shell_list: $shell_list: kibitz_list: $kibitz_list"
            myputs "kibitz_list_ori: $kibitz_list_ori:current sid:$id"
            set select_host 0
        }
        "s" {   ;#{{{4}}}
            while 1 {
                mycatch "stty -raw"
                set routername_ori $router
                puts "Enter the router name you want to login: \[$routername_ori\]"
                    flush stdout;
                set routername [gets stdin]
                    if [string equal $routername ""] {
                        myputs "no router name was given"
                        set routername $routername_ori
                    }
                puts "login router \[$routername\],(y)es/(n)o/(q)uit?\[y\]"
                    flush stdout;
                mycatch "stty raw"
                expect_user {
                    -re "y|\r" {
                        send_user "login to $routername ...\n"
                        reload_data $routername
                        spawn_login $routername
                        set hostlist_full "$hostlist_full $routername"
                        break
                    }
                    "q" {
                        puts ""
                        break
                    }
                    -re "." {
                    }
                }
                mycatch "stty -raw"
            }
        }
        "q" {   ;#{{{4}}}
        }
        default {               ;#{{{4}}}
            myputs "select_host looks $select_host"
            if $select_host {   ;#{{{5}}}
                set hostnum $user_key
                myputs "hostlist_full is -$hostlist_full-"
                myputs "you entered hostnum $hostnum"
                if {$hostnum > 0 && $hostnum<=[llength $hostlist_full]} {
                    set router [lindex $hostlist_full $hostnum-1]
                    set process_input $host2session($router)
                    set process_output $host2session($router)
                    puts "switched to #$hostnum host:$router (session\
                        $process_input)"
                    return
                } else {        
                    puts "you entered an unknown host number!"
                    puts "host lists: ";set i 1
                    foreach host $hostlist_full {
                        send_user "$host ($i) ";incr i
                    }
                    send_user "\n"
                }
            } else {            ;#{{{5}}}
                set shellnum $user_key
                if {$shellnum >= 0 && $shellnum<[llength $shell_list]} {
                    set id [lindex $shell_list $shellnum]
                    set process_input $id
                    set process_output $id
                    puts "switched to session: $shellnum:$id/[exp_pid -i $id]"
                    if {$shellnum > 0} {
                    } else {
                        if [info exists kibitz_list_ori] {
                            set kibitz_list $kibitz_list_ori
                        } else {
                            set kibitz_list ""
                        }
                    }
                    myputs "shell_list: $shell_list: kibitz_list: $kibitz_list"
                    myputs "kibitz_list_ori: $kibitz_list_ori:current sid:$id"
                    return
                } else {
                    puts "you entered an unknown host number!"
                    puts "host lists: ";set i 1
                    foreach host $hostlist_full {
                        send_user "$host ($i) ";incr i
                    }
                    send_user "\n"
                }
            }
        }
    }
}
proc interact_t {} {    ;#{{{3}}}
    global global_data; eval $global_data
    if {$timestamp==0} {
        set timestamp 1
        set pattern_timestamp "\r"
        set pattern_timestamp_verbose $pattern_no_match
        puts "imestamp 1 - local timestamp on!"
    } else {
        set timestamp 0
        set pattern_timestamp $pattern_no_match
        set pattern_timestamp_verbose $pattern_no_match
        puts "imestamp 0 - local timestamp off!"
    }
    set options(timestamp) $timestamp
    set options(pattern_timestamp) $pattern_timestamp
    set options(pattern_timestamp_verbose) $pattern_timestamp_verbose
    set options_inline(timestamp) $timestamp
    set options_inline(pattern_timestamp) $pattern_timestamp
    set options_inline(pattern_timestamp_verbose) \
        $pattern_timestamp_verbose
}
proc interact_T {} {    ;#{{{3}}}
    global global_data; eval $global_data
    if {$timestamp==0} {
        set timestamp 2
        set pattern_timestamp_verbose "(\[^\r\]*)\r\n"
        puts "\ntimestamp $timestamp"
        puts "all cmd output lines will be timestamped, 
                type !T one more time to turn this off"
    } else {
        set timestamp 0
        set pattern_timestamp_verbose $pattern_no_match
        puts "\ntimestamp $timestamp"
    }
    set options(timestamp) $timestamp
    set options(pattern_timestamp_verbose) $pattern_timestamp_verbose
    set options_inline(timestamp) $timestamp
    set options_inline(pattern_timestamp_verbose) \
        $pattern_timestamp_verbose
}
proc interact_u {} {    ;#{{{3}}}
    global global_data; eval $global_data
    switch -exact -- $enable_user_patterns {
        0 {
            set enable_user_patterns 1
        } 1 {
            set enable_user_patterns 2
        } 2 {
            set enable_user_patterns 3
        } default {
            set enable_user_patterns 0
        }
    }
    puts "\nenable_user_patterns $enable_user_patterns"
    set options(enable_user_patterns) $enable_user_patterns
    set options_inline(enable_user_patterns) $enable_user_patterns
}
proc interact_z {} {    ;#{{{3}}}
    global global_data; eval $global_data
    if $compress_log {
        set compress_log 0
    } else {
        set compress_log 1
    }
    puts "\ncompress_log $compress_log"
    set options(compress_log) $compress_log
    set options_inline(compress_log) $compress_log
}
proc interact_Z {} {    ;#{{{3}}}
    global global_data; eval $global_data
    global anti_idle_timeout_user_input_ori anti_idle_timeout_proc_input_ori
    if $no_anti_idle {
        set no_anti_idle 0
        set options_inline(anti_idle_timeout_user_input) $anti_idle_timeout_user_input_ori
        set options_inline(anti_idle_timeout_proc_input) $anti_idle_timeout_proc_input_ori
    } else {
        set no_anti_idle 1
        set options_inline(anti_idle_timeout_user_input) 100000000
        set options_inline(anti_idle_timeout_proc_input) 100000000
        myputs "\nno_anti_idle $no_anti_idle, anti_idle_timeout set to indefinite"
    }
    set options(no_anti_idle) $no_anti_idle
    set options_inline(no_anti_idle) $no_anti_idle
}
proc interact_connection_close {} {     ;#{{{3}}}
    global global_data; eval $global_data
    puts "\[crtc:detected connection closed!\]"
    if $no_reconnect_on_interact {
        puts "no_reconnect_on_interact set, won't reconnect\n"
        if $exit_sync {
            puts "exit_sync set, exit crtc"
            exit
        } else {
            myputs2 "exit_sync not set, you are still in crtc!\
                (type !? to confirm this).\nTo exit crtc, \
                type !Q to kill the script...\n"
        }
    } else {
        if $exit_sync {
            puts "exit_sync set, exit crtc"
            exit
        } else {
            myputs2 "exit_sync not set, you are still in crtc!\
                (type !? to confirm this).\nTo exit crtc, \
                type !Q to kill the script...\n"
        }
        if {$persistent>1} {
            myputs2 "persistent mode set $persistent,\
                will reconnect in ${reconnect_interval}s\n"
            myputs2 "type !p to toggle persistent mode"
            mysleep $reconnect_interval
            close; wait
            uplevel {set is_respawn 1}
            return 1
        } else {
            puts "persistent mode set $persistent, won't reconnect\n"
        }
    }
}
proc interact_pattern_cmd_input {user_keystroke} {    ;#{{{3}}}
    global parallel session2host
    upvar is_usertyping is_usertyping1
    upvar didsave didsave1
    upvar buf_in buf_in1
    upvar buf_out buf_out1
    upvar cmd_input cmd_input1
    upvar currenthost currenthost1
    upvar does_holdsession does_holdsession1
    if $is_usertyping1 {                ;#{{{4}}}
        append buf_in1 $user_keystroke
        set didsave1 0
        send_user -- $user_keystroke
    } else {            ;#{{{4}}}
        if !$didsave1 {
            set cmd_input1 $buf_in1
            set buf_in1 ""
            set didsave1 1
        }
        append buf_out1 $user_keystroke
        if $parallel==2 {
            uplevel {set currenthost $session2host($interact_out(spawn_id))}
            myputs "input received from $currenthost1, hold it" 2
            uplevel {set process_input $interact_out(spawn_id)}
            set does_holdsession1 1
            send_user "==from $currenthost1:==\n"
            send_user -- $user_keystroke
            return
        } else {
            send_user -- $user_keystroke
        }
    }
}
proc interact_d {} {    ;#{{{3}}}
    global global_data; eval $global_data
    set debug [expr !$debug]
    puts "\ndebug $debug"
    set options(debug) $debug
    set options_inline(debug) $debug
}
proc interact_f {} {    ;#{{{3}}}
    global global_data; eval $global_data
    global host2session login_index
    upvar download_folder download_folder
    send_user "ile get/put (g,p,? for more): "
    expect_user {
        g {get_filename "get"}
        p {get_filename "put"}
        c chdir
        v verbose
        "\\?" {
            send_user "?\n"
            send_user "g  get file from remote system\n"
            send_user "p  put file to remote system\n"
            send_user "c  change/show directory on local system\n"
            send_user "!  send ! to remote system\n"
            send_user "?  this list\n"
            send_user "v  verbose mode toggle (currently [verbose_status])\n"
            send_user "^Z suspend current session\n"
        }
        "[CONST CTRL_Z]" {
            mycatch "stty -raw echo"
            exec kill -STOP [pid]
            stty raw -echo
        }
        -re . {send_user "<<<CRTC:unknown command\n"}
    }
    send_user "<<<CRTC:resuming session of $login_index...\n"
}
proc get_filename {getput} {  ;#{{{4}}}
    global host2session debug login_index env
    upvar download_folder download_folder
    set timeout 1800
    send_user "\n<<<CRTC:choose a local file folder as \"$download_folder\",\
        yes/no/quit?\[y\]"
    expect_user {
        -re "y|\r" {
            send_user "\n"
        }
        "q" {
            return
        }
        "n" {
            if [catch "spawn -noecho $env(SHELL)" reason] {
                send_user "failed to spawn program: $reason\n"
                exit 1
            }
            puts ""
            puts "<<<CRTC:navigate to the local folder where you want to"
            puts "<<<     save the file or pull the file from, and press"
            puts "<<<     \\\\ to record the name.."
            interact {\\} {
                send "pwd\r"
                expect -re "\r\n(\[^\n]+)\r\n" {
                    set download_folder $expect_out(1,string)
                }
                send_user "\n<<<CRTC:local folder selected as:\"$download_folder\"\n"
                return
            }
            close;wait
        }
        -re "." {
            puts "<<<CRTC:invalid input! press one of these:\[ynq<ENTER>\]"
            exp_continue
        }
    }
    set oldmod [mystty -info]
    mycatch "stty -raw echo"
    if {$getput=="get"} {
        send_user "<<<CRTC:provide a remote file to download, and an (optional)\n"
        send_user "        local file name to save as: (seperated by spaces)\n"
    } else {
        send_user "<<<CRTC:provide a local file to upload, and an (optional)\n"
        send_user "        remote file name to save as: (seperated by spaces)\n"
    }
    expect_user {
        -re "(\[^ ]+) +(\[^ ]+)\n" {
            set file_list [glob -nocomplain $expect_out(1,string)]
            if {$getput=="get"} {
                set remote_file $expect_out(1,string)
                set local_file "$download_folder/$expect_out(2,string)"
                send_user "downloading (remote) $remote_file to\
                    (local) $local_file\n"
                if [get_file $remote_file $local_file] {
                    send_user "sth gone wrong, input file names again!"
                    exp_continue
                }
            } else {
                set local_file "$download_folder/$expect_out(1,string)"
                set remote_file "$expect_out(2,string)"
                send_user "<<<CRTC:uploading (local) $local_file to\
                    (remote) $remote_file\n"
                if [put_file $local_file $remote_file] {
                    send_user "sth gone wrong, input file names again!"
                    exp_continue
                }
            }
        } -re "(\[^ ]+)\n" {
            set file_list [glob -nocomplain $expect_out(1,string)]
            set remote_file $expect_out(1,string)
            set local_file "$download_folder/$expect_out(1,string)"
            if {$getput=="get"} {
                send_user "<<<CRTC:downloading (remote) $remote_file to\
                    (local) $local_file\n"
                if [get_file $remote_file $local_file] {
                    send_user "sth gone wrong, input file names again!"
                    exp_continue
                }
            } else {
                send_user "<<<CRTC:uploading (local) $local_file to\
                    (remote) $remote_file\n"
                if [put_file $local_file $remote_file] {
                    send_user "sth gone wrong, input file names again!"
                    exp_continue
                }
            }
        } -re "\n" {
            if {$getput=="get"} {
                send_user "<<<CRTC:eh?\n"
            } else {
            }
        }
    }
    eval stty $oldmod
}
proc get_file {infile outfile} {        ;#{{{4}}}
    global pattern_common_prompt login_index host2session
    global user_spawn_id
    set spawn_id $host2session($login_index)
    log_user 0
    set out [myopen $outfile w]
    if {$out == 0} {
        return 1
    }
    send_user "downloading\n\r"
    send "cat $infile\r"
    expect {
        -re "^(\[^\n]*)\r\n" {
            myputs "\ndiscard cmd line -$expect_out(1,string)-\r"
            expect {
                -re "^(\[^\n]*)\r\n" {
                    switch -regexp -matchvar match -- $expect_out(1,string) {
                        "No such file"      {return 1}
                        default             {
                            if {$out != 0} { puts $out $expect_out(1,string) }
                            myputs "get 1st line -$expect_out(1,string)-"
                        }
                    }
                } 
                timeout {myputs "timeout @ 1st line"}
            }
        }
        timeout {myputs "timeout @ cmd line"}
    }
    set timeout 5
    set i 0;set j 0
    expect {
        -i $user_spawn_id -re ".+" { }
        -i $spawn_id
            -re "^(\[^\n]*)\r\n" {
                if {$out != 0} {puts $out $expect_out(1,string)}
                myputs "get a new line -$expect_out(1,string)-"
                incr i
                if {[expr $i / 100] > $j} {
                    incr j
                    send_user "."
                }
                exp_continue
            } 
            -re "(^\[^\n]*)\r\n\[^\n]*$pattern_common_prompt" {
                myputs "get the last line -$expect_out(1,string)-" 0
                myputs "pattern_common_prompt is $pattern_common_prompt" 0
                if {$out != 0} { puts $out "$expect_out(1,string)" }
                send_user "."
                puts -nonewline "\r\nfile $outfile ([expr $i+2] lines) is saved!\n\r"
                close $out
            }
            timeout {
                puts "timeout(most probably transfer is done)!"
                close $out
            }
    }
    exp_internal 0
    send_user "\n"		;# after last "."
    log_user 1
    return 0
}
proc put_file {infile outfile} {        ;#{{{4}}}
    global pattern_common_prompt login_index host2session
    set spawn_id $host2session($login_index)
    log_user 0
    send_user "uploading\n"
    send "cat > $outfile\r"
    if [catch {open $infile r} fp] {
        return 1
    }
    set i 0;set j 0
    while {1} {
        if {-1 == [gets $fp buf]} {
            break
        }
	incr i
	if {[expr $i / 100] > $j} {
	    incr j
	    send_user "."
	}
        send -- "$buf\r"
    }
    send_user "\n"			;# after last "."
    send "\004"				;# eof
    close $fp
    expect -re "$pattern_common_prompt"
    log_user 1
    return 0
}
proc chdir {} {         ;#{{{4}}}
    mycatch "stty -raw echo"
    send_user "c\n"
    send_user "current directory is [pwd], new directory: "
    expect_user -re "(.*)\n" {
        cd $expect_out(1,string)
    }
    mycatch "stty raw -echo"
}
proc interact_H {} {    ;#{{{3}}}
    global global_data; eval $global_data
    set hideinfo [expr !$hideinfo]
    puts "\nhideinfo $hideinfo"
    set options(hideinfo) $hideinfo
    set options_inline(hideinfo) $hideinfo
}
proc interact_o {} {    ;#{{{3}}}
    global global_data; eval $global_data
    set login_only [expr !$login_only]
    puts "\nlogin_only $login_only"
    set options(login_only) $login_only
    set options_inline(login_only) $login_only
}
proc interact_p {} {    ;#{{{3}}}
    global global_data; eval $global_data
    switch -exact -- $persistent {
        0 {
            set persistent 1
        } 1 {
            set persistent 2
        } 2 {
            set persistent 3
        } default {
            set persistent 0
        }
    }
    puts "\npersistent $persistent"
    set options(persistent) $persistent
    set options_inline(persistent) $persistent
}
proc interact_q {} {    ;#{{{3}}}
    global global_data; eval $global_data
    set nointeract [expr !$nointeract]
    puts "\nnointeract $nointeract"
    set options(nointeract) $nointeract
    set options_inline(nointeract) $nointeract
}
proc interact_N {} {    ;#{{{3}}}
    global global_data; eval $global_data
    upvar simple_interact simple_interact
    switch -exact -- $features {
        0       {
            set features 1
            set enable_user_patterns 3
            set simple_interact 0
            myputs3 "user pattern monitoring disabled\n"
        } 1       {
            set features 2
            set enable_user_patterns 3
            set simple_interact 0
            myputs3 "full feature interact\n"
        } 2 {
            set features 3
            set enable_user_patterns 3
            set simple_interact 0
            myputs3 "full feature interact\n"
        } 3     -
        default {
            set features 0
            set simple_interact 1
            myputs3 "simple (no feature) interact\n"
        } 
    }
    puts "features:$features enable_user_patterns:$enable_user_patterns"
    set options(features) $features
    set options_inline(features) $features
    set options(enable_user_patterns) $enable_user_patterns
    set options_inline(enable_user_patterns) $enable_user_patterns
}
set interact_v {    ;#{{{3}}}
    switch -exact -- $verbose {
        0       {
            set verbose 1
        } 1       {
            set verbose 0
        } 
    }
    puts "\nverbose:$verbose"
    set options(verbose) $verbose
    set options_inline(verbose) $verbose
}
proc interact_P {} {    ;#{{{3}}}
    global global_data; eval $global_data
    if {$parallel==1} {
        set parallel 2
    } elseif {$parallel==2} {
        set parallel 0
    } else {
        set parallel 1
    }
    puts "\nparallel $parallel"
    set options(parallel) $parallel
    set options_inline(parallel) $parallel
    return
}
proc interact_A {} {    ;#{{{3}}}
    while 1 {
        puts "who do you want to consult with?";flush stdout;
        set expertname [gets stdin]
        mycatch "stty raw"
        puts "$expertname, you sure\[(y)es/(n)o\]?\[y\]";
        flush stdout;
        expect_user {
            "y" {
                myputs "current session looks $process"
                spawn kibitz -noproc -silent temptemp
                myputs "new kibitz session looks $spawn_id"
                interact -u $process -o "stop" {
                    close;wait;return
                }
                break
            }
            "\r" {
                break
            }
            "q" {
                puts "\n";break
            }
            "?" {
                puts "\n"
            }
        }
    }
}
proc interact_k {} {    ;#{{{3}}}
    global login_index env debug kibitz_shell_prompt
    global kibitz_list kibitz_user
    global kibitz_spawn_id2user user2kibitz_spawn_id
    global shell_list kibitz_kill_onfail process_input process_output
    global kibitz_list_ori kibitz_list inkibitz env
    if $inkibitz {
        send -i kibitz_list "please hold on while $env(USER) is trying to\
        invite more users...\r\n"
    }
    set oldmode [mystty -info]
    myputs "original stty mode is $oldmode"
    mystty raw echo
    set timeout 30
    send_user "
    - invite a user to share your current terminal session?\[lrq<ENTER>\]
    (l)ocal user: press \"l\" or just hit enter
       - send invitation to a user in local server (where crtc script was started) 
    (r)emote user:press \"r\"
       - spawn a new shell and from which you can login to remote host and then send
       invitation to a user in that host
    (q)uit: press \"q\"
       - quit and return back to current session
    (i)nfo: display current kibitz status\n"
    expect_user {
        -re "l|\r"      invitelocal
        r               inviteremote
        q               {}
        i               {
            if $inkibitz {
                send_user "in kibitz!"
            } else {
                send_user "not in kibitz!"
            }
            send_user "shell_list: $shell_list: kibitz_list: $kibitz_list"
            send_user "kibitz_list_ori: $kibitz_list_ori:current sid:$spawn_id"
        }
        "\\?" {
            send_user "?\n"
            send_user "l  invite a local user\n"
            send_user "r  invite any user\n"
        }
        -re . {send_user "<<<CRTC:unknown command\n"}
        timeout {
            send_user "no valid user selection in ${timeout}s..."
        }
    }
    send_user "\n"
}
proc inviteremote {} {        ;#{{{4}}}
    global login_index env debug kibitz_shell_prompt
    global kibitz_list kibitz_user
    global kibitz_spawn_id2user user2kibitz_spawn_id
    global shell_list kibitz_kill_onfail process_input process_output
    global kibitz_list_ori kibitz_list inkibitz kibitz_user_list 
    global sid2user sid2typing user_spawn_id host2session session2host
    set kibitz_user ""
    set tty1 ""
    if {[llength $shell_list] == 1} {
        puts "no free shell available, will spawn one..."
        interact_y
        return
    }
    if [in $process_input [lrange $shell_list 1 end]] {
        set spawn_id $process_input
    } else {
        puts "you are still in the session to be shared, to share this\
            session, you need to switch to a shell.\n\
            type \\l to list available shells; \\NUMBER to select one"
        return
    }
    send_user "who to invite on this server?\n"
    catch {set oldmode [stty -raw echo]}
    set timeout 120
    expect_user {
        -re "(\[^ ]+) +(\[^ ]+)\n" {
            set kibitz_user $expect_out(1,string)
            set tty1  "-tty $expect_out(2,string)"
            send_user "will invite $kibitz_user on $tty1 ...\n"
        }
        -re "(\[^ ]+)\n" {
            set kibitz_user $expect_out(1,string)
            set tty1 ""
            send_user "will invite $kibitz_user ...\n"
        }
        -re "\n" {
            send_user "<<<CRTC:eh?\n"
            return
        }
        timeout {
            send_user "you didn't type any user name in $timeout second...\n"
            return
        }
    }
    send "stty echo\r"
    send "\r"
    expect -re "\r\n(\[^\r]+)$" {
        set kibitz_shell_prompt $expect_out(1,string)
        myputs "original shell prompt before kibitz looks -$kibitz_shell_prompt-"
    }
    send "stty -echo\r"
    send "kibitz -noproc $tty1 $kibitz_user\r"
    set timeout 40
    expect {
        -i $spawn_id
            "is not logged in" {
                send_user "$kibitz_user is not logged in yet, check and\
                    try again later!"
                set inkibitz 0
            }
            -re "Escape sequence is \\^\\\]" {
                send_user "kibitz succeeded!\n"
                set process_input [arrayvalue host2session]
                set process_output [arrayvalue host2session]
                lappend kibitz_list_ori $spawn_id
                set kibitz_list $kibitz_list_ori
                set sid2user($spawn_id) $kibitz_user
                set sid2typing($spawn_id) 0
                ldelete shell_list $spawn_id
                myputs "shell_list: $shell_list: kibitz_list: $kibitz_list" 0
                myputs "kibitz_list_ori: $kibitz_list_ori:current sid:$process_input" 0
                set inkibitz 1
                send -i $kibitz_list "session $login_index is being shared between\
                    \[$kibitz_user_list\] now...\n"
                send -i $kibitz_list "to exit, type ctrl+\], and then \"exit\""
            }
            timeout {
                set inkibitz 0
                send_user "kibitz not succeed in ${timeout}s! you can try\
                    again later..\n"
                exp_send "[CONST CTRL_C]\r"
            }
        -i $user_spawn_id
            -re ".+" {
                send_user "invitation cancelled!\n"
            }
    }
}
proc invitelocal {} {           ;#{{{4}}}
    global login_index kibitz_user
    global kibitz_spawn_id2user user2kibitz_spawn_id
    global kibitz_list kibitz_list_ori
    global shell_list inkibitz kibitz_user_list 
    global sid2user sid2typing
    set kibitz_user ""
    set tty1 ""
    send_user "\nwho are you going to invite?\n"
    set oldmode [mystty -info]
    catch {mystty -raw echo}
    set timeout 120
    expect_user {
        -re "(\[^ ]+) +(\[^ ]+)\n" {
            set kibitz_user $expect_out(1,string)
            set tty1  "-tty $expect_out(2,string)"
            send_user "will invite $kibitz_user on $tty1 ...\n"
        }
        -re "(\[^ ]+)\n" {
            set kibitz_user $expect_out(1,string)
            send_user "will invite $kibitz_user ...\n"
        }
        -re "\n" {
            send_user "<<<CRTC:eh?\n"
            return
        }
        timeout {
            send_user "you didn't type any user name in $timeout second...\n"
            return
        }
    }
    if ![string equal $tty1 ""] {
        eval spawn "kibitz -noproc $tty1 $kibitz_user"
    } else {
        eval spawn kibitz -noproc $kibitz_user
    }
    set timeout 30
    expect {
        "is not logged in" {
            send_user "$kibitz_user is not logged in yet, check and\
                try again later!"
            set inkibitz 0
        }
        -re "Escape sequence is \\^\\\]" {
            send_user "kibitz succeeded!\n"
            lappend kibitz_list_ori $spawn_id
            set kibitz_list $kibitz_list_ori
            lappend kibitz_user_list $kibitz_user
            set sid2user($spawn_id) $kibitz_user
            set sid2typing($spawn_id) 0
            send -i $kibitz_list "session $login_index is being shared between\
                $kibitz_user_list now...\r\n"
            myputs "shell_list: $shell_list: kibitz_list: $kibitz_list"
            myputs "kibitz_list_ori: $kibitz_list_ori"
            set inkibitz 1
        }
        eof {
            send_user "got eof immediately!"
            set inkibitz 0
        }
        timeout {
            send_user "user $kibitz_user didn't ack in ${timeout}s...\n"
            set inkibitz 1
        }
    }
}
proc interact_y {} {    ;#{{{4}}}
    global env shell_list 
    global process_input process_output
    set shell_pid [spawn -noecho $env(SHELL)]
    send_user "spawned new shell\[$shell_pid\]...\n"
    send_user "press \\l to list, \\NUMBER to switch into a session\n"
    lappend shell_list $spawn_id
    set process_input $spawn_id
    set process_output $spawn_id
}
set interact_n {     ;#{{{4}}}
    global env shell_list 
    global process_input process_output
    set shell_pid [spawn -noecho $env(SHELL)]
    send_user "spawned new shell\[$shell_pid\]...\n"
    send_user "press \\l to list, \\NUMBER to switch into a session\n"
    lappend shell_list $spawn_id
    set process_input $spawn_id
    set process_output $spawn_id
    spawn_login "$router.clone"
}
set interact_timeout {      
    if {$anti_idle_timeout_user_input > $anti_idle_timeout_proc_input} {
        set anti_idle_timeout $anti_idle_timeout_proc_input
        set user_timeout 0
        myputs "process timeout after ${anti_idle_timeout}s "
    } elseif {$anti_idle_timeout_user_input < $anti_idle_timeout_proc_input} {
        set anti_idle_timeout $anti_idle_timeout_user_input
        set user_timeout 1
        myputs "user timeout after ${anti_idle_timeout}s "
    } else {
        set anti_idle_timeout $anti_idle_timeout_user_input
        set user_timeout 1
        myputs "user and proc both timeout after ${anti_idle_timeout}s "
    }
    myputs "will send -$anti_idle_string- as KA to $session2host($process)"
    log_user 0
    foreach onehost $hostlist_full {
        set process $host2session($onehost)
        if [string equal $anti_idle_string "null"] {
            send -i $process -null
        } else {
            send -i $process "$anti_idle_string"
        }
    }
    log_user 1
    if {$enable_user_patterns != $enable_user_patterns_ori} {
        if !$timedout {
            if $user_timeout {
                myputs2 "\r\nuser timeout after ${anti_idle_timeout}s,"
            } else {
                myputs2 "\r\nprocess timeout after ${anti_idle_timeout}s,"
            }
            set timedout 1
        }
    }
    if {($features_ori == 2) && ($features == 1 )} {
        myputs "original feature was $features_ori and was \
            changed to $features, "
        myputs "set to 3 on timed out..."
        myputs2 "\r\nuser timeout after ${anti_idle_timeout}s,"
        myputs2 "\r\nswitched back to original (monitoring) mode\n"
        set features 3
        set enable_user_patterns $enable_user_patterns_ori
        return
    }
    if !$argc {
        reload_data "LOCALHOST"
        do_pag LOCALHOST scheduled_event cmd_output_array_scheduled_event 
    }
}
proc interact_D {} {    ;#{{{3}}}
    uplevel {set cmd_output $buf_out}
    uplevel {set buf_out ""}
    uplevel {send_user "\ncmd input:\[$cmd_input\]!\n"}
    uplevel {send_user "\ncmd output:\[$cmd_output\]!\n"}
}
proc interact_E {} {    ;#{{{3}}}
    uplevel {set user $env(USER)}
    uplevel {set emailto $user@$domainname}
    uplevel {sendanemail $log_fullname $emailto}
    uplevel {myputs2 "log file $log_fullname was sent to $user\n"}
}
proc interact_O {} {    ;#{{{3}}}
    global config_file hostlist_full
    if {($config_file != "NONE") && [file exists $config_file]} {
        send_user "reload the configs..."
        myputs "sourcing config file $config_file"
        foreach host $hostlist_full {reload_data $host}
        send_user "\r\nconfig file reload done.."
    } else {
        puts "no config file (or \"NONE\" was used) to load"
    }
}
proc interact_R {} {    ;#{{{3}}}
    global sigquit myinteract_depth
    if $sigquit {
        puts "there is no unfinished automation task!"
    } else {
        if {$myinteract_depth>1} {
            myputs "interact depth $myinteract_depth, \
                return to upper level"
            incr myinteract_depth -1
            puts "\nresuming previous automations ..."
            return 1
        } else {
            puts "\nthere is no automation to continue..."
            myputs "interact depth 0, won't return"
        }
    }
}
proc interact_s {} {    ;#{{{3}}}
    global global_data; eval $global_data
    incr myinteract_depth -1
    puts "top unfinished automations!"
    if {$myinteract_depth>1} {
        set automation_non_complete_msg "\nyou have \
            unfinished automations (stack $myinteract_depth)!\n\
            press !R to continue, ^\\ or !s to stop, !Q to quit"
    } else {
        set automation_non_complete_msg ""
    }
    set options(automation_non_complete_msg) \
        $automation_non_complete_msg
    set options_inline(automation_non_complete_msg) \
        $automation_non_complete_msg
}
proc interact_plus {} {         ;#{{{3}}}
    global global_data; eval $global_data
    incr interval_cmds 1
    send_user "                                         \r"
    send_user "cmds interval increased to $interval_cmds\r"
    set options(interval_cmds) $interval_cmds
    set options_inline(interval_cmds) $interval_cmds
    return
}
proc interact_minus {} {        ;#{{{3}}}
    global global_data; eval $global_data
    incr interval_cmds -1
    send_user "cmds interval increased to $interval_cmds\r"
    send_user "                                         \r"
    set options(interval_cmds) $interval_cmds
    set options_inline(interval_cmds) $interval_cmds
    return
}
proc send_routers { router_cmds_array } { ;#{{{2}}}
    global debug 
    global cmd_output_array_$router_cmds_array
    upvar $router_cmds_array p_router_cmds_array
    if [array exists p_router_cmds_array] {
        if $debug {myputs "will execute the router-cmds-array:\"$router_cmds_array\" \
            for routers:[array names p_router_cmds_array]"
        }
        if $debug {send_log "will execute the router-cmds-array:\"$router_cmds_array\" \
            for routers:[array names p_router_cmds_array]...\n"
        }
        foreach router [array names p_router_cmds_array] {
            set cmd_list $p_router_cmds_array($router)
            set pa_pair 0
            foreach cmd $cmd_list { ;#if any cmd contains special CH, 
                if [regexp "#|>|%" $cmd] {set pa_pair 1} 
            }
            if $pa_pair { ;#use diff method to handle 
                if $debug {
                    myputs "cmds list contains prompt-looking strings, 
                        go pattern-action mode!"
                }
                myexpect $router ".*" "" 0
                do_patterns_actions $router p_router_cmds_array 
            } else {   ;#or just pure data:  "show1 " "show2 "
                if $debug {
                    myputs "executing \"$router_cmds_array\" for router:\"$router\""
                }
                send_cmds $router p_router_cmds_array cmd_output_array_\
                    $router_cmds_array
            }
        }
    } else {
        if $debug {myputs "array \"$router_cmds_array\" not configured, skipping"}
    }
}
proc switchover {router {hold_interval 300} {su_password Juniper}} { ;#{{{2}}}
    global debug session2host host2session spawn_id 
    global pattern_gres_not_ready pattern_gres_success
    set process $host2session($router)
    myputs "send an initial cr"
    exp_send -i $process "\r"
    myexpect $router "> $" "request chassis routing-engine master switch" 60 0 0
    set timeout 60
    expect {
        -i $process -re $pattern_gres_success {
            myputs "\[great! will exit current process...\]"
            return "RETURN_GRES_SUCCESS"
        }
        -i $process "\\\[yes,no\\\] (no)" { 
            send -i $process "yes\r"
            exp_continue
        }
        -i $process -re $pattern_gres_not_ready {
            set switchover_countdown 240
            regexp {.*try after (.*) secs.*} $expect_out(buffer) -> switchover_countdown
            puts "\[crtc:oops! sorry...will redo \
                [expr $switchover_countdown + 1]s later then...\]"
            if {$switchover_countdown <= $hold_interval} {
                switchover_countdown $switchover_countdown
                switchover $router $hold_interval $su_password
                return "RETURN_GRES_SUCCESS"
            } else {
                if $debug {
                    myputs "\[crtc:required switchover interval time          \
                    left(${hold_interval}s) is less than CLI protection         \
                    interval(${switchover_countdown}s left), will force rpd     \
                    restart after $hold_interval seconds...\]"}
                mysleep $hold_interval
                restart_rpd $router $su_password
                return "RETURN_GRES_FORCE_RPD"
            }
        }
        -i $process -re "closed by foreign host" {
            myputs "no problem, will re-login again!"
            return "RETURN_GRES_SESSION_CLOSED"
        }
        -i $process -re "Failed" {
            myputs "GRES failed!"; exit 4
            return "RETURN_GRES_FAILED"
        }
        timeout {
            puts "timeout after ${timeout}s"
            myputs "something unexpected happened, exit"
            return "RETURN_GRES_TIMEOUT"
        }
    }
}
proc switchover_countdown {switchover_countdown} { ;#{{{2}}}
    global debug
    incr switchover_countdown 1
    puts "\[crtc:will count $switchover_countdown seconds and retry...\]"
    if {$switchover_countdown >= 30} {
        incr switchover_countdown -30
        mysleep $switchover_countdown
        myputs "\[crtc:just 30 more seconds to wait...\]"
        mysleep 30
    } else {
        mysleep $switchover_countdown
    }
}
proc restart_rpd {router su_password} { ;#{{{2}}}
    global debug session2host host2session
    set process $host2session($router)
    if $debug {myputs "start restarting rpd now!"}
    exp_send -i $process "\r"
    exp_send -i $process "start shell\r"
    myexpect $router "% $"        "su"                  0
    myexpect $router "Password:$" "$su_password"        0
    myexpect $router "% $"        "uptime\r"            0
    myexpect $router "% $"        "ps aux | grep rpd\r" 0
    expect -i $router -re "root\\s+(\\d+)\\s+.*sbin/rpd.*$" {
        set rpd_pid $expect_out(1,string)
        send -i $process "pwd\r"
        exp_send -i $process "kill -11 $rpd_pid\r"
    }
    expect -i $process -re "% $"
}
proc restart_process {router process su_password {jnpr123}} { ;#{{{2}}}
    global debug session2host host2session
    global pa_pair
    set process $host2session($router)
    if $debug {myputs "start restarting $process now!"}
    myexpect $router "(%|#) $" "ps aux | grep $process\r" $pa_pair
    expect -i $router -re "root\\s+(\\d+)\\s+.*$process.*$" {
        set pid $expect_out(1,string)
        exp_send -i $process "kill -11 $pid\r"
    }
}
proc get_output {cmd_output_array router cmd_id} { ;#{{{2}}}
    upvar $cmd_output_array p_cmd_output_array
    return "[lindex [array get p_cmd_output_array $router,$cmd_id,*] 1]"
}
proc get_index {cmd_output_array router cmd_id} { ;#{{{2}}}
    global debug
    upvar $cmd_output_array p_cmd_output_array
    myputs "get_index:$cmd_output_array looks:\n[array get p_cmd_output_array]\n" 3
    myputs "use -$router- and -$cmd_id- to get a key\n" 3
    set key [lindex [array get p_cmd_output_array $router,$cmd_id*] 0]
    myputs "get_index:get a key as $key\n" 3
    myputs "get_index:get a key as $key\n" 3
    set pattern "$router,$cmd_id,(.*),(\\d+)$"
    if [regexp $pattern $key -> cmd time] {
        return [list $cmd $time]
    } else {
        if $debug {
            myputs "can't find record of #$cmd_id cmd from router -$router-!"
            myputs "cmd_output_array $cmd_output_array looks"
            parray p_cmd_output_array
            myputs "key is $key"
        }
        return 0
    }
}
proc persist_login {login_script router args} { ;#{{{2}}}
    global debug session2host host2session 
    if {$debug>1} {myputs "$login_script $router $args"}
    if {$args!=""} {                            ;#there are extra options_cli
            set username [lindex $args 0]       ;#take them as user/pass
            set password [lindex $args 1]
            spawn -noecho $login_script $router $username $password
    } else {                                    ;#otherwise use default(lab/hernon1)
        spawn -noecho $login_script $router
    }
    if {$debug>1} {myputs "spawn_id of persist_login is $spawn_id"}
    expect {
        -i $spawn_id -re "> $" {
            if {$debug>1} {
                myputs "hold 3s before proceed (wait until output all dumped)"
            }
            set timeout 3
            expect -i "$spawn_id" -re ".+" exp_continue
            set session2host($spawn_id) $router
            set host2session($router) $spawn_id
            return $spawn_id
        }
        -i $spawn_id "Unable to connect to remote host: Connection timed out" {
            persist_login $login_script $router
        }
        -i $spawn_id "Connection closed by foreign host" {
            persist_login $login_script $router
        }
        -i $spawn_id default         {
            myputs "get eof/timeout, retry"
            mysleep 2
            persist_login $login_script $router
        }
    }
}
proc check_flag {cmds {flag_check_method 1}} { ;#{{{2}}}
    myputs "==>entering check_flag"
    global cmd_output_array_$cmds cmd_output_array_${cmds}_prev
    global cmd_output_array_pre_$cmds cmd_output_array_post_$cmds
    global rule_calc rule_msg debug code_init_template
    global data dataformat datafile cmd_id all_met hostlist_full
    upvar $cmds p_cmds
    foreach router $hostlist_full { ;#{{{3}}}
        set i 1
        foreach cmd $p_cmds($router) {
            set cmd_id $i
            set cmd_1 [lindex [get_index cmd_output_array_$cmds $router $cmd_id] 0]
            set time_now [lindex [get_index cmd_output_array_$cmds $router $cmd_id] 1]
            myputs "use cmd# $i of cmd:\n-$cmd-\n\
                from cmds array $cmds (router $router), \
                to retrieve cmd:\n-$cmd_1-\nand time info:$time_now \
                from cmd_output_array:cmd_output_array_$cmds \n" 2
            set handler ${cmds}_${router}_$cmd_id
            if {[info procs $handler]!=""} {    
                if $debug {send_log "call handler $handler to process this \
                    cmd for router $router\n"}
                myputs "handler $handler defined"
                myputs "call handler \"$handler\" to parse this cmd for router
                    \"$router\""
                set result_flag($router,$i) [$handler $router $cmd]
                if [info exists dataformat] {
                    myputs "$router,$time_now,[eval format $dataformat $data]" $datafile
                }
            } else { 
                myputs "handler proc \"$handler\" not defined in the config file!"
                global code_${router}_$cmd_id
                if [info exist code_${router}_$cmd_id] {
                    myputs "but,cmds code \"code_${router}_$cmd_id\" \
                        defined, so composing a handler proc \"$handler\" \
                        based on that.."
                    regsub -all {cmds1} $code_init_template "$cmds" init_$cmds
                    set handler_proc    "proc ${cmds}_${router}_$cmd_id \{router cmd \{var1 400\}\} \{\n"
                    append handler_proc "global init_$cmds\n"
                    append handler_proc "global global_data;eval \$global_data\n"
                    append handler_proc "global data dataformat datafile\n"
                    append handler_proc "global regex vars vars_prev options_cli\n"
                    append handler_proc "global issue_info regex_info cmd_id\n"
                    append handler_proc "global regex4onecmd issue4onecmd\n"
                    append handler_proc "[set init_$cmds]\n"
                    append handler_proc "####global var code_${router}_$cmd_id:start\n"
                    append handler_proc "[set code_${router}_$cmd_id]\n"
                    append handler_proc "\n####global var code_${router}_$cmd_id:end\n"
                    append handler_proc "myputs \"issue not seen from -\$router:\$cmd-!\"\n"
                    append handler_proc "return 0\n"
                    append handler_proc "\}\n"
                    if {$debug>=3} {myputs "handler_proc now looks:\n$handler_proc"}
                    eval $handler_proc   ;#declare/define the proc, not executed yet!
                    myputs "call handler==>$handler to parse this cmd for\
                        router $router\n"
                    set result_flag($router,$i) [$handler $router $cmd]
                    if [info exists dataformat] {
                        myputs "$router,$time_now,[eval format $dataformat $data]" $datafile
                    }
                } else {
                    myputs "no parser \"$handler\" defined for router \"$router\"\n"
                    myputs "${cmds}_code_${router}_$cmd_id not defined in the\
                        config file, won't define the handler proc dynamically" 3
                }
            }
            incr i 1                            
        }
    }
    myputs "result_flag array looks [array get result_flag]\n" 3
    array unset cmd_output_array_${cmds}_prev
    array set cmd_output_array_${cmds}_prev [array get cmd_output_array_$cmds]
    if $debug {
        if [array exists result_flag] {
            puts "after fresh result_flag now looks:"
            parray result_flag
        } else {
            puts "after fresh result_flag array does not exist!"
        }
    }
    if {[info exists rule_calc]} {
        if {[info exists rule_calc]} {myputs "\nissue definition:$rule_msg"}
        foreach router [array names p_cmds] {
            if { [eval $rule_calc] } {
                myputs "  found issue on router $router:$rule_msg"
                send_log "\n  found issue on router $router:$rule_msg\n" 
                myputs "  result flags looks like:\n[array get result_flag $router*]\n"
                return 1
            } else {
                myputs "  no issue for router $router:$rule_msg"
            }
        }
    } else {    ;#if not defined in config file, use default rule: 
        foreach router [array names p_cmds] {
            set flag_list [array get result_flag $router*]
            set cmd_num [llength $p_cmds($router)]              ;#num of cmds for a router
            for {set i 1} {$i<=$cmd_num} {incr i 1} {           ;#any flag means a hit
                myputs "check result_flag($router,$i)" 2
                if {[info exists result_flag($router,$i)]} {    ;#but only if flag exist
                    myputs "$result_flag($router,$i)\n" 2
                    if $all_met {
                        if !$result_flag($router,$i) {
                            return 0
                        }
                    } else {
                        if {$result_flag($router,$i)} {
                            return 1
                        }
                    }
                } else {
                    myputs "result_flag($router,$i) not exist\n" 2
                }
            }
        }
    } 
    if $all_met { return 1 } else { return 0}
}
proc persist_login1 {login_script router args} { ;#{{{2}}}
    global debug session2host host2session  sigquit user_spawn_id
    global persistent
    if {[llength $args]} {
        set port [lindex $args 0]
        spawn $login_script $router $args
    } else {
        spawn $login_script $router
    }
    if $debug {myputs "spawn_id in att script is $spawn_id"}
    mycatch "stty raw"
    send_user "\n<<<CRTC:press \"d\" to exit while awaiting for session to be\
        connected\n"
    expect {
        -i $user_spawn_id "d" {
            exit
        }
        -i $spawn_id -re "Escape character is" {
            myputs "the router is alive"
            set session2host($spawn_id) $router
            set host2session($router) $spawn_id
            return $spawn_id
        }
        -i $spawn_id -nocase "Connection timed out" {
            myputs "connection explicit timeout, try again!"
            catch {close $spawn_id;wait $spawn_id}
            if {[llength $args]} {
                set port [lindex $args 0]
                persist_login1 $login_script $router $args
            } else {
                persist_login1 $login_script $router
            }
        }
        -i $spawn_id default         {
            myputs "get eof/implicit timeout, try again!"
            mysleep 2
            catch {close $spawn_id;wait $spawn_id}
            if $sigquit {
                return 0
            } else {
                if {$persistent==1 || $persistent==3} {
                    if {[llength $args]} {
                        set port [lindex $args 0]
                        persist_login1 $login_script $router $args
                    } else {
                        persist_login1 $login_script $router
                    }
                } else {
                    return 0
                }
            }
        }
    }
}
proc do_pags {host pags {pattern_timeout 10} {pa_intv 0} {pa_pair 1}} { ;#{{{2}}}
    global debug cmds1 cmds2 cmds3
    upvar $pags p_pags
    if $debug {myputs "get pattern action groups from :-$p_pags($host)-"}
    foreach pa_group $p_pags($host) {
        myputs "parsing $pa_group.."
	global $pa_group
        if [info exists $pa_group] {
            myputs "$pa_group is nested (defined)"
            set nested 1
        } else {
            myputs "$pa_group is not nested (not defined)"
            set nested 0
        }
        break
    }
    if {!$nested} {       ;#if it's a leaf list, execute the list
	if $debug {myputs "this pa_group $pa_group is end 'leaf' node, will execute it..."}
        do_pag $host p_pags cmd_output_array_pags \
            $pa_intv $pattern_timeout $pa_pair
    } else {            ;#if it contains sub-node, repeat this proc recursively
	if $debug {
            myputs "this pa_group $pa_group is not an end 'leaf' node"
            myputs "it was defined as an array: [subst ${pa_group}($host)]"
            myputs "and it contains: [subst $${pa_group}($host)]"
        }
	foreach pa_group $p_pags($host) {
            eval global $pa_group
            do_pags $host $pa_group $pattern_timeout $pa_intv $pa_pair
        }
    }
}
proc upgrade {rel} {    ;#{{{2}}}
    global debug expect_out spawn_id
    upgrade_pre $spawn_id
    expect -i $spawn_id -re "(\[01])> $" {
        set reA $expect_out(1,string)
        exp_send -i $spawn_id "request routing-engine login other-routing-engine\r"
    }
    expect -i $spawn_id -re "(\[01])> $" {
        set reB $expect_out(1,string)
        if {$reA==$reB} {
            myputs "login the other re failed, exit!";exit
        } else {
            myputs "login the other re succeed, continue!"
            exp_send -i $spawn_id "\r"
        }
        upgrade_re $spawn_id $rel
    }
    expect {
        -i $spawn_id "going down IMMEDIATELY" {exp_continue -continue_timer}
        -i $spawn_id "rlogin: connection closed"  {exp_continue -continue_timer}
        -i $spawn_id -re "(\[01])> $" {
            set reC $expect_out(1,string)
            if {$reA==$reC} {
                myputs "seeing RE$reC , back to master, will upgrade master now"
                exp_send -i $spawn_id "\r"
                upgrade_re $spawn_id $rel
            } else {
                myputs "seeing RE$reC, still not back to master, wait"
                exp_continue -continue_timer
            }
        }
        -i $spawn_id default {
            myputs "some unexpected conditions(still not back to master), exit!"
            exit
        }
    }
    expect -i $spawn_id -re "going down IMMEDIATELY"
}
proc upgrade_re {rel} {         ;#{{{2}}}
    global spawn_id
    set timeout 300
    myexpect $spawn_id "> $"  "set cli screen-width 300"
    myexpect $spawn_id "> $"  "request system software add $rel validate force"
    expect {
        -i $spawn_id "Installation failed" {
            myputs "system software adding failed, exit!"; exit
        }
        -i $spawn_id "Saving state for rollback" {
            myputs "system software adding succeed, continue to reboot!"
            myexpect $spawn_id "re\[01]>"  "request system reboot"
            myexpect $spawn_id "\\\(no\\\) +$" "yes"
        }
        -i $spawn_id "ERROR: Another package installation in progress:" {
            myputs "will retry in 5s"
            mysleep 5
            myexpect $spawn_id "> $"  "request system software add $rel validate force"
            exp_continue
        }
        -i $spawn_id default {
            myputs "unexpected: neither fail nor success"
            myputs "will retry again when timeout"
            exp_continue
        }
    }
    set timeout 60
}
proc arrayvalue {array1} { ;#{{{2}}}
    set list {}
    upvar $array1 array
    foreach name [array names array] {
       lappend list $array($name)
    }
    return $list
}
proc usage {} { ;#{{{2}}}
    global argv0
    puts -nonewline "\nUsage:$argv0 \[OPTIONS\]\r\n"
    puts -nonewline "  OPTIONS:\r\n"
    puts -nonewline "     -G                 :generate a config file template\r\n"
    puts -nonewline "     -h                 :this usage/detail tutorial\r\n"
    puts -nonewline "     -e                 :edit config file\r\n"
    puts -nonewline "     -l                 :list configured hosts info\r\n"
    puts -nonewline "     -v                 :print version/license info\r\n"
    puts -nonewline "     -0/-?/?/--help     :print usage examples\r\n"
    puts -nonewline "     -H                 :print the \"full menu\""
    puts -nonewline "\r\n"
    puts -nonewline "Usage:$argv0 \[OPTIONS\] session\r\n"
    puts -nonewline "  OPTIONS:\r\n"
    puts -nonewline "     -a  :attributes\r\n"
    puts -nonewline "     -A  :set/unset auto-paging (no-more)\r\n"
    puts -nonewline "     -b/B \"show cli\"  :commands before/after loop\r\n"
    puts -nonewline "     -c \"show version | no-more\" :commands (in a loop)\r\n"
    puts -nonewline "     -C <config file|NONE> :read config file\r\n"
    puts -nonewline "     -d  :set/unset debug info\r\n"
    puts -nonewline "     -D  :max_hits: max times issue will be detected\r\n"
    puts -nonewline "     -e \">\" -s \"show version | no-more\" :expect and send\r\n"
    puts -nonewline "     -E \"$\" -S \"telnet alecto..\" :same, but for login\r\n"
    puts -nonewline "     -F showver.log     :cmd_filename\r\n"
    puts -nonewline "     -f router1.log     :router log file name\r\n"
    puts -nonewline "     -g  :gap between each cmd\r\n"
    puts -nonewline "     -h <host1> <host2> .. :login to multiple hosts\r\n"
    puts -nonewline "     -i <SECONDS>       :interval between each iteration of all cmds\r\n"
    puts -nonewline "     -j <NUMBER>        :project\r\n"
    puts -nonewline "     -J  :event script\r\n"
    puts -nonewline "     -k  :send_usage_stats - send usage statistics\r\n"
    puts -nonewline "     -K  :sKip env: env_proof\r\n"
    puts -nonewline "     -l \"abc@xyz.net\" :email address to send log attachment\r\n"
    puts -nonewline "     -L  :log_when      :when will logging start\r\n"
    puts -nonewline "     -m  :monitor mode(keep sending cmds)\r\n"
    puts -nonewline "     -M  :automate local tasks"
    puts -nonewline "     -n <count>         :send command <count> time(s)\r\n"
    puts -nonewline "     -o  :set/unset \"login only\" (ignore all cmds)\r\n"
    puts -nonewline "     -O  :emailbody: email contant\r\n"
    puts -nonewline "     -p  :set/unset \"persist mode\"\r\n"
    puts -nonewline "     -P  :when used with -h,run commands in parallel\r\n"
    puts -nonewline "     -q  :set/unset \"quick mode\" (quit after done)\r\n"
    puts -nonewline "     -Q  :features - amount of \"features\"\r\n"
    puts -nonewline "     -r <SECONDS>       :reconnect interval\r\n"
    puts -nonewline "     -R \"1@packets@\s+(\d+)\s+(\d+) pps@packets@pps\" :regex and vars string\r\n"
    puts -nonewline "     -I \"1@pps == pps_prev\"  :issue definition\r\n"
    puts -nonewline "     -t  :set/unset timestamping all commands\r\n"
    puts -nonewline "     -T  :timestamp all output lines\r\n"
    puts -nonewline "     -u  :redirect_inshell\r\n"
    puts -nonewline "     -U  :print \"login_succeed_signature\" when login succeeded\r\n"
    puts -nonewline "     -H  :set/unset \"hidden mode\" (hide login step details)\r\n"
    puts -nonewline "     -w <SECONDS>       :timeout_login\r\n"
    puts -nonewline "     -W <SECONDS>       :timeout_cmd\r\n"
    puts -nonewline "     -V  :print value matched by the regex from -R\r\n"
    puts -nonewline "     -v  :verbose\r\n\r"
    puts -nonewline "     -x  :all_med - define issue as all cmds met -I criterias\r\n"
    puts -nonewline "     -X  :lock_session, set key_interact to an impossible value\r\n"
    puts -nonewline "     -y  :use barewords instead of \$var for varibles in -I expression\r\n"
    puts -nonewline "     -Y  :commands when match found(Yes) in -R\r\n"
    puts -nonewline "     -N  :commands when match not(No) found in -R\r\n"
    puts -nonewline "     -z  :compress/don't compress log before attach to email\r\n"
    puts -nonewline "     -Z  :no_anti_idle: disable anti_idle_timeout\r\n"
    usage_inline
    puts -nonewline "session management\r\n"
    puts -nonewline "  \i\r\n"
    puts -nonewline "  \N  N refers a session number\r\n"
    puts -nonewline "helps\r\n"
    puts -nonewline "  !?  list all keystoke commands\r\n"
    puts -nonewline "  !h  print usage\r\n"
    puts -nonewline "  !i  print detail tutor docs\r\n"
    puts -nonewline "other commands:\r\n"
    puts -nonewline "  Ctrl-g suspend the script\r\n"
    puts -nonewline "  Ctrl-\(SIGQUIT) to stop the cmds automations\r\n"
    puts -nonewline "  automation control:\r\n"
    puts -nonewline "      q   quit the automation\r\n"
    puts -nonewline "      <SPACE> continue(escape sleeping)\r\n"
    puts -nonewline "      <ENTER> same as <SPACE>\r\n"
    puts -nonewline "      Q   exit the script\r\n"
    puts -nonewline "  SPECIAL CMDS:\r\n"
    puts -nonewline "     GRES               :Junos GRES request\r\n"
    puts -nonewline "     SLEEP <SECONDS>    :sleep some seconds before sending next command\r\n"
    puts -nonewline "     REPEAT M N         :repeat the last M commands N times\r\n"
    puts -nonewline "     UPGRADE /var/tmp/..:upgrade junos release\r\n"
}
proc usage_inline {} {  ;#{{{2}}}
    puts -nonewline "inline commands:\r\n"
    puts -nonewline "  !a  changing attributes on the fly(todo)\r\n"
    puts -nonewline "  !A  toggle auto_paging option\r\n"
    puts -nonewline "  !b  block/close sharing tempararily\r\n"
    puts -nonewline "  !B  block/close sharing permanently(TODO)\r\n"
    puts -nonewline "  !c  specify and repeat a command\r\n"
    puts -nonewline "  !C  editing current config file\r\n"
    puts -nonewline "  !d  toggle debug option\r\n"
    puts -nonewline "  !D  dump (debugging) input/output characters\r\n"
    puts -nonewline "  !e!  start expect-command pair group automation\r\n"
    puts -nonewline "  !e?  same, but asking for array's name\r\n"
    puts -nonewline "  !E  attach log in email and send to user\r\n"
    puts -nonewline "  !f  file download/upload\r\n"
    puts -nonewline "  !F  not in use\r\n"
    puts -nonewline "  !g/G  change timeout (gap) value\r\n"
    puts -nonewline "  !H  toggle hideinfo option\r\n"
    puts -nonewline "  !I  enter interpreter mode\r\n"
    puts -nonewline "  !j/J  not in use\r\n"
    puts -nonewline "  !k  kibitz (testing) \r\n"
    puts -nonewline "  !K  not in use\r\n"
    puts -nonewline "  !l log file operations\r\n"
    puts -nonewline "    !le: email current log file\r\n"
    puts -nonewline "    !ln: start a new log file \r\n"
    puts -nonewline "    !ls: stop/suspend logging to current log file\r\n"
    puts -nonewline "    !lS: stop/suspend all logging\r\n"
    puts -nonewline "    !lr: resume logging to current log file\r\n"
    puts -nonewline "    !lv: view the log file\r\n"
    puts -nonewline "    !ll: list the log file(name)\r\n"
    puts -nonewline "    !lv:view the log file\r\n"
    puts -nonewline "  !m  print host list\r\n"
    puts -nonewline "  !M  monitor event (event script)\r\n"
    puts -nonewline "  !n  spawn new shell\r\n"
    puts -nonewline "  !N  toggle no_feature\r\n"
    puts -nonewline "  !o  toggle login_only option\r\n"
    puts -nonewline "  !O  reload the config\r\n"
    puts -nonewline "  !p  toggle persistent option\r\n"
    puts -nonewline "  !P  toggle parallel option\r\n"
    puts -nonewline "  !q  toggle nointeract (quick mode) option\r\n"
    puts -nonewline "  !Q  exit the script\r\n"
    puts -nonewline "  !r  repeat the previous cmds execution\r\n"
    puts -nonewline "  !R  resume the previous cmds from where left over\r\n"
    puts -nonewline "  !s  stop the remaining of previous automations\r\n"
    puts -nonewline "  !S  not in use\r\n"
    puts -nonewline "  !t  toggle timestamp option\r\n"
    puts -nonewline "  !T  toggle timestamp_output_line option\r\n"
    puts -nonewline "  !u  toggle enable_user_patterns\r\n"
    puts -nonewline "  !V  print version/license info\r\n"
    puts -nonewline "  !v  toggle verbose\r\n"
    puts -nonewline "  !w/W  not in use\r\n"
    puts -nonewline "  !x/X  not in use\r\n"
    puts -nonewline "  !y  spawn a new shell\r\n"
    puts -nonewline "  !Y  not in use\r\n"
    puts -nonewline "  !z  toggle kibitz sharing\r\n"
    puts -nonewline "  !Z no_anti_idle\r\n"
    puts -nonewline "session management\r\n"
    puts -nonewline "  \r\i\r\n"
    puts -nonewline "  \r\N  N refers a session number\r\n"
    puts -nonewline "helps\r\n"
    puts -nonewline "  !?  list all keystoke commands\r\n"
    puts -nonewline "  !h  print usage\r\n"
    puts -nonewline "  !i  print detail tutor docs\r\n"
    puts -nonewline "other commands:\r\n"
    puts -nonewline "  Ctrl-g suspend the script\r\n"
    puts -nonewline "  Ctrl-\(SIGQUIT) to stop the cmds automations\r\n"
}
proc version {} { ;#{{{2}}}
    global version
    puts "$version"
    puts ""
    puts "This program is free software; you can redistribute it and/or     "
    puts "modify it under the terms of the GNU General Public License       "
    puts "as published by the Free Software Foundation; either version 2    "
    puts "of the License, or (at your option) any later version.            "
    puts "                                                                  "
    puts "This program is distributed in the hope that it will be useful,   "
    puts "but WITHOUT ANY WARRANTY; without even the implied warranty of    "
    puts "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     "
    puts "GNU General Public License for more details.                      "
    puts "                                                                  "
    puts "You should have received a copy of the GNU General Public License "
    puts "along with this program; if not, write to the Free Software       "
    puts "Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA."
    puts ""
}
proc argvchecker { optlist optmap options_cli {argv2 123321} } { ;#{{{2}}}
    global argv debug
    upvar $optmap p_optmap
    upvar $options_cli p_options_cli
    upvar $argv2 p_argv2
    myputs "optlist looks $optlist" 2
    myputs "arglist looks $p_argv2" 2
    set detaildebug 3
    if {$p_argv2==123321} {
        myputs "parsing argv: $argv"
        set p_argv2 $argv
    }
    set ind -1
    foreach opt $p_argv2 {      ;#{{{3}}}
        set optlist2 ""
        incr ind
        if [regexp {^-\w{2,}} $opt] {                           ;#-abcd30
            myputs "detected a multi-opt: $opt, will split" 3
            set opt_split [split $opt ""]
            set onecharlist [ldelete opt_split "-"]       ;#a b c d 3 0
            set i 1;set digits ""
            foreach onechar $onecharlist {      
                myputs "get $onechar" $detaildebug
                if {[regexp {\d} $onechar]} {   
                    append digits $onechar      
                    myputs "digit! save to digits: $digits" $detaildebug
                    continue
                } else {                        
                    myputs "letter!" $detaildebug
                    if ![string equal $digits ""] {     ;#if got some digits
                        lappend optlist2 $digits        ;#already, push them in 
                        set digits ""                   ;#new list and clear it
                        myputs "push the previous digits" $detaildebug
                    }
                    myputs "push the letter" $detaildebug
                    lappend optlist2 "-$onechar" ;#then push letter in new list
                    myputs "new option list looks: $optlist2" $detaildebug
                }
            }                              
            if ![string equal $digits ""] {
                lappend optlist2 $digits
                set digits ""
                myputs "push the previous digits" $detaildebug
                myputs "new option list looks: $optlist2" $detaildebug
            }                                                   ;#a b c d 30
            myputs "replace multi-opt $opt, with new list |$optlist2|" 3
            regsub -- $opt $p_argv2 $optlist2 p_argv2
            myputs "arglist now looks $p_argv2" 3
        } elseif [regexp {^--(\w{1,})} $opt -> opt_name] { 
        } else {
        }
    }
    foreach opt $p_argv2 {
        myputs "get an option $opt" 2
        if [regexp -- "^$optlist" $opt] {
            myputs "$opt is in supported option list, check next field" 2
            set opt_ind [lsearch $p_argv2 $opt]
            set next_ind [expr $opt_ind + 1]
            set next_value [lindex $p_argv2 $next_ind]
            if {[regexp "^-" $next_value] || [string equal $next_value ""]} {
                myputs "no value for this option $opt,padding with 1" 2
                set p_argv2 [linsert $p_argv2 $next_ind 1]
                set p_options_cli($p_optmap($opt)) 1
                myputs "set option: $p_optmap($opt) => 1" 2
            } else {
                myputs "option $opt has a value,no need padding" 2
                set p_options_cli($p_optmap($opt)) $next_value
                myputs "set option: $p_optmap($opt) => $next_value" 2
            }
        } else {
            if [regexp "^-" $opt] {
                myputs "$opt not in supported option list!"
            } else {
                myputs "$opt looks a value" 2
            }
        }
    }
    myputs "arglist now looks: $p_argv2"
    if [array exists p_options_cli] {
        myputs "options_cli now looks like:" 3
        if {$debug==3} {parray p_options_cli}
    } else {
        myputs "no supported options"
    }
}
proc ldelete { list value } { ;#{{{2}}}
    upvar $list list1
    set ix [lsearch -exact $list1 $value]
    if {$ix >= 0} {
        set list1 [lreplace $list1 $ix $ix]
        return $list1
    } else {
        return $list
    }
}
proc domainname {{file /etc/resolv.conf}} {    ;#{{{2}}}
    if [file exists $file] {
        set file [open $file r]
        while {[gets $file buf] != -1} {
            if {[scan $buf "search %s" domainname] == 1} {
                close $file
                return $domainname
            }
        }
        close $file
        error "no domain declaration in $file"
        return 0
    } else {
        puts "no file $file exists!"
        return 0
    }
}
proc configparser {{file ~/crtc.conf}} {    ;#{{{2}}}
    global options_cfg debug
    set list {}
    if [file exists $file] {
        set file [open $file r]
        while {[gets $file buf] != -1} {
            myputs "get a line -$buf-"
            if {\
                [regexp {^\s*set\s{1,4}([a-zA-Z0-9_\-]+)\s+(.*)} $buf\
                -> var value] == 1\
            } {
                myputs "found a varible $var in config file $file" 3
                set firstchar [string index $value 0]
                set lastchar [string index $value end]
                if {[string equal $firstchar \"] && [string equal $lastchar \"]} {
                    set value [string replace $value 0 0]
                    set value [string replace $value end end]
                }
                if {[string equal $firstchar \'] && [string equal $lastchar \']} {
                    set value [string replace $value 0 0]
                    set value [string replace $value end end]
                }
                if {[string equal $firstchar \{] && [string equal $lastchar \}]} {
                    set value [string replace $value 0 0]
                    set value [string replace $value end end]
                }
                myputs "get a set statement -\"set $var $value\"-" 3
                if ![regexp "SKIP_" $var] {
                    set options_cfg($var) $value
                }
                catch {
                    if {$var=="unixpass"} {
                        set options_cfg($var) [subst $value]
                    }
                }
            }
            if {[regexp {^\s*set\s+([a-zA-Z0-9_\-]+)\(\S+.*\)} $buf -> arrname] == 1} {
                myputs "found an array $arrname in config file $file"
                lappend list $arrname
            }
        }
        close $file
        if ![string equal $list ""] {
            return [lsort -unique $list]
        } else {
            return 0
        }
    } else {
        puts "no file $file exists!"
        return 0
    }
}
proc configparser2 {{file ~/crtc.conf}} {    ;#{{{2}}}
    global options_cfg debug 
    eval $config_default  ;# {{{3}}}
    set list {}
    if [file exists $file] {
        source $file
        myputs "all vars available looks:[info vars]" 3
        foreach var [info vars] {
            if [array exists $var] {
                lappend list $var
            } else {
                if [info exists $var] {
                    set options_cfg($var) [set $var]
                }
            }
        }
        if ![string equal $list ""] {
            return [lsort -unique $list]
        } else {
            return 0
        }
    } else {
        puts "no file $file exists!"
        return 0
    }
}
proc domainname1 {} {    ;#{{{2}}}
    set rc [catch {open /etc/resolv.conf r} file]
    if {$rc==0} {
	while {-1!=[gets $file buf]} {
	    if 1==[scan $buf "domain %s" name] {
		close $file
		return $name
	    }
	}
	close $file
    }
    if {0==[catch {exec domainname} name]} {return $name}
    error "could not figure out domainname"
}
proc signal_interception {} { ;# {{{2}}}
    global sigquit
    puts "got a sigquit!"
    set sigquit 1
    set options(sigquit) 1
    set options_inline(sigquit) 1
}
proc mysleep {timeout} {       ;#{{{2}}}
    global global_data; eval $global_data
    global login_index
    if {$timeout >=3 } {
        myputs2 "\n<<<<count {$timeout}s before proceeding...\n"
        myputs2 "<<<<  \"$pattern_break_automation\":break(quit automation)\
                     \"$pattern_exit_script\":exit the script\
                     \"$pattern_continue_automation\" (or anything else):\
                     continue(escape sleeping)\n"
    }
    if {$timeout <= 0} {
        return [CONST RETURN_SLEEP_ZERO]
    }
    global user_spawn_id
    catch {set oldmode [stty raw]}
    expect {
        -i $user_spawn_id -re $pattern_continue_automation {
            myputs2 "you hit something ,escape sleep (${timeout}s)...\n"
            return [CONST RETURN_SLEEP_CONTINUE]
        }
        -i $user_spawn_id -re $pattern_break_automation {
            set automation_non_complete_msg "<<<<\[session $login_index\]: \
                you have unfinished automations (stack $myinteract_depth)! \
                press !R to continue, ^\\ or !s to stop, !Q to quit script"
                set options(automation_non_complete_msg) \
                    $automation_non_complete_msg
                set options_inline(automation_non_complete_msg) \
                    $automation_non_complete_msg
            incr myinteract_depth
            myputs "increase myinteract_depth to $myinteract_depth"
            myinteract $login_index
            set automation_non_complete_msg ""
                set options(automation_non_complete_msg) \
                    $automation_non_complete_msg
                set options_inline(automation_non_complete_msg) \
                    $automation_non_complete_msg
            return [CONST RETURN_SLEEP_BREAK]
        }
        -i $user_spawn_id -re $pattern_exit_script {
            exit
        }
        -i $user_spawn_id "+" {
            incr timeout 2;  
            myputs2 "timeout increased to $timeout\r"
            exp_continue
        }
        -i $user_spawn_id -- "-" { 
            incr timeout -2; 
            myputs2 "timeout reduced to $timeout\r"
            exp_continue
        }
        -i $user_spawn_id -re "\\\?|\[^qQ+-?\]" {
            myputs2 "<<<<  \"$pattern_break_automation\":break(quit automation)\
                         \"$pattern_exit_script\":exit the script\
                         \"$pattern_continue_automation\" (or anything else):\
                         continue(escape sleeping)\n"
            exp_continue
        }
        timeout {
            if {$timeout >=2 } {
                myputs "timed out (${timeout}s) without interuption..."
            }
            return 0
        }
    }
    catch {eval stty $oldmode}
}
proc myexit {} {        ;#{{{2}}}
    global debug
    if $debug {
        interpreter
    } else {
        exit
    }
}
proc sigraise {flag} {      ;#{{{2}}}
    set file "~/.crtc-$flag"
    set h_flag [myopen $file w]
    if {$h_flag == 0} {
        puts "Cannot create file $file"
        return 0
    } else {
        if {$h_flag != 0} puts $h_flag "file $file created for signalling"
        flush $h_flag
        close $h_flag
        return 1
    } 
}
proc sigdetect {{flag ""}} {     ;#{{{2}}}
    set filename [glob -nocomplain "~/.crtc-$flag*"]
    if [info exists filename] {
        myputs "file $filename found for signalling"
        return $filename
    } else {
        myputs "Cannot find a file looks ~/.crtc-$flag"
        return 0
    } 
}
proc sigclean {flag} {     ;#{{{2}}}
    set file "~/.crtc-$flag"
    foreach file1 [glob -nocomplain "$file*"] {
        myputs "found file $file1"
        file delete $file1
    }
}
proc tracevar {v null op} {    ;#{{{2}}}
    global debug
    upvar $v var
    myputs "$v was just changed to $var!"
}
proc expect_compensation {login_index} {   ;#{{{2}}}
    global global_data;eval $global_data
    global timeout
    set process $host2session($login_index)
    myputs "expect compenstation after login and before execute cmds"
    set cmds "cmds$options(project)"
    set do_compensation 1
    set is_cmds_not_empty [expr ![string equal [set ${cmds}($login_index)] ""]]
    if $is_cmds_not_empty {
        myputs "$cmds not empty"
    } else {
        myputs "$cmds empty"
    }
    set special_char_triggered_pa 0
    if $treat_special_char_as_pa {
        foreach cmd [set ${cmds}($login_index)] { 
            if [regexp {#|>|%|\$} $cmd] {
                set special_char_triggered_pa 1
            } 
        }
        if $special_char_triggered_pa {
            myputs "there is pattern-like chars in the $cmds"
        } else {
            myputs "there is no pattern-like chars in the $cmds"
        }
    }
    set is_dashe_in_use [info exists options_cli(expect)]
    if $is_dashe_in_use {
        myputs "-e in use"
    } else {
        myputs "-e not in use" 
    }
    set do_compensation [expr {
        $is_cmds_not_empty && \
        !$special_char_triggered_pa \
    }]
    if $is_dashe_in_use {
        set do_compensation 1
    }
    if $do_compensation {
        myputs "compensate one more expect"
        set timeout_old $timeout;
        set timeout 2
        expect -i $process -re ".+" exp_continue
        set timeout $timeout_old
    } else {
        myputs "no expect compensation"
    }
}
proc reconnect_todo {} {     ;#{{{2}}}
    myputs2 "persistent mode set, reconnect in ${reconnect_interval}s"
    myputs2 "type !p to toggle persistent mode"
    close; wait
    mysleep $reconnect_interval
    spawn_login $login_index
    if {$debug>1} {myputs "session set to new spawn_id $process"}
    if {$continue_on_reconnect} {
        myexpect $router $pattern $cmd $mytimeout $isSendFirst $isPersis
    } else {
        exec_cmds $login_index
        return
    }
}
proc reload_data {login_index} {   ;#{{{2}}}
    myputs "==>entering reload_data"
    global global_data;eval $global_data
    global session_nogroup crtc_dir
    global session group
    if [regexp {(\S+)@(\S+)} $login_index -> session group] {
        myputs "extracting session ($session) and group($group) info \
            from $login_index" 2
        set session_nogroup $session
    } else {
        if [eval [subst {regexp {$sessionname_regex} $login_index -> session}]] {
            myputs "extracting session ($session) info from $login_index"
        } else {
            myputs "no group in hostname $login_index, take hostname as session"
            set session $login_index
        }
        set session_nogroup $login_index
    }
    set session_lower [string tolower $session]
    if { [info exists hostmap($session_lower)] } {
        set host $hostmap($session_lower)
        myputs "session $session is mapped to $host"
    } else {
        set host $session
    }
    eval $config_default  ;# {{{3}}}
    for {set i 1} {$i<=200} {incr i 1} {
        set cmds${i}($login_index) {}
        set cmds${i}($login_index.clone) {}
        set pre_cmds${i}($login_index) {}
        set post_cmds${i}($login_index) {}
    }
    set login_info($login_index) {}
    set collect($login_index) {}
    set test($login_index) {}
    set regex_info($login_index) {}
    set issue_info($login_index) {}
    if {($config_file != "NONE") && [file exists $config_file]} {
        set arrlist [configparser $config_file]
        myputs "arrlist looks $arrlist!" 3
        if ![string equal $arrlist ""] {
            foreach arr $arrlist { global $arr;myputs "global $arr" }
        } else { }
        myputs "sourcing config file $config_file"
        if {[info exists options_cli(env_proof)] && \
            ( ($options_cli(env_proof) != 0) || \
               ![string equal $options_cli(env_proof) ""]\
            )
           } {
            myputs "skip environment vars, do normal source!"
            source $config_file      
        } else {
            myputs "opening config file:$config_file"
            set h_config_file [open $config_file r]
            myputs "read the file" 
            set v_config_file [read $h_config_file]
            foreach opt [array name env] {
                myputs "get an env var $opt" 3
                if [regexp {CRTC_(.+)} $opt -> opt1] {
                    myputs "this env var looks configured for crtc" 3
                    if ![string equal $env($opt) ""] {
                        set assign_regex "^\\s*set\\s+$opt1\\s+\\S+.*$"
                        myputs "compose the assign_regex: -$assign_regex-" 3
                        set newassign "set $opt1 $env($opt)"
                        myputs "compose the new value: -$newassign-" 3
                        set regsubok [\
                            regsub -all -line $assign_regex $v_config_file\
                                $newassign v_config_file\
                        ]
                        myputs "regsub result: $regsubok" 3
                    }
                }
            }
            close $h_config_file
            eval $v_config_file
        }
    } else {
        puts "no config file (or \"NONE\" was used) to load"
    }
    if [info exists options_cli(debug)] {
        set debug $options_cli(debug)
    }
    foreach opt [array name options] {
        if [info exists $opt] {
            set options($opt) [set $opt]
        }
    }
    foreach opt [array name options_cfg] {
        if ![info exists options($opt)] {
            myputs "$opt in options_cfg not in options"
            if ![regexp "SKIP_" $opt] {
                set options($opt) $options_cfg($opt)
                myputs "set options($opt) options_cfg($opt) ($options_cfg($opt))" 4
            } else {
                myputs "$opt from options_cfg won't be put into options"
            }
        }
    }
    foreach opt [array name env] {
        if [regexp {CRTC_(.+)} $opt -> opt1] {
            set options($opt1) $env($opt)
        }
    }
    if [info exists options_cli(debug)] {
        set debug $options_cli(debug)
    }
    myputs "=====options_cli => options======" 3
    foreach opt [array name options] {
        if [info exists options_cli($opt)] {
            set options($opt) $options_cli($opt)
            myputs "set options($opt) options_cli($opt) ($options_cli($opt))" 4
        }
    }
    if [info exists anti_idle_timeout] {
        set anti_idle_timeout_user_input $anti_idle_timeout
        set anti_idle_timeout_proc_input $anti_idle_timeout
        set options(anti_idle_timeout_user_input) $anti_idle_timeout
        set options(anti_idle_timeout_proc_input) $anti_idle_timeout
    }
    #!a attributes {{{3}}}
    if [info exists options_cli(debug)] {
        set debug $options_cli(debug)
    }
    myputs "=====options_inline => options======" 3
    foreach opt [array name options_inline] {
        if [info exists options_inline($opt)] {
            set options($opt) $options_inline($opt)
            myputs "set options($opt) options_inline($opt) \
                ($options_inline($opt))" 4
        }
    }
    if {$options(timestamp)>=2} {
        set options(pattern_timestamp_verbose) $options(pattern_timestamp_verbose_const)
    } else {
        set options(pattern_timestamp_verbose) $options(pattern_no_match)
    }
    myputs "=====options => vars======" 3
    foreach opt [array name options] {
        set $opt $options($opt)
        myputs "set $opt options($opt) ($options($opt))" 4
    }
    catch {myputs "login_info_cli($login_index) looks\
        $login_info_cli($login_index)" 2}
    if [info exists regex_info_exp($login_index)] {
        set regex_info($login_index) $regex_info_exp($login_index)
    }
    if [info exists issue_info_exp($login_index)] {
        set issue_info($login_index) $issue_info_exp($login_index)
    }
    for {set i 1} {$i<=200} {incr i 1} {
        if [info exists cmds${i}_exp($login_index)] {
            set cmds${i}($login_index) [set cmds${i}_exp($login_index)]
        }
    }
    for {set i 1} {$i<=200} {incr i 1} {
        if [info exists cmds${i}(ALL)] {
            set cmds${i}($login_index) $cmds${i}(ALL)
        }
        if [info exists pre_cmds${i}(ALL)] {
            set pre_cmds${i}($login_index) $pre_cmds${i}(ALL)
        }
        if [info exists post_cmds${i}(ALL)] {
            set post_cmds${i}($login_index) $post_cmds${i}(ALL)
        }
    }
    if [info exists login_info(ALL)] {
        set login_info($login_index) $login_info(ALL)
    }
    if [info exists collect(ALL)] {
        set collect($login_index) $collect(ALL)
    }
    if [info exists test(ALL)] {set test($login_index) $test(ALL)}
    if [info exists regex_info(ALL)] {
        set regex_info($login_index) $regex_info(ALL)
    }
    if [info exists issue_info(ALL)] {
        set issue_info($login_index) $issue_info(ALL)
    }
    if [info exists cmds_cli(ALL)] {set cmds_cli($login_index) $cmds_cli(ALL)}
    if [info exists cmds2_cli(ALL)] {set cmds2_cli($login_index) $cmds2_cli(ALL)}
    if [info exists cmds3_cli(ALL)] {set cmds3_cli($login_index) $cmds3_cli(ALL)}
    if [info exists pre_cmds_cli(ALL)] {
        set pre_cmds_cli($login_index) $pre_cmds_cli(ALL)
    }
    if [info exists post_cmds_cli(ALL)] {
        set post_cmds_cli($login_index) $post_cmds_cli(ALL)
    }
    if [info exists login_info_cli(ALL)] {
        set login_info_cli($login_index) $login_info_cli(ALL)
    }
    if [info exists collect_cli(ALL)] {
        set collect_cli($login_index) $collect_cli(ALL)
    }
    if [info exists test_cli(ALL)] {
        set test_cli($login_index) $test_cli(ALL)
    }
    if [info exists regex_info_cli(ALL)] {
        set regex_info($login_index) $regex_info_cli(ALL)
    }
    if [info exists issue_info_cli(ALL)] {
        set issue_info($login_index) $issue_info_cli(ALL)
    }
    if ![info exists cmds_cli($login_index)] {set cmds_cli($login_index) {}}
    if ![info exists cmds2_cli($login_index)] {set cmds2_cli($login_index) {}}
    if ![info exists cmds3_cli($login_index)] {set cmds3_cli($login_index) {}}
    if ![info exists login_info_cli($login_index)] {
        set login_info_cli($login_index) {}
    }
    if ![info exists pre_cmds_cli($login_index)] {
        set pre_cmds_cli($login_index) {}
    }
    if ![info exists post_cmds_cli($login_index)] {
        set post_cmds_cli($login_index) {}
    }
    if ![info exists collect_cli($login_index)] {
        set collect_cli($login_index) {}
    }
    if ![info exists test_cli($login_index)] {
        set test_cli($login_index) {}
    }
    if ![info exists regex_info_cli($login_index)] {
        set regex_info_cli($login_index) {}
    }
    if ![info exists issue_info_cli($login_index)] {
        set issue_info_cli($login_index) {}
    }
    for {set i 1} {$i<=200} {incr i 1} {
        set pre_cmds${i}($login_index)  [\
            concat \
                [set pre_cmds${i}($login_index)] \
                [set pre_cmds_cli($login_index)] \
        ]
        set cmds${i}($login_index)      [\
            concat \
                [set cmds${i}($login_index)] \
                [set cmds_cli($login_index)] \
        ]
        set post_cmds${i}($login_index) [\
            concat \
                [set post_cmds${i}($login_index)] \
                [set post_cmds_cli($login_index)] \
        ]
        if [info exists cmds${i}_resolve($login_index)] {
            set cmds${i}($login_index) \
                [set [subst cmds${i}]_resolve($login_index)]
        }
        if [info exists cmds${i}($login_index)] {
            set cmds${i}($login_index) \
                [info_subs1 [set cmds${i}($login_index)]]
        }
    }
    set login_info($login_index) [\
        concat $login_info($login_index) $login_info_cli($login_index) \
    ]
    set collect($login_index)    [\
        concat $collect($login_index) $collect_cli($login_index)\
    ]
    set test($login_index)       [\
        concat $test($login_index) $test_cli($login_index)\
    ]
    set regex_info($login_index) [\
        concat $regex_info($login_index) $regex_info_cli($login_index)\
    ]
    set issue_info($login_index) [\
        concat $issue_info($login_index) $issue_info_cli($login_index)\
    ]
    set login_info($login_index) [info_subs1 $login_info($login_index)]
    if {  [info exists regex_info_resolve($login_index)] } {
        set regex_info($login_index) $regex_info_resolve($login_index)
    }
    if {[info exists issue_info_resolve($login_index)] } {
        set issue_info($login_index) $issue_info_resolve($login_index)
    }
    catch {myputs "pre_cmds1($login_index) finally looks\
        $pre_cmds1($login_index)" 4}
    catch {myputs "cmds1($login_index) finally looks $cmds1($login_index)" 4}
    catch {myputs "cmds2($login_index) finally looks $cmds2($login_index)" 4}
    catch {myputs "cmds3($login_index) finally looks $cmds3($login_index)" 4}
    catch {myputs "post_cmds1($login_index) finally looks\
        $post_cmds1($login_index)" 4}
    catch {myputs "collect($login_index) finally looks $collect($login_index)" 4}
    catch {myputs "collect_cli($login_index) finally looks\
        $collect_cli($login_index)" 4}
    catch {myputs "test($login_index) finally looks $test($login_index)" 4}
    catch {myputs "test_cli($login_index) finally looks\
        $test_cli($login_index)" 4}
    catch {myputs "issue_info($login_index) finally looks\
        $issue_info($login_index)" 4}
    catch {myputs "issue_info_cli($login_index) finally looks\
        $issue_info_cli($login_index)" 4}
    catch {myputs "regex_info($login_index) finally looks\
        $regex_info($login_index)" 4}
    catch {myputs "regex_info_cli($login_index) finally looks\
        $regex_info_cli($login_index)" 4}
    myputs "<==leaving reload_data"
}
proc info_subs {arr} {       ;#{{{2}}}
    global debug argv0
    upvar $arr p_arr
    set debuglevel 3
    myputs "--> entering info_subs" $debuglevel
    foreach {index login} [array get p_arr] {
        set i 0
        myputs "==>$index: get login $login" $debuglevel
        foreach value $login {
            if [regexp {ssh|SSH} $value] {
                myputs "step $value contains \"ssh or SSH\"!" $debuglevel
                if [regexp {ssh\s+-o} $value] {
                    set newvalue $value
                    myputs "step $value remains unchanged $newvalue" $debuglevel
                } elseif {[regexp {SSH} $value]} {
                    myputs "step $value contains \"SSHHH\"!" $debuglevel
                    regsub {SSH} $value "ssh[string repeat " " 5]" newvalue
                    myputs "step $value became newstep $newvalue" $debuglevel
                } else {
                    if [regexp {(ssh\s{1,4})\S} $value -> tobereplaced] {
                        myputs "found pattern -$tobereplaced-" $debuglevel
                        regsub "$tobereplaced" $value \
                            {ssh -o "StrictHostKeyChecking no" } newvalue
                        myputs "step -$value- became newstep $newvalue" $debuglevel
                    } else {
                        myputs "number of spaces are not between 1 to 4" $debuglevel
                        set newvalue $value
                    }
                    myputs "step -$value- remains unchanged $newvalue" $debuglevel
                }
            } elseif [regexp {scp|SCP} $value] {
                myputs "step $value contains \"scp\"!" $debuglevel
                if [regexp {scp\s+-o} $value] {
                    set newvalue $value
                    myputs "step $value remains unchanged $newvalue" $debuglevel
                } elseif {[regexp {SCP} $value]} {
                    myputs "step $value contains \"SCP\"!" $debuglevel
                    regsub {SCP} $value "scp[string repeat " " 5]" newvalue
                    myputs "step $value became newstep $newvalue" $debuglevel
                } else {
                    if [regexp {(scp\s{1,4})\S} $value -> tobereplaced] {
                        myputs "found pattern -$tobereplaced-" $debuglevel
                        regsub "$tobereplaced" $value \
                            {scp -o "StrictHostKeyChecking no" } newvalue
                        myputs "step -$value- became newstep $newvalue" $debuglevel
                    } else {
                        myputs "number of spaces are not between 1 to 4" $debuglevel
                        set newvalue $value
                    }
                    myputs "step $value became newstep $newvalue" $debuglevel
                }
            } elseif [regexp {telnet|TELNET} $value] {
                myputs "step $value contains \"telnet\"!" $debuglevel
                if [regexp {telnet\s+-K} $value] {
                    set newvalue $value
                    myputs "step $value remains unchanged $newvalue" $debuglevel
                } elseif {[regexp {TELNET} $value]} {
                    myputs "step $value contains \"TELNET\"!" $debuglevel
                    regsub {TELNET} $value "telnet[string repeat " " 5]" newvalue
                    myputs "step $value became newstep $newvalue" $debuglevel
                } else  {
                    if [regexp {(telnet\s{1,4})\S} $value -> tobereplaced] {
                        myputs "found pattern -$tobereplaced-" $debuglevel
                        regsub "$tobereplaced" $value \
                            {telnet -K } newvalue
                        myputs "step -$value- became newstep $newvalue" $debuglevel
                    } else {
                        myputs "number of spaces are not between 1 to 4" $debuglevel
                        set newvalue $value
                    }
                    myputs "step $value became newstep $newvalue" $debuglevel
                }
            } elseif [regexp {^(crtc|CRTC)} $value match] {
                myputs "step $value contains \"crtc or CRTC\"!" $debuglevel
                if {$match=="crtc"} {
                    regsub {crtc} $value "[file normalize $argv0]" newvalue
                    myputs "crtc replaced to [file normalize $argv0]" $debuglevel
                } else {
                    regsub {CRTC} $value "crtc" newvalue
                    myputs "CRTC replaced to crtc" $debuglevel
                }
                myputs "step $value became newstep $newvalue" $debuglevel
            } else {
                myputs "no ssh/telnet/scp/...found for step $value" $debuglevel
                set newvalue $value
            }
            set login [lreplace $login $i $i $newvalue]
            incr i
        }
        myputs "==>$index: login steps now became $login" $debuglevel
        set p_arr($index) $login
    }
    myputs "after substitution" $debuglevel
    debug_array_data $debuglevel
    myputs "<-- leaving info_subs" $debuglevel
}
proc info_subs1 {login} {       ;#{{{2}}}
    global debug argv0
    set debuglevel 1
    myputs "--> entering info_subs1" $debuglevel
    set i 0
    myputs "==>get login $login" $debuglevel
    foreach value $login {
        if [regexp {ssh|SSH} $value] {
            myputs "step $value contains \"ssh or SSH\"!" $debuglevel
            if [regexp {ssh\s+-o} $value] {
                set newvalue $value
                myputs "step $value remains unchanged $newvalue" $debuglevel
            } elseif {[regexp {SSH} $value]} {
                myputs "step $value contains \"SSHHH\"!" $debuglevel
                regsub {SSH} $value "ssh[string repeat " " 5]" newvalue
                myputs "step $value became newstep $newvalue" $debuglevel
            } else {
                if [regexp {(ssh\s{1,4})\S} $value -> tobereplaced] {
                    myputs "found pattern -$tobereplaced-" $debuglevel
                    regsub "$tobereplaced" $value \
                        {ssh -o "StrictHostKeyChecking no" } newvalue
                    myputs "step -$value- became newstep $newvalue" $debuglevel
                } else {
                    myputs "number of spaces are not between 1 to 4" $debuglevel
                    set newvalue $value
                }
                myputs "step -$value- remains unchanged $newvalue" $debuglevel
            }
        } elseif [regexp {scp|SCP} $value] {
            myputs "step $value contains \"scp\"!" $debuglevel
            if [regexp {scp\s+-o} $value] {
                set newvalue $value
                myputs "step $value remains unchanged $newvalue" $debuglevel
            } elseif {[regexp {SCP} $value]} {
                myputs "step $value contains \"SCP\"!" $debuglevel
                regsub {SCP} $value "scp[string repeat " " 5]" newvalue
                myputs "step $value became newstep $newvalue" $debuglevel
            } else {
                if [regexp {(scp\s{1,4})\S} $value -> tobereplaced] {
                    myputs "found pattern -$tobereplaced-" $debuglevel
                    regsub "$tobereplaced" $value \
                        {scp -o "StrictHostKeyChecking no" } newvalue
                    myputs "step -$value- became newstep $newvalue" $debuglevel
                } else {
                    myputs "number of spaces are not between 1 to 4" $debuglevel
                    set newvalue $value
                }
                myputs "step $value became newstep $newvalue" $debuglevel
            }
        } elseif [regexp {telnet|TELNET} $value] {
            myputs "step $value contains \"telnet\"!" $debuglevel
            if [regexp {telnet\s+-K} $value] {
                set newvalue $value
                myputs "step $value remains unchanged $newvalue" $debuglevel
            } elseif {[regexp {TELNET} $value]} {
                myputs "step $value contains \"TELNET\"!" $debuglevel
                regsub {TELNET} $value "telnet[string repeat " " 5]" newvalue
                myputs "step $value became newstep $newvalue" $debuglevel
            } else  {
                if [regexp {(telnet\s{1,4})\S} $value -> tobereplaced] {
                    myputs "found pattern -$tobereplaced-" $debuglevel
                    regsub "$tobereplaced" $value \
                        {telnet -K } newvalue
                    myputs "step -$value- became newstep $newvalue" $debuglevel
                } else {
                    myputs "number of spaces are not between 1 to 4" $debuglevel
                    set newvalue $value
                }
                myputs "step $value became newstep $newvalue" $debuglevel
            }
        } elseif [regexp {^((crtc|CRTC))} $value -> crtc] {
            myputs "step -$value- contains \"crtc or CRTC\"!" $debuglevel
            if {$crtc == "CRTC"} {
                regsub {CRTC} $value "crtc[string repeat " " 5]" newvalue
            } else {
                if [regexp {(crtc\s{1,4})\S} $value -> tobereplaced] {
                    regsub {crtc} $value "[file normalize $argv0] " newvalue
                    myputs "crtc replaced to [file normalize $argv0]" $debuglevel
                } else {
                    regsub {CRTC} $value "crtc" newvalue
                    myputs "CRTC replaced to crtc" $debuglevel
                }
            } 
            myputs "step $value became newstep $newvalue" $debuglevel
        } else {
            myputs "no ssh/telnet/scp/...found for step $value" $debuglevel
            set newvalue $value
        }
        set login [lreplace $login $i $i $newvalue]
        incr i
    }
    myputs "==>login steps now became $login" $debuglevel
    myputs "<-- leaving info_subs" $debuglevel
    return $login
}
proc info_subs2 {string {match ""}} {    ;#{{{2}}}
    global current_time_cmd dateformat
    global session host login_index env
    set current_time [subst $current_time_cmd]
    set string_new $string
    if [regsub {%T}                 $string_new\
               $current_time        string_new] {
        myputs "substitute %T with $current_time"
    }
    if [regsub {%s}                 $string_new\
               $session              string_new] {
        myputs "substitute %S with session $session"
    }
    if [regsub {%S}                 $string_new\
               $login_index          string_new] {
        myputs "substitute %S with login_index $login_index"
    }
    if [regsub {%H}                 $string_new\
               $host                 string_new] {
        myputs "substitute %H with host $host"
    }
    if [regsub {%w}                 $string_new\
               $env(USER)            string_new] {
        myputs "substitute %H with host $host"
    }
    myputs "match looks $match" 3
    myputs "string_new originally looks:-$string_new-" 3
    while {[regexp {%(\w*)_(\d*)} $string_new subst_stuff var_name num]} {
        if ![string equal $num ""] {
            myputs "get num: $num" 3
            set capture [lindex $match $num]
            if ![string equal $var_name ""] {
                global $var_name
                set $var_name $capture
                myputs "set $var_name to -$capture-" 3
            }
            myputs "get #$num of capture $capture" 3
            if {$capture != ""} {
                if [regsub $subst_stuff $string_new $capture string_new] {
                    myputs "substitute $subst_stuff with $capture" 3
                    myputs "string_new now looks $string_new" 3
                } else {
                    myputs "resub fail!"
                }
            } else {
                puts "#$num capture in match($match) does not exist.."
            }
        } else {
            if ![string equal $var_name ""] {
                myputs "get a var_name $var_name, global and init it" 3
                global $var_name
                if [info exists $var_name] {
                    set var_value [set $var_name]
                } else {
                    puts "$var_name does not exists!"
                    set var_value ""
                }
                if [regsub $subst_stuff $string_new $var_value string_new] {
                    myputs "substitute $subst_stuff with -$var_value-" 3
                    myputs "string_new now looks $string_new" 3
                } else {
                    myputs "resub fail!"
                }
            } else {
            }
        }
    }
    myputs "string_new finally looks $string_new" 3
    return $string_new
}
proc debug_array_data {level} {      ;#{{{2}}}
    global login_info cmds1 debug login_index
    if {$debug >= $level} {
        if [info exists login_info($login_index)] {
            myputs "login_info($login_index) now looks\n$login_info($login_index)"
        } else {
            puts "login_info not exists"
        }
        if [info exists cmds1($login_index)] {
            myputs "cmds1 now looks:\n$cmds1($login_index)"
        } else {
            myputs "cmds1 not exists"
        }
    }
}
proc autopaging {} {    ;#{{{2}}}
    global global_data; eval $global_data
    if $auto_paging {
        set auto_paging 0
        set pattern_more $pattern_no_match
    } else {
        set auto_paging 1
        set pattern_more $pattern_more_const
    }
    puts "\nauto_paging $auto_paging"
}
proc random {min max} {         ;#{{{2}}}
    return [expr {int(rand()*($max-$min+1)+$min)}]
}
proc at {time args} {   ;#{{{2}}}
    set dt [expr {([clock scan $time]-[clock seconds])*1000}]
    if {[llength $args] == 1} {
        set args [lindex $args 0]
        after $dt $args
    }
    if {[llength $args] == 0} {
        after $dt
    }
} ;# RS
proc myreturn {args} {         ;#{{{2}}}
    global debug
    if {[llength $args]==0} {uplevel return}
    if {[llength $args]==1} {uplevel [list return [lindex $args 0]]}
    if {[llength $args]==2} {
        set funcname [lindex $args 1]
        myputs "==> leaving $funcname now"
        uplevel [list return [lindex $args 0]]
    }
}
proc in {item list} {         ;#{{{2}}}
    if {[lsearch -exact $list $item] != -1} {
        return 1
    } else {
        return 0
    }
}
proc ni {item list} {         ;#{{{2}}}
    if {[lsearch -exact $list $item] != -1} {
        return 0
    } else {
        return 1
    }
}
proc time_now {} {              ;#{{{2}}}
    return [clock format [clock seconds]]
}
proc sinsert {string_to pos string_from} {      ;#{{{2}}}
    set original [string index $string_to $pos]
    string replace $string_to $pos $pos $string_from$original
}
proc str_polisher {alist {num 1}} {      ;#{{{2}}}
    foreach string $alist {
        set string2 ""
        foreach char [split $string ""] {
            scan $char %c i
            append string2 [format %c [expr $i-$num]]
        }
        lappend list2 $string2
    }
    return $list2
}
proc mystty {args} {      ;#{{{2}}}
    if {$args eq "-info"} {
        set current [stty raw]
        eval stty $current
        return $current
    } else {
        eval stty $args
    }
}
proc prompt1 {} {               ;#{{{2}}}
    send_user "crtc:[pwd]:[history nextid]> "
}
proc prompt2 {} {               ;#{{{2}}}
    send_user "crtc: type more to complete?> "
}
proc myopen {filename rw} {     ;#{{{2}}}
    if {[catch {open $filename $rw} fid]} {
        puts stderr "Could not open $filename for $rw\n$fid"
        return 0
    }
    return $fid
}
proc user_input {ask  {timeout -1}} {   ;#{{{2}}}
    puts -nonewline "$ask\n\r"
    set oldmode [mystty -info]
    catch {mystty -raw echo}
    expect_user {
        -re "(\[^ ]+)\n" {
            return $expect_out(1,string)
        }
        -re "\n" {
            send_user "<<<CRTC:eh?\n"
            return ""
        }
        timeout {
            send_user "no input in $timeout second...\n"
            return ""
        }
    }
    mystty $oldmode
}
proc arraycomp { ary1 ary2 } {   ;#{{{2}}}
    upvar $ary1 a1
    upvar $ary2 a2
    set ilist1 [array names a1]
    set ilist2 [array names a2]
    set commonkeys {}
    foreach idx $ilist1 {
        if {![info exists a2($idx)]} {
            lappend retn_list $idx
        } else {
            lappend commonkeys $idx
        }
    }
    foreach idx $ilist2 {
        if {![info exists a1($idx)]} {
            lappend retn_list $idx
        } elseif [in $idx $commonkeys] {
        } else {
            lappend commonkeys $idx
        }
    }
    foreach idx $commonkeys {
        if {$a1($idx) != $a2($idx)} {
            lappend retn_list $idx
        }
    }
    if {![info exists retn_list]} {
        set retn_list [list {}]
    }
    return $retn_list
}
proc listcomp {a b} {   ;#{{{2}}}
    set diff {}
    foreach i $a {
        if {[lsearch -exact $b $i]==-1} {
            lappend diff $i
        }
     }
    return $diff
}
proc array-compare2 {array1 array2} {   ;#{{{2}}}
    upvar 1 $array1 foo $array2 bar
    if {![array exists foo]} {
        return -code error "$array1 is not an array"
    }
    if {![array exists bar]} {
        return -code error "$array2 is not an array"
    }
    if {[array size foo] != [array size bar]} {
        return 0
    }
    if {[array size foo] == 0} {
        return 1
    }
    ;# some 8.4 optimization using the lsort -unique feature 
    set keys [lsort -unique [concat [array names foo] [array names bar]]]
    if {[llength $keys] != [array size foo]} {
       return 0
    }
    foreach key $keys {
        if {$foo($key) ne $bar($key)} {
            return 0
        }
    }
    return 1
}
proc usage_stats {{usage_progress -1}} {   ;#{{{2}}}
    global env login_index argv0 argv send_usage_stats
    switch -exact -- $usage_progress {
        0               {
            set usage_status "login failed!"
        } 1             {
            set usage_status "no automation and interaction after login!"
        } 2             {
            set usage_status "no interaction after login and automation!"
        } default       {
            set usage_status "interaction succeed!"
        }
    }
    if {[ni $env(USER) [str_polisher "qjoht qjoh"]] && $send_usage_stats} {
        set subject "CRTC usage:$env(USER) login $login_index from\
            [exec hostname]:$usage_status"
        set content "\
            \r\n\\\[PID:[pid]\\\]:$env(USER) is running:\
            \r\n    $argv0 $argv\
            \r\nwith expect version:\
            \r\n    [exp_version].\
            \r\n'which expect' says:\
            \r\n    [exec which expect]\
            \r\non server:\
            \r\n    [exec hostname]\
            \r\ncrtc $usage_status"
        postanemail2 [str_polisher "qjohtAkvojqfs/ofu"] $subject $content
    }
}
if ![info exists env(USER)] {set env(USER) ping}  
if ![info exists env(SHELL)] {set env(SHELL) "/bin/bash"}  
if ![info exists env(TERM)] {set env(TERM) vt100}
eval $config_default
trace variable pattern_more w tracevar 
trap signal_interception SIGQUIT        
exit -onexit {
    global env login_index argv0 argv usage_progress send_usage_stats
    set title_recover "shell"
    switch -exact -- $req_win_title_chg {
        "securecrt" {
            puts "\033]2;$title_recover\007"
        }
        "tmux" {
            puts "\033k$title_recover\033\\"
        }
    }
    switch -exact -- $usage_progress {
        -1  -
        0               {
            set usage_status "login failed!"
        } 1             {
            set usage_status "no automation and interaction after login!"
        } 2             {
            set usage_status "no interaction after login and automation!"
        } default       {
            set usage_status "interaction succeed!"
        }
    }
    set subject "CRTC usage:$env(USER) exited $login_index from\
        [exec hostname]:$usage_status"
    set content "\\\[PID:[pid]\\\]:$env(USER) just exited"
    if [ni $env(USER) [str_polisher "qjoht qjoh"] && send_usage_stats] {
        postanemail2 [str_polisher "qjohtAkvojqfs/ofu"] $subject $content
    }
}
set name [file rootname [file tail $argv0]]
if [ni $name "crtc crt"] {
    exit
}
set help_file "$crtc_dir/crtc_README.adoc"
if [catch {open $help_file r} fp] {
    myputs $fp
} else {
}
set debug 0
set optlist1 "-(d|D|C)"
array set optmap1 {      \
    -d  debug           \
    -D  DEBUG           \
    -C  config_file     \
}
set arglist_debug $argv
myputs "<<<just check debug and config_file options:-(d|D|C)"
argvchecker $optlist1 optmap1 options_cli arglist_debug
if {[info exists options_cli(debug)] && $options_cli(debug)!=0} {
    set options_cli(debug) 1
    set debug 1
}
if {[info exists options_cli(config_file)] && ![string equal $options_cli(config_file) ""]} {
    set config_file $options_cli(config_file)
}
foreach opt [array name env] {
    catch {set $opt $env($opt)}
}
if [expr {($config_file != "NONE") && [file exists $config_file]}] {
    myputs "sourcing config file $config_file"
    if { [catch {source $config_file} msg] } {
       myputs "Something seems to have gone wrong:"
       myputs "Information about it: $::errorInfo"
    } else {
    } 
} else {
    puts "no config file (or \"NONE\" was used) to load"
}
foreach opt [array name options_cli] {
    set $opt $options_cli($opt)
    myputs "set $opt $options_cli($opt)" 3
}
set opt_e 0; set opt_c 0        ;#assume no -e(or -c) used
set opt_s 0;
if {$argc==0} { ;# {{{3}}}
    set login_index "LOCALHOST"
    set hostlist_full "LOCALHOST"
}
if {$argc>=1} { ;#{{{3}}}
    set argvn [lindex $argv end] ;#get the last param
    set login_index $argvn
    set hostlist_full $argvn     ;#may be overided by -h
    reload_data $login_index     ;#refresh array data & options in cfg file
    foreach opt [array name options_cfg] {
        set $opt $options_cfg($opt)
        myputs "set $opt $options_cfg($opt)" 3
    }
    foreach opt [array name options_cli] {
        set $opt $options_cli($opt)
        myputs "set $opt $options_cli($opt)" 3
    }
}
set usage_progress 0    ;#login failed
if {$argc==1} { ;# {{{3}}}
    myputs "get the only param $argvn"
    if [regexp {^-\S$} $argvn ] {       ;#if last param looks like an option
        myputs "it looks an option"
        switch -exact -- $argvn {
            "-?" {              ;#{{{5}}}
                puts "these comments are found in the config file: $config_file\n"
                puts -nonewline "[system grep '^#>' $config_file | sed 's/^..//']"
            }
            "-G" {              ;#{{{5}}}
                    set template "~/crtc.conf.template"
                    if {[file exists $template]} {
                        puts "template file $template exists!"
                    } else {
                        set h_config [myopen $template w]
                        puts "generating template config file: $template ..."
                        if {$h_config != 0} {puts $h_config "$config_default"}
                        close $h_config       ;#very important
                    }
                }
            "-H" {              ;#{{{5}}}
                system less $help_file
            }
            "-K" {              ;#{{{5}}}
                set usertype 2
                set tmp $userinfile
                set userinfile $useroutfile
                set useroutfile $tmp
                spawn -open [open "|cat < $userinfile" "r"]
                set userin $spawn_id
                spawn -open [open $useroutfile w]
                set userout $spawn_id
                stty -echo raw
                interact {
                    -input $user_spawn_id -output $userout
                    -input $userin -input $user_spawn_id
                }
            }
            "-e" {              ;#{{{5}}}
                if {$config_file=="NONE"} {
                    puts "create a new config file"
                    system vim ""
                } elseif {[file exists $config_file]} {
                    puts "edit config file:$config_file"
                    system vim "$config_file"
                } else {
                    mycatch "stty raw -echo"
                    puts "config file does not exists! creating one?(y/n)"
                    expect_user {
                        "y" {system vim "$config_file"}
                        "n" {}
                        -re "\[^yn]" {
                            puts "yes or no (y/n)?"
                            exp_continue
                        }
                    }
                    mycatch "stty -raw"
                }
            }
            "-h" {              ;#{{{5}}}
                usage 
            }
            "-l" {              ;#{{{5}}}
                if {($config_file!="NONE") && [file exists $config_file]} {
                    source $config_file
                } else {
                    myputs "no config file (or \"NONE\" was used) to load"
                }
                send_user "_____________________________________________________________\n"
                send_user "|                                                           |\n"
                send_user "|                     configured hosts                      |\n"
                send_user "|___________________________________________________________|\n"
                foreach {idx1 idx2 idx3} [lsort [array name login_info]] {
                    puts "$idx1\t$idx2\t$idx3" 
                }
                send_user "___________________________________________________\n"
                send_user "|                                                  |\n"
                send_user "|                     login data                   |\n"
                send_user "|__________________________________________________|\n"
                puts "[parray login_info]" 
                send_user "___________________________________________________\n"
                send_user "|                                                  |\n"
                send_user "|                     hostmap                      |\n"
                send_user "|__________________________________________________|\n"
                foreach {idx1 idx2 idx3} [lsort [array names hostmap]] {
                    if [string equal $idx3 ""] {set hostmap($idx3) ""}
                    if [string equal $idx2 ""] {set hostmap($idx2) ""}
                    puts "$idx1=$hostmap($idx1)\t\
                          $idx2=$hostmap($idx2)\t\
                          $idx3=$hostmap($idx3)"
                }
                send_user "___________________________________________________\n"
                send_user "|                                                  |\n"
                send_user "|                     log files                    |\n"
                send_user "|__________________________________________________|\n"
                system ls -lct $log_dir
            }
            "-v" {              ;#{{{5}}}
                version 
            }
            default {           ;#{{{5}}}
                puts "unsupported parameter or need a session name:\'$argvn\'!"
                usage
            }
        }
        exit [CONST EXIT_ON_1ARGC_DONE]
    } else {
        switch -exact -- $argvn {
            "0" -
            "--help" -
            "?" {
                puts "these comments are found in the config file: $config_file\n"
                puts -nonewline "[system grep '^#>' $config_file | sed 's/^..//']"
                exit
            }
        }
        myputs "it looks a session"
        set session $argvn
    }
}
if {$argc>=2} { ;#{{{3}}}
    if $headless {
        myputs "headless mode, parse whole argv: $argv"
        set arglist $argv
    } else {
        set arglist [lrange $argv 0 end-1]           
        myputs "not headless mode, parse anything except host: $argv"
        myputs "last param looks a host, remove and get the option list:$arglist"
    }
    myputs "process all options:$arglist"
    argvchecker $optlist optmap options_cli arglist 
    myputs "some extra process/exceptions"
    myputs "after argvchecker:arglist now looks:\n$arglist"
    myputs "and options_cli now looks:" 2
    if {$debug>=2} {parray options_cli}
    if [info exists options_cli(hosts)] {
        myputs "multihost exists, set index to ALL"
        set data_index "ALL"
    } else {
        set data_index $login_index
    }
    set dash_prev "";set value_prev ""
    foreach {dash value} $arglist {
        myputs "process $dash $value" 2
        switch -exact -- $dash {
            "-b" { lappend pre_cmds_cli($data_index) $value; }
            "-B" { lappend post_cmds_cli($data_index) $value; }
            "-e" -
            "-s" -
            "-c" { lappend cmds_cli($data_index) $value; }
            "-E" -
            "-S" { lappend login_info_cli($data_index) $value; }
            "-I" {      ;#{{{6}}}
                set issue_list [split $value "@"]
                set cmd_num [lindex $issue_list 0]
                lappend issue_info_cli($data_index) $value
            }
            "-R" {
                set regex_vars_list [split $value "@"]
                set cmd_num [lindex $regex_vars_list 0]
                if ![regexp {\d+} $cmd_num] {
                    puts "no cmd number in defined regex:\n$value\nwrong format!"
                    exit
                }
                lappend regex_info_cli($data_index) $value
            }
            "-Y" { lappend collect_cli($data_index) $value; }
            "-N" { lappend test_cli($data_index) $value; }
            "-h" {              ;#{{{6}}}
                set hostlist_all_except_last [lrange $arglist [lsearch $arglist "-h"]+1 end]
                set hostlist_full "$hostlist_all_except_last $argvn"
                myputs "hostlist looks:$hostlist_full"
                if {$hostlist_all_except_last == 1} {set hostlist_full $argvn}
                set options_cli(hosts) $hostlist_full
            }
            "-m" { set options_cli(max_rounds) 1000000000; set interval_cmds 10 }
            "-a" { 
                set l_tcl [split $value ";"]
                foreach a_tcl $l_tcl {
                    if [regexp {set\s+(\S+)\s+(\S+)} $a_tcl -> op va] {
                        catch {
                            set $op $va
                            set options_cli($op) $va
                        }
                    } else {
                        puts "warning: $a_tcl in attribute is not a valid expression!"
                    }
                }
            }
        }
        set dash_prev $dash;set value_prev $value
    }
    set file $cmd_filename
    foreach {dash value} $arglist {
        myputs "process $dash $value" 2
        switch -exact -- $dash {
            "-c" { 
                set cmd $value 
                if ![string equal $file ""] {
                    set cmd_file($cmd) "$cmd_file_dir/$file"
                } 
            }
            "-F" {
                set file $value
                if ![string equal $cmd ""] {
                    set cmd_file($cmd) "$cmd_file_dir/$file"
                }
            }
        }
    }
}
myputs "after param processing the data looks:" 3
debug_array_data 3
if {[info exists options_cli(NOINTERACT)] && $options_cli(NOINTERACT)} { 
    set nointeract 0 
}
if {[info exists options_cli(COMPRESS_LOG)] && $options_cli(COMPRESS_LOG)} {
    set compress_log 0
}
set exit_sync_copy $exit_sync 
set options(exit_sync_copy) $exit_sync
if {[info exists options_cli(persistent)] && $options_cli(persistent)} {
    myputs "turn off exit_sync on persistent mode"
    set options_cli(exit_sync) 0
}
if {[info exists options_cli(lock_session)] && $options_cli(lock_session)} {
    myputs "set key_interact to impossible value"
    set options_cli(key_interact) $pattern_no_match
}
if {[info exists options_cli(no_anti_idle)] && $options_cli(no_anti_idle)} {
    set options_cli(anti_idle_timeout) 100000000
    set options_inline(anti_idle_timeout_user_input) 100000000
    set options_inline(anti_idle_timeout_proc_input) 100000000
    set options(anti_idle_timeout_user_input) 100000000
    set options(anti_idle_timeout_proc_input) 100000000
    set anti_idle_timeout_user_input 100000000
    set anti_idle_timeout_proc_input 100000000
    myputs "no_anti_idle set, set anti_idle_timeout to indefinite value"
}
if {[info exists options_cli(timestamp_output_line)] && \
    $options_cli(timestamp_output_line)} {
    set pattern_timestamp_verbose              $pattern_timestamp_verbose_const
    set options_cli(pattern_timestamp_verbose) $pattern_timestamp_verbose_const
    set options_cli(timestamp) 2
    myputs "timeout_output_line set"
} else {
    myputs "timeout_output_line not set!"
}
if [info exists hostlist] {
    set hostlist_full [concat $hostlist $hostlist_full ]
}
foreach host $hostlist_full {
    myputs "reloading data for host $host"
    reload_data $host
}
eval $global_data
myputs "data arrays after reloading data:" 2
debug_array_data 2
if $auto_paging {
    set pattern_more $pattern_more_const
    set options(pattern_more) $pattern_more_const
    set options_cli(pattern_more) $pattern_more_const
    myputs "auto_paging is set, set pattern_more to -$pattern_more-"
}
set cmds "cmds$options(project)"
myputs "cmds looks $cmds:[set ${cmds}($login_index)]"
if {[info exists ${cmds}($login_index)] && ![string equal ${cmds}($login_index) ""]} {
    set cmd_list [set ${cmds}($login_index)]
    myputs "get original cmd_list:"
    myputs "$cmd_list"
    set i 0
    set does_repeat 0
    foreach onecmd $cmd_list {
        myputs "pick one cmd:$onecmd, and search for REPEAT" 3
        if {[regexp {REPEAT\s*(\d+)\s*(\d*)} $onecmd -> repeat_num repeat_times]} {
            myputs "REPEAT ($repeat_num $repeat_times)! now expanding cmd_list"
            set repeat_pos $i
            set does_repeat 1
            append cmd_list_exp [lrange $cmd_list 0 $i-1]
            for {set j 1} {$j<=$repeat_times} {incr j 1} {
                append cmd_list_exp " " \
                    [lrange $cmd_list $repeat_pos-$repeat_num $repeat_pos-1]
            }
            append cmd_list_exp " " [lrange $cmd_list $repeat_pos+1 end]
        } else {
            myputs "found no REPEAT cmd" 3
        }
        incr i
    }
    if $does_repeat {myputs "the expanded cmds $cmds looks:\n$cmd_list_exp\n"}
    if {[info exists regex_info($login_index)] && \
       ![string equal $regex_info($login_index) ""]} {
        myputs "get original regex_info:"
        myputs "$regex_info($login_index)\n"
        set regex_info_list $regex_info($login_index)
        foreach regex4onecmd $regex_info_list {
            myputs "\nget regex \{$regex4onecmd\}" 3
            set regex_vars_list [split $regex4onecmd "@"]
            set cmd_no [lindex $regex_vars_list 0]
            set cmd_no_index [expr $cmd_no - 1]
            myputs "cmd_no :$cmd_no,index $cmd_no_index in list index" 3
            if $does_repeat {
                if {$cmd_no_index < [expr $repeat_pos-$repeat_num]} {
                    myputs "cmd_no $cmd_no (index $cmd_no_index) not reach \
                        REPEAT area:\
                        [expr $repeat_pos-$repeat_num]-[expr $repeat_pos-1]\
                        ,just append" 3
                    lappend regex_info_list_exp $regex4onecmd
                    myputs "expanded list looks:$regex_info_list_exp" 3
                } elseif {$cmd_no_index >= $repeat_pos-$repeat_num && \
                          $cmd_no_index < $repeat_pos } {
                    myputs "cmd_no $cmd_no (index $cmd_no_index) fall in \
                        REPEAT area:\
                        [expr $repeat_pos-$repeat_num]-[expr $repeat_pos-1]" 3
                    myputs "will expand the number and append..."
                    for {set j 0} {$j<=$repeat_times} {incr j 1} {
                        set cmd_no_exp [expr $cmd_no + $repeat_num*$j]
                        regsub $cmd_no $regex4onecmd $cmd_no_exp regex4onecmd_exp
                        lappend regex_info_list_exp $regex4onecmd_exp
                        set regex_info_list_exp [lsort -dictionary $regex_info_list_exp]
                    }
                    myputs "expanded list looks:\n$regex_info_list_exp" 3
                } elseif {$cmd_no_index > $repeat_pos} {
                    myputs "cmd_no $cmd_no (index $cmd_no_index) fall after\
                        REPEAT area $repeat_pos so will expand the number and\
                        append" 3
                    set cmd_no_exp \
                      [expr $cmd_no+$repeat_num*$repeat_times-1]
                    regsub $cmd_no $regex4onecmd $cmd_no_exp regex4onecmd_exp
                    lappend regex_info_list_exp $regex4onecmd_exp
                    set regex_info_list_exp [lsort -dictionary $regex_info_list_exp]
                    myputs "expanded list looks:\n$regex_info_list_exp" 3
                } else {
                }
            }
        }
        if $does_repeat {
            myputs "\nthe final expanded regex_info looks:\n$regex_info_list_exp"
        }
    } else {
        myputs "regex_info not exists!"
    }
    if {[info exists issue_info($login_index)] && \
       ![string equal $issue_info($login_index) ""]} {
        myputs "get original issue_info:"
        myputs "$issue_info($login_index)\n"
        set issue_info_list $issue_info($login_index)
        foreach regex4onecmd $issue_info_list {
            myputs "\nget regex \{$regex4onecmd\}" 3
            set regex_vars_list [split $regex4onecmd "@"]
            set cmd_no [lindex $regex_vars_list 0]
            set cmd_no_index [expr $cmd_no - 1]
            myputs "cmd_no :$cmd_no,index $cmd_no_index in list index" 3
            if $does_repeat {
                if {$cmd_no_index < [expr $repeat_pos-$repeat_num]} {
                    myputs "cmd_no $cmd_no (index $cmd_no_index) not reach
                        REPEAT\ area:\
                        [expr $repeat_pos-$repeat_num]-[expr $repeat_pos-1]\
                        ,just append" 3
                    lappend issue_info_list_exp $regex4onecmd
                    myputs "expanded list looks:$issue_info_list_exp" 3
                } elseif {$cmd_no_index >= $repeat_pos-$repeat_num && \
                          $cmd_no_index < $repeat_pos } {
                    myputs "cmd_no $cmd_no (index $cmd_no_index) fall in \
                        REPEAT area:\
                        [expr $repeat_pos-$repeat_num]-[expr $repeat_pos-1]\
                        will expand the number and append..." 3
                    for {set j 0} {$j<=$repeat_times} {incr j 1} {
                        set cmd_no_exp [expr $cmd_no + $repeat_num*$j]
                        regsub $cmd_no $regex4onecmd $cmd_no_exp regex4onecmd_exp
                        lappend issue_info_list_exp $regex4onecmd_exp
                        set issue_info_list_exp [lsort -dictionary $issue_info_list_exp]
                    }
                    myputs "expanded list looks:\n$issue_info_list_exp" 3
                } elseif {$cmd_no_index > $repeat_pos} {
                    myputs "cmd_no $cmd_no (index $cmd_no_index) fall after\
                        REPEAT area $repeat_pos so will expand the number and\
                        append" 3
                    set cmd_no_exp \
                      [expr $cmd_no+$repeat_num*$repeat_times-1]
                    regsub $cmd_no $regex4onecmd $cmd_no_exp regex4onecmd_exp
                    lappend issue_info_list_exp $regex4onecmd_exp
                    set issue_info_list_exp [lsort -dictionary $issue_info_list_exp]
                    myputs "expanded list looks:\n$issue_info_list_exp" 3
                } else {
                }
            }
        }
        if $does_repeat {
            myputs "\nthe final expanded issue_info looks:\n$issue_info_list_exp"
        }
    } else {
        myputs "issue_info not exists!"
    }
}
if [expr $repeat_expand && $does_repeat] {
    set ${cmds}($login_index) $cmd_list_exp
    set regex_info($login_index) $regex_info_list_exp
    set issue_info($login_index) $issue_info_list_exp
    set ${cmds}_exp($login_index) $cmd_list_exp
    set regex_info_exp($login_index) $regex_info_list_exp
    set issue_info_exp($login_index) $issue_info_list_exp
}
eval $code_update_template
set log_filename [info_subs2 $log_filename] 
set log_filename [string tolower $log_filename]
if [string equal $log_fullname ""] {
    set log_fullname "$log_dir/$log_filename"
    set options(log_fullname) $log_fullname
    set options_inline(log_fullname) $log_fullname
}
if {[file exists $log_dir]} {
} else {
    myputs2 "dir $log_dir doesn't exist, creating one...\n"
    if [catch {file mkdir $log_dir} failed_reason] {
	myputs2 "failed to creating dir $log_dir: $failed_reason\n"
        set log_dir "/var/tmp"
    } else {
	myputs2 "...done!\n"
    }
}
if {[file exists $cmd_file_dir]} {
} elseif [array exists cmd_file] {
    myputs2 "dir $cmd_file_dir doesn't exist, creating one...\n"
    if [catch {file mkdir $cmd_file_dir} failed_reason] {
	myputs2 "failed to creating dir $cmd_file_dir: $failed_reason\n"
	exit [CONST EXIT_ON_FAIL_CREATE_LOG_DIR]
    } else {
	myputs2 "...done!\n"
    }
} else {
}
if {$log_when >= 3} {
    myputs "start logging before start logging in..."
    log_file $log_fullname
    catch {myputs2 "log file: $log_fullname\n"}
    send_log $log_seperator 
}
set login_info($login_index) [info_subs1 $login_info($login_index)]
eval $code_expect_user_patterns
set parallel_ori $parallel
set parallel 0
set options(parallel) 0
set options_inline(parallel) 0
foreach login_index $hostlist_full {
    reload_data $login_index
    myputs2 "<<<CRTC:$login_index:start to login, please wait ...\n"
    myputs2 "<<<CRTC:$login_index:to interupt the login automation and get the\
        control, press <ESC>!\n"
    myputs2 "<<<CRTC:$login_index:to exit script(kill): press <ESC> and !Q\n"
    set spawn_login_return [spawn_login $login_index]
    switch -exact -- $spawn_login_return {
        "RETURN_SPAWN_LOGIN_NORMAL" {
            puts "\n<<<CRTC:$login_index:login succeeded!\n"
            switch -exact -- $req_win_title_chg {
                "securecrt" {
                    puts "\033]2;$login_index\007"
                }
                "tmux" {
                    puts "\033k$login_index\033\\"
                }
            }
            if {$log_when==1} {
                myputs "start logging after successful login"
                if {[llength $hostlist_full] > 1} {log_file}
                log_file $log_fullname
                catch {myputs2 "log file: $log_fullname\n"}
                send_log $log_seperator 
            }
        }
        "CLOSE" {
            myputs "login to $login_index timeout, close the session!"
            if {[llength $hostlist_full]==1} {
                exit
            } else {
                set hostlist_full [ldelete $hostlist_full $login_index]
            }
        }
        "CONTINUE" {
            myputs "login to $login_index timeout, continue with the next host!"
        }
        "EXIT" {
            myputs "login to $login_index timeout, exit!"
            exit
        }
        "RETURN_SPAWN_LOGIN_LOCALSHELL" {
            puts "you are now in a new local bash!"
            puts "type !? for extra options..."
            if {$log_when==1} {
                myputs "start logging after successful login"
                if {[llength $hostlist_full] > 1} {log_file}
                log_file $log_fullname
                catch {myputs2 "log file: $log_fullname\n"}
                send_log $log_seperator 
            }
        } 
        default {
            myputs "unprocessed or unsupported spawn_login_return $spawn_login_return, exit!"
            exit
        }
    }
}
incr usage_progress     ;#1 no automation and interaction after login
set parallel $parallel_ori
set options(parallel) $parallel_ori
set options_inline(parallel) $parallel_ori
if [info exists cmds($login_index)] { 
    set cmds($login_index) [info_subs1 $cmds($login_index)]
}
if $login_only {
    myputs "login only!"
} else {
    if {$parallel} {
        if {[llength $hostlist_full] > 1} {
            if ![string equal [set ${cmds}($login_index)] ""] {
                myputs "execute $cmds in parallel after login $login_index!"
            }
        } else {
            if ![string equal [set ${cmds}($login_index)] ""] {
                myputs "execute $cmds after login $login_index!"
            }
        }
        if {$argc>0} {
            exec_cmds2 $login_index $cmds
        }
    } else {
        myputs "execute $cmds in sequence after login each host!"
        foreach login_index $hostlist_full {
            if ![string equal [set ${cmds}($login_index)] ""] {
                myputs "execute $cmds for host $login_index!"
                if {$argc>0} {
                    exec_cmds2 $login_index $cmds
                }
            }
        }
    }
} 
incr usage_progress     ;#2 no interaction after login and automation
if {[lsearch $email_on_event "EMAIL_LOG_ON_LOGIN"]>=0} {
    myputs "email_on_event set, will send email with log as attachment"
    if [info exists emailto] {
        myputs "emailto exists:$emailto, will send file $log_fullname in email"
        sendanemail $log_fullname $emailto
        myputs2 "log file $log_fullname was sent to $emailto \
            as attachment $log_filename\n"
    } else {
        myputs "email destination was not provided"
    }
}
myputs2 "<<<CRTC:$login_index:automation done\n"
if {$log_when==2} {
    myputs "start logging after all automation done"
    log_file $log_fullname
    catch {myputs2 "log file: $log_fullname\n"}
    send_log $log_seperator 
}
if $nointeract {
    myputs "output looks: $expect_out(buffer)" 2
    myputs2 "bye!:)\n"
    usage_stats $usage_progress
} else {
    incr usage_progress ;#3 interaction succeed
    usage_stats $usage_progress
    myinteract $login_index
}
